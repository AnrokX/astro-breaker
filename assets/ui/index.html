<!DOCTYPE html>
<html>
<head>
  <style>
    /* Base styles */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Arial', sans-serif;
      color: #eee;
      overflow: hidden;
      background-color: transparent;
    }
    
    /* Container for test buttons */
    #test-buttons-container {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
    }
    
    /* More styles... */
  </style>
</head>
<body>
  <link href="https://fonts.googleapis.com/css2?family=Permanent+Marker&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  
  <!-- Debug button for testing -->
  <button id="run-leaderboard-tests" style="
    position: fixed;
    top: 10px;
    right: 10px;
    background-color: #4CAF50;
    color: white;
    padding: 8px 15px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    z-index: 9999;
    border: none;
  ">Run Leaderboard Tests</button>
  
  <link href="https://fonts.googleapis.com/css2?family=Audiowide&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
  
  <!-- Add particles container -->
  <div class="particles"></div>
  
  <style>
    :root {
      --matrix-green: #00ff41;
      --matrix-dark: #0d0208;
      --matrix-light: #003b00;
      --blood-red: #ff1717;
      --dark-red: #8b0000;
      --glow-red: #ff000d;
      --terminal-green: #39ff14;
      --matrix-bg: rgba(0, 15, 2, 0.85);
      --title-font: 'Press Start 2P', cursive;
      --display-font: 'VT323', monospace;
      --number-font: 'VT323', monospace;
      --text-font: 'VT323', monospace;
    }

    /* Fixed orphaned CSS properties */

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }

    @keyframes shake {
      0%, 100% { transform: translate3d(0, 0, 0) rotate(0deg); }
      10%, 90% { transform: translate3d(-2px, 1px, 0) rotate(-1deg); }
      20%, 80% { transform: translate3d(3px, -1px, 0) rotate(1deg); }
      30%, 50%, 70% { transform: translate3d(-4px, 2px, 0) rotate(-2deg); }
      40%, 60% { transform: translate3d(4px, -2px, 0) rotate(2deg); }
    }

    .particles {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      overflow: hidden;
      z-index: -1;
    }

    .particle {
      position: absolute;
      width: 4px;
      height: 4px;
      background: var(--blood-red);
      border-radius: 50%;
      pointer-events: none;
      box-shadow: 0 0 5px var(--glow-red);
    }

    .scoreboard {
      position: fixed;
      top: 100px;
      left: 40px;
      background: rgba(0, 0, 0, 0.7);
      padding: 18px;
      border-radius: 10px;
      color: #ffffff;
      font-family: var(--text-font);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      min-width: 312px;
      z-index: 100;
      transform: scale(1.2);
      transform-origin: top left;
      will-change: transform; /* Optimize for performance */
      transition: transform 0.5s cubic-bezier(0.19, 1, 0.22, 1), 
                  opacity 0.5s cubic-bezier(0.19, 1, 0.22, 1);
      opacity: 1;
    }

    .scoreboard.hidden {
      transform: translateX(-120%) scale(1.2);
      opacity: 0;
      pointer-events: none;
    }

    @keyframes scoreboardSlideIn {
      0% {
        transform: translateX(-120%);
        opacity: 0;
      }
      100% {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes scoreboardSlideOut {
      0% {
        transform: translateX(0);
        opacity: 1;
      }
      100% {
        transform: translateX(-120%);
        opacity: 0;
      }
    }

    .leaderboard {
      position: fixed;
      top: 100px;
      right: 40px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 8px;
      color: #ffffff;
      font-family: var(--text-font);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      min-width: 260px;
      z-index: 100;
      will-change: transform; /* Optimize for performance */
      transition: transform 0.5s cubic-bezier(0.19, 1, 0.22, 1), 
                  opacity 0.5s cubic-bezier(0.19, 1, 0.22, 1);
      transform: translateX(0);
      opacity: 1;
    }
    
    /* States for leaderboard visibility */
    .leaderboard.hidden {
      transform: translateX(120%);
      opacity: 0;
    }
    
    .leaderboard.pre-game {
      transform: translateX(0);
      opacity: 1;
      background: rgba(0, 0, 0, 0.5);
    }

    .leaderboard-title {
      font-family: var(--title-font);
      font-size: 16px;
      color: #ffffff;
      margin-bottom: 15px;
      padding-bottom: 8px;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 1px;
      position: relative;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    #leaderboard-container {
      transition: opacity 0.2s ease;
    }

    .leaderboard-entry {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(0, 0, 0, 0.3);
      margin: 6px 0;
      padding: 10px 12px;
      border-radius: 4px;
      border-left: 3px solid transparent;
      transition: background 0.2s ease, transform 0.3s ease, opacity 0.3s ease;
      position: relative;
      opacity: 1;
      transform: translateX(0);
    }

    .leaderboard-entry:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .leaderboard-entry.winner {
      background: rgba(255, 215, 0, 0.15);
      border-left-color: #ffd700;
    }
    
    .leaderboard-entry.current-player {
      background: rgba(255, 255, 255, 0.1);
      border-left-color: #ffffff;
    }
    
    /* Entry animations */
    .leaderboard-entry.new-entry {
      animation: newEntryAnimation 0.6s ease forwards;
    }
    
    .leaderboard-entry.rank-changed {
      animation: rankChangedAnimation 0.8s ease;
    }
    
    .leaderboard-entry.score-updated {
      animation: scoreUpdatedAnimation 0.4s ease;
    }
    
    @keyframes newEntryAnimation {
      0% {
        opacity: 0;
        transform: translateX(20px);
      }
      100% {
        opacity: 1;
        transform: translateX(0);
      }
    }
    
    @keyframes rankChangedAnimation {
      0% {
        background: rgba(255, 255, 255, 0.3);
      }
      100% {
        background: rgba(0, 0, 0, 0.3);
      }
    }
    
    @keyframes scoreUpdatedAnimation {
      0%, 100% {
        background: rgba(0, 0, 0, 0.3);
      }
      50% {
        background: rgba(76, 175, 80, 0.2);
      }
    }

    .player-name {
      font-family: var(--text-font);
      font-size: 14px;
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .player-info {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .player-rank {
      font-family: var(--number-font);
      font-size: 18px;
      min-width: 25px;
      text-align: center;
      opacity: 0.8;
    }
    
    /* Remove avatar styling completely */
    .player-avatar {
      display: none;
    }
    
    .player-avatar.large {
      display: none;
    }
    
    .rank-change {
      font-size: 12px;
      margin: 0 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      position: relative;
      transition: transform 0.3s ease;
    }
    
    .rank-up {
      color: #4CAF50;
      animation: rankUpAnimation 0.6s ease;
    }
    
    .rank-down {
      color: #F44336;
      animation: rankDownAnimation 0.6s ease;
    }
    
    .rank-same {
      color: #FFD700;
    }
    
    .rank-new {
      color: #2196F3;
      animation: rankNewAnimation 0.8s ease;
    }
    
    @keyframes rankUpAnimation {
      0% {
        transform: translateY(5px);
        opacity: 0;
      }
      100% {
        transform: translateY(0);
        opacity: 1;
      }
    }
    
    @keyframes rankDownAnimation {
      0% {
        transform: translateY(-5px);
        opacity: 0;
      }
      100% {
        transform: translateY(0);
        opacity: 1;
      }
    }
    
    @keyframes rankNewAnimation {
      0% {
        transform: scale(0);
        opacity: 0;
      }
      50% {
        transform: scale(1.5);
      }
      100% {
        transform: scale(1);
        opacity: 1;
      }
    }
    
    @keyframes pulse-green {
      0% { transform: scale(1); text-shadow: 0 0 2px rgba(76, 175, 80, 0.5); }
      50% { transform: scale(1.1); text-shadow: 0 0 10px rgba(76, 175, 80, 0.8); }
      100% { transform: scale(1); text-shadow: 0 0 2px rgba(76, 175, 80, 0.5); }
    }
    
    @keyframes pulse-red {
      0% { transform: scale(1); text-shadow: 0 0 2px rgba(244, 67, 54, 0.5); }
      50% { transform: scale(1.1); text-shadow: 0 0 10px rgba(244, 67, 54, 0.8); }
      100% { transform: scale(1); text-shadow: 0 0 2px rgba(244, 67, 54, 0.5); }
    }
    
    @keyframes sparkle {
      0% { transform: scale(1) rotate(0deg); text-shadow: 0 0 5px rgba(33, 150, 243, 0.7); }
      25% { transform: scale(1.2) rotate(15deg); text-shadow: 0 0 15px rgba(33, 150, 243, 1); }
      50% { transform: scale(1) rotate(0deg); text-shadow: 0 0 5px rgba(33, 150, 243, 0.7); }
      75% { transform: scale(1.2) rotate(-15deg); text-shadow: 0 0 15px rgba(33, 150, 243, 1); }
      100% { transform: scale(1) rotate(0deg); text-shadow: 0 0 5px rgba(33, 150, 243, 0.7); }
    }
    
    /* Remove the staggered animation keyframes */

    .player-wins {
      font-family: var(--number-font);
      font-size: 20px;
      letter-spacing: 0.5px;
      font-weight: bold;
      position: relative;
    }
    
    /* Score change animation */
    .player-wins.score-change::after {
      content: attr(data-diff);
      position: absolute;
      right: 0;
      top: -15px;
      font-size: 14px;
      color: #4CAF50;
      opacity: 0;
      animation: scoreChangeAnimation 1.5s ease-out forwards;
    }
    
    @keyframes scoreChangeAnimation {
      0% {
        opacity: 0;
        transform: translateY(0);
      }
      20% {
        opacity: 1;
      }
      80% {
        opacity: 1;
        transform: translateY(-15px);
      }
      100% {
        opacity: 0;
        transform: translateY(-20px);
      }
    }

    .round-info {
      border-bottom: 1px solid var(--blood-red);
      padding-bottom: 15px;
      margin-bottom: 15px;
    }

    .waiting-message {
      font-family: var(--display-font);
      font-size: 16px;
      letter-spacing: 2px;
    }

    .player-count {
      font-size: 18px;
      color: #ffffff;
      text-align: left;
    }

    .round-number {
      font-family: var(--display-font);
      font-size: 16px;
      color: var(--blood-red);
      text-shadow: 0 0 10px var(--glow-red);
      letter-spacing: 1px;
      margin-bottom: 8px;
    }

    .round-timer {
      position: fixed;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      font-family: var(--display-font);
      font-size: 32px;
      color: #ffffff;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
      background: rgba(0, 0, 0, 0.7);
      padding: 15px 30px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      z-index: 10000;  /* Increased z-index to ensure it's above other elements */
      text-align: center;
      min-width: 100px;
      pointer-events: none;  /* Ensure it doesn't interfere with clicking */
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
    }

    .round-timer.warning {
      color: var(--blood-red);
      text-shadow: 0 0 10px var(--glow-red);
    }

    .round-timer.danger {
      color: var(--blood-red);
      text-shadow: 0 0 15px var(--glow-red);
      animation: matrix-flicker 0.5s infinite;
    }

    @keyframes matrix-pulse {
      0% { opacity: 0.8; text-shadow: 0 0 5px var(--glow-red); }
      50% { opacity: 1; text-shadow: 0 0 20px var(--glow-red); }
      100% { opacity: 0.8; text-shadow: 0 0 5px var(--glow-red); }
    }

    @keyframes matrix-flicker {
      0% { opacity: 0.8; text-shadow: 0 0 10px var(--glow-red); }
      25% { opacity: 0.3; }
      50% { opacity: 1; text-shadow: 0 0 30px var(--glow-red); }
      75% { opacity: 0.5; }
      100% { opacity: 0.8; text-shadow: 0 0 10px var(--glow-red); }
    }

    .score-target {
      font-size: 14px;
      color: #4CAF50;
    }

    .scores-wrapper {
      width: 100%;
    }

    .scores-title {
      font-family: var(--title-font);
      font-size: 24px;
      color: #ffffff;
      margin-bottom: 18px;
      padding-bottom: 10px;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 1px;
      position: relative;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* Add animation for individual score entries */
    .player-score {
      animation: scoreEntryFadeIn 0.4s ease-out forwards;
      animation-delay: calc(var(--index, 0) * 0.1s);
      opacity: 0;
      transform: translateX(-20px);
    }

    @keyframes scoreEntryFadeIn {
      0% {
        opacity: 0;
        transform: translateX(-20px);
      }
      100% {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .player-score {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(0, 0, 0, 0.3);
      margin: 7px 0;
      padding: 12px 14px;
      border-radius: 5px;
      border-left: 4px solid transparent;
      transition: background 0.2s ease, transform 0.3s ease, opacity 0.3s ease;
      position: relative;
      opacity: 1;
      transform: translateX(0);
    }
    
    .player-score.current-player {
      background: rgba(255, 255, 255, 0.1);
      border-left-color: #ffffff;
    }
    
    .player-score:hover {
      background: rgba(255, 255, 255, 0.1);
    }
    
    .player-indicator {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .player-avatar {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: inline-block;
      box-shadow: 0 0 8px rgba(255, 255, 255, 0.4);
    }
    
    .player-avatar.large {
      width: 32px;
      height: 32px;
      margin-right: 10px;
      box-shadow: 0 0 12px rgba(255, 255, 255, 0.6);
    }
    
    .player-label {
      font-size: 19px;
      letter-spacing: 0.5px;
      text-shadow: none;
    }
    
    .player-you-tag {
      font-size: 12px;
      background: rgba(255, 255, 255, 0.15);
      padding: 2px 5px;
      border-radius: 3px;
      margin-left: 6px;
      color: white;
      font-weight: bold;
    }
    
    .score-info {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 10px;
    }

    .score-value {
      font-family: var(--number-font);
      font-size: 26px;
      letter-spacing: 0.6px;
      font-weight: bold;
      position: relative;
    }
    
    .round-score {
      font-size: 19px;
      opacity: 0.7;
      color: rgba(255, 255, 255, 0.8);
      animation: pulseScore 1.5s ease-out;
      margin-left: 5px;
    }
    
    @keyframes pulseScore {
      0% { opacity: 1; transform: scale(1.1); }
      70% { opacity: 0.8; }
      100% { opacity: 0.7; transform: scale(1); }
    }

    .crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: var(--crosshair-size, 24px);
      height: var(--crosshair-size, 24px);
      pointer-events: none;
      z-index: 1000;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* Outer circle */
    .crosshair::before {
      content: '';
      position: absolute;
      width: var(--ring-size, 20px);
      height: var(--ring-size, 20px);
      border: 2px solid var(--crosshair-color, rgba(255, 255, 0, 0.8));
      border-radius: 50%;
      box-shadow: 0 0 4px var(--crosshair-glow, #ffff00),
                  inset 0 0 4px var(--crosshair-glow, #ffff00),
                  0 0 0 1px rgba(0, 0, 0, 0.5);
      display: var(--show-ring, block);
    }

    /* Center dot */
    .crosshair::after {
      content: '';
      position: absolute;
      width: var(--dot-size, 4px);
      height: var(--dot-size, 4px);
      background-color: var(--crosshair-color, rgba(255, 255, 0, 0.9));
      border-radius: 50%;
      box-shadow: 0 0 4px var(--crosshair-glow, #ffff00),
                  0 0 2px rgba(0, 0, 0, 0.8);
      display: var(--show-dot, block);
    }

    /* Scene UI Container and Notifications */
    .scene-ui-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1000;
    }

    .hit-notification {
      position: absolute;
      transform: translate(-50%, -50%);
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 1001;
    }

    .hit-notification .score {
      /* Using dynamic colors from SceneUIManager */
      font-family: var(--display-font);
      font-size: 28px;
      animation: hitNotification 1s cubic-bezier(0.22, 1, 0.36, 1) forwards;
      opacity: 0;
      transform: scale(0.5) translateZ(0);
      transform-origin: center center;
    }

    .block-destroyed-notification {
      position: absolute;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      pointer-events: none;
      z-index: 1001;
    }

    .block-destroyed-notification .score {
      font-family: var(--display-font);
      font-size: 48px;
      font-weight: bold;
      opacity: 0;
      transform: scale(0.5) translateZ(0);
      transform-origin: center center;
      perspective: 1000px;
      --pop-intensity: calc(var(--score-value, 0) * 0.01);
    }

    @keyframes scoreAnimation {
      0% {
        opacity: 0;
        transform: scale(0.5) translateZ(-300px) translateY(calc(50px * var(--pop-intensity))) rotate3d(1, 0, 0, -45deg);
      }
      15% {
        opacity: 1;
        transform: scale(1.8) translateZ(200px) translateY(calc(-100px * var(--pop-intensity))) rotate3d(1, 0, 0, 30deg);
      }
      30% {
        opacity: 1;
        transform: scale(2) translateZ(150px) translateY(calc(-150px * var(--pop-intensity))) rotate3d(1, 0, 0, 15deg);
      }
      50% {
        opacity: 1;
        transform: scale(1.8) translateZ(100px) translateY(calc(-200px * var(--pop-intensity))) rotate3d(1, 0, 0, 0deg);
      }
      70% {
        opacity: 0.9;
        transform: scale(1.5) translateZ(50px) translateY(calc(-250px * var(--pop-intensity))) rotate3d(1, 0, 0, -10deg);
      }
      85% {
        opacity: 0.7;
        transform: scale(1.2) translateZ(25px) translateY(calc(-300px * var(--pop-intensity))) rotate3d(1, 0, 0, -20deg);
      }
      100% {
        opacity: 0;
        transform: scale(1) translateZ(0) translateY(calc(-350px * var(--pop-intensity))) rotate3d(1, 0, 0, -30deg);
      }
    }

    /* Settings Menu */
    .settings-menu {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.95);
      background: rgba(0, 0, 0, 0.7);
      padding: 45px; /* Reduced from 60px */
      border-radius: 15px; /* Reduced from 20px */
      color: #ffffff;
      font-family: var(--text-font);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      z-index: 2000;
      min-width: 525px; /* Reduced from 700px */
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .settings-menu.visible {
      opacity: 1;
      visibility: visible;
    }

    .settings-title {
      font-family: var(--title-font);
      font-size: 36px; /* Reduced from 48px */
      color: #ffffff;
      text-align: center;
      margin-bottom: 38px; /* Reduced from 50px */
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
      letter-spacing: 3px; /* Reduced from 4px */
    }

    .settings-section {
      margin-bottom: 30px; /* Reduced from 40px */
      padding: 23px; /* Reduced from 30px */
      background: rgba(0, 0, 0, 0.3);
      border-radius: 11px; /* Reduced from 15px */
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .settings-section-title {
      font-family: var(--title-font);
      font-size: 36px; /* Reduced from 48px */
      color: #ffffff;
      margin-bottom: 30px; /* Reduced from 40px */
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
      letter-spacing: 2px; /* Reduced from 3px */
      text-transform: uppercase;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding-bottom: 15px; /* Reduced from 20px */
    }

    .settings-option {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 23px 0; /* Reduced from 30px */
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .settings-option:last-child {
      border-bottom: none;
    }

    .settings-label {
      font-size: 24px; /* Reduced from 32px */
      color: #ffffff;
      text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
      letter-spacing: 1.5px; /* Reduced from 2px */
    }

    .settings-value {
      display: flex;
      align-items: center;
      gap: 23px; /* Reduced from 30px */
    }

    .settings-button {
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.1);
      padding: 15px 30px; /* Reduced from 20px 40px */
      border-radius: 9px; /* Reduced from 12px */
      color: white;
      font-family: var(--text-font);
      font-size: 24px; /* Reduced from 32px */
      cursor: pointer;
      transition: all 0.3s ease;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      margin-top: 23px; /* Reduced from 30px */
      letter-spacing: 1.5px; /* Reduced from 2px */
    }

    .settings-button:hover {
      transform: translateY(-2px);
      background: rgba(255, 255, 255, 0.1);
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
    }

    .settings-button:active {
      transform: translateY(0);
    }

    /* Settings overlay background */
    .settings-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(3px);
      z-index: 1999;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

    .settings-overlay.visible {
      opacity: 1;
      visibility: visible;
    }

    .color-dropdown {
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: white;
      padding: 11px 19px; /* Reduced from 15px 25px */
      border-radius: 6px; /* Reduced from 8px */
      font-family: var(--text-font);
      font-size: 21px; /* Reduced from 28px */
      cursor: pointer;
      margin-right: 15px; /* Reduced from 20px */
      min-width: 150px; /* Reduced from 200px */
      letter-spacing: 0.75px; /* Reduced from 1px */
    }

    .color-dropdown option {
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 11px; /* Reduced from 15px */
      font-size: 21px; /* Reduced from 28px */
    }

    .color-controls {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    input[type="range"] {
      width: 300px;
      height: 12px;
    }

    input[type="color"] {
      width: 70px;
      height: 70px;
      padding: 0;
      border: none;
      border-radius: 8px;
    }

    #sensitivity-value {
      font-size: 32px;
      min-width: 60px;
      text-align: center;
      letter-spacing: 2px;
    }

    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 28px;
      color: white;
      cursor: pointer;
    }

    .checkbox-label input[type="checkbox"] {
      width: 24px;
      height: 24px;
      cursor: pointer;
    }

    #global-size-value,
    #ring-size-value,
    #dot-size-value {
      font-size: 32px;
      min-width: 80px;
      text-align: center;
      letter-spacing: 2px;
    }

    /* Updated HUD Guide Styles */
    .scoring-guide-hud {
      position: fixed;
      left: 40px;
      top: 300px; /* Moved down further */
      background: linear-gradient(135deg, var(--matrix-dark) 0%, rgba(13, 2, 8, 0.85) 100%);
      padding: 15px;
      border-radius: 10px;
      color: #ffffff;
      font-family: var(--text-font);
      border: 1px solid var(--blood-red);
      box-shadow: 0 0 15px rgba(255, 0, 0, 0.15);
      max-width: 320px; /* Increased width */
      opacity: 0.85;
      transition: opacity 0.3s;
    }

    .scoring-guide-hud .guide-header {
      font-family: var(--title-font);
      font-size: 16px; /* Bigger header */
      color: var(--blood-red);
      margin-bottom: 10px;
      letter-spacing: 1.5px;
      text-align: center;
    }

    .scoring-guide-hud .guide-item {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 15px; /* Bigger text */
      letter-spacing: 0.5px;
      padding: 4px 0;
    }

    .scoring-guide-hud .guide-icon {
      font-size: 18px; /* Bigger icons */
      min-width: 25px;
      text-align: center;
    }

    /* Subtle HUD Hotkey Hints */
    .hotkey-hints {
      position: fixed;
      right: 250px;   /* Moved even more to the left (from 150px) */
      bottom: 40px;
      display: flex;
      gap: 20px;
      font-family: var(--display-font);
      font-size: 18px;
      opacity: 0.7;
      transition: opacity 0.3s;
      background: rgba(0, 0, 0, 0.3);
      padding: 10px 15px;
      border-radius: 8px;
      z-index: 999;
    }

    .hotkey-hints:hover {
      opacity: 1;
    }

    .hotkey-hint {
      color: var(--matrix-green);
      text-shadow: 0 0 8px var(--terminal-green);
      letter-spacing: 0.5px;
    }

    /* Add combo notification styles directly here */
    .combo-notification {
      position: fixed;
      left: 50%;
      bottom: 80px;  /* Moved lower, closer to the bottom */
      transform: translateX(-50%);
      pointer-events: none;
      font-family: var(--display-font);
      text-align: center;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .combo-notification.active {
      opacity: 1;
    }

    .combo-counter {
      background: rgba(0, 0, 0, 0.3);
      padding: 4px 12px;
      border-radius: 4px;
      backdrop-filter: blur(2px);
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 8px;
      justify-content: center;
    }

    .combo-hits {
      font-size: 24px;
      font-weight: bold;
      color: var(--matrix-green);
      text-shadow: 0 0 6px var(--terminal-green);
      opacity: 0.9;
    }

    .combo-text {
      font-size: 18px;
      color: rgba(255, 255, 255, 0.8);
      text-shadow: 0 0 4px rgba(255, 255, 255, 0.4);
      letter-spacing: 1px;
    }

    .combo-bonus {
      font-size: 16px;
      color: rgba(255, 255, 0, 0.8);
      text-shadow: 0 0 4px rgba(255, 255, 0, 0.4);
      letter-spacing: 1px;
      margin-left: 4px;
    }

    @keyframes comboSlideIn {
      from {
        transform: translateX(-50%) translateY(20px);
        opacity: 0;
      }
      to {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
      }
    }

    /* Combo tiers with different colors */
    .combo .combo-hits { 
      color: rgba(255, 255, 255, 0.9);
      text-shadow: 0 0 4px rgba(255, 255, 255, 0.4);
    }
    .super-combo .combo-hits { 
      color: rgba(0, 255, 255, 0.9);
      text-shadow: 0 0 4px rgba(0, 255, 255, 0.4);
    }
    .ultra-combo .combo-hits { 
      color: rgba(255, 0, 255, 0.9);
      text-shadow: 0 0 4px rgba(255, 0, 255, 0.4);
    }
    .mega-combo .combo-hits { 
      color: rgba(255, 0, 0, 0.9);
      text-shadow: 0 0 4px rgba(255, 0, 0, 0.4);
    }

    .system-message {
      position: fixed;
      top: 20%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: var(--display-font);
      font-size: 24px;
      color: var(--blood-red);
      text-shadow: 0 0 10px var(--glow-red);
      background: rgba(13, 2, 8, 0.9);
      padding: 15px 30px;
      border-radius: 8px;
      border: 1px solid var(--blood-red);
      z-index: 1000;
      animation: fadeInOut 4s ease-in-out;
    }

    @keyframes fadeInOut {
      0% { opacity: 0; transform: translate(-50%, -60%); }
      10% { opacity: 1; transform: translate(-50%, -50%); }
      90% { opacity: 1; transform: translate(-50%, -50%); }
      100% { opacity: 0; transform: translate(-50%, -40%); }
    }

    .round-end {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.7);
      padding: 21px;
      border-radius: 11px;
      color: #ffffff;
      font-family: var(--text-font);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 3px 14px rgba(0, 0, 0, 0.5);
      z-index: 1000;
      min-width: 364px;
      will-change: transform;
      transition: transform 0.5s cubic-bezier(0.19, 1, 0.22, 1), 
                 opacity 0.5s cubic-bezier(0.19, 1, 0.22, 1);
    }
    
    .round-end-title {
      font-family: var(--title-font);
      font-size: 22px;
      color: #ffffff;
      margin-bottom: 21px;
      padding-bottom: 11px;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 1px;
      position: relative;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .round-end-placement {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(0, 0, 0, 0.3);
      margin: 8px 0;
      padding: 14px 17px;
      border-radius: 6px;
      border-left: 4px solid transparent;
      transition: background 0.2s ease, transform 0.3s ease, opacity 0.3s ease;
      position: relative;
      opacity: 1;
      transform: translateX(0);
    }

    .round-end-placement:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .round-end-placement.first {
      background: rgba(255, 215, 0, 0.15);
      border-left-color: #ffd700;
    }
    
    .round-end-placement.current-player {
      background: rgba(255, 255, 255, 0.1);
      border-left-color: #ffffff;
    }
    
    .round-end-placement .player-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .round-end-placement .player-name {
      font-family: var(--text-font);
      font-size: 20px;
      letter-spacing: 1px;
    }
    
    .round-end-placement .player-avatar {
      display: none;
    }

    .placement-rank {
      font-family: var(--number-font);
      font-size: 22px;
      min-width: 42px;
    }

    .placement-points {
      font-family: var(--number-font);
      font-size: 22px;
      letter-spacing: 1px;
    }
    
    .round-end-placements {
      margin: 21px 0;
    }

    .next-round-timer {
      font-family: var(--display-font);
      font-size: 20px;
      color: #ffffff;
      margin-top: 21px;
      padding: 14px;
      border-radius: 6px;
      background: rgba(0, 0, 0, 0.3);
      text-align: center;
    }

    .round-complete-message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: var(--display-font);
      font-size: 34px;
      color: #ffffff;
      background: rgba(0, 0, 0, 0.7);
      padding: 21px 42px;
      border-radius: 11px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 3px 14px rgba(0, 0, 0, 0.5);
      z-index: 1000;
      text-align: center;
      backdrop-filter: blur(10px);
    }

    @keyframes pulseCenter {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.05); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }

    /* Game status elements */
    .game-status {
      position: fixed;
      top: 40px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
      pointer-events: none;
      z-index: 1000;
    }

    .game-status .round-number {
      font-family: var(--display-font);
      font-size: 32px;
      color: #ffffff;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
      text-align: center;
      background: rgba(13, 2, 8, 0.9);
      padding: 5px 20px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      margin-bottom: 5px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
    }

    .game-status .round-timer {
      font-family: var(--display-font);
      font-size: 24px;
      color: #ffffff;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
      text-align: center;
      background: rgba(0, 0, 0, 0.7);
      padding: 5px 15px;
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
    }

    .game-status.waiting {
      border-color: rgba(255, 255, 255, 0.1);
    }

    .game-status.waiting .round-number,
    .game-status.waiting .round-timer {
      color: #ffffff;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
    }

    .scores-title {
      font-family: var(--display-font);
      font-size: 24px;
      color: var(--blood-red);
      text-shadow: 0 0 10px var(--glow-red);
      margin-bottom: 15px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    /* Add this to the style section */
    .game-end-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, rgba(13, 2, 8, 0.95) 0%, rgba(13, 2, 8, 0.98) 100%);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 2000;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.5s ease;
    }

    .game-end-overlay.visible {
        opacity: 1;
        pointer-events: auto;
    }

    .game-end-content {
        background: linear-gradient(135deg, var(--matrix-dark) 0%, rgba(13, 2, 8, 0.95) 100%);
        padding: 40px;
        border-radius: 20px;
        border: 3px solid var(--blood-red);
        box-shadow: 0 0 50px rgba(255, 0, 0, 0.3),
                    inset 0 0 25px rgba(255, 0, 0, 0.2);
        text-align: center;
        max-width: 800px;
        width: 90%;
    }

    .game-end-title {
        font-family: var(--title-font);
        font-size: 64px;
        color: var(--blood-red);
        text-shadow: 0 0 20px var(--glow-red);
        margin-bottom: 30px;
        letter-spacing: 4px;
        animation: titlePulse 2s infinite;
    }

    .winner-announcement {
        font-family: var(--display-font);
        font-size: 48px;
        color: #ffd700;
        text-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        margin-bottom: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .final-standings {
        margin: 30px 0;
        width: 100%;
    }
    
    .standing-player-info {
        display: flex;
        align-items: center;
        gap: 12px;
        min-width: 150px;
    }
    
    .standing-stats {
        display: flex;
        gap: 30px;
        align-items: center;
        flex-wrap: wrap;
        justify-content: center;
    }

    .standing-entry {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: linear-gradient(90deg, rgba(255, 0, 0, 0.1) 0%, transparent 100%);
        margin: 10px 0;
        padding: 20px;
        border-radius: 10px;
        border: 1px solid rgba(255, 0, 0, 0.2);
        transition: all 0.3s ease;
    }

    .standing-entry.winner {
        background: linear-gradient(90deg, rgba(255, 215, 0, 0.2) 0%, transparent 100%);
        border: 1px solid #ffd700;
    }
    
    .medal {
        font-size: 24px;
        display: inline-block;
        transform-origin: center;
        animation: medalPulse 2s infinite alternate;
        filter: drop-shadow(0px 0px 5px rgba(255, 255, 255, 0.5));
        text-align: center;
    }
    
    /* Medal styling for leaderboard tables */
    .leaderboard-table .medal {
        font-size: 20px;
        display: flex;
        justify-content: center;
        width: 100%;
    }
    
    .medal.gold {
        animation: goldMedalShine 3s infinite;
    }
    
    .medal.silver {
        animation: silverMedalShine 3s infinite;
    }
    
    .medal.bronze {
        animation: bronzeMedalShine 3s infinite;
    }
    
    @keyframes medalPulse {
        0% { transform: scale(1); }
        100% { transform: scale(1.1); }
    }
    
    @keyframes goldMedalShine {
        0% { filter: drop-shadow(0px 0px 3px rgba(255, 215, 0, 0.5)); }
        50% { filter: drop-shadow(0px 0px 10px rgba(255, 215, 0, 0.8)); }
        100% { filter: drop-shadow(0px 0px 3px rgba(255, 215, 0, 0.5)); }
    }
    
    @keyframes silverMedalShine {
        0% { filter: drop-shadow(0px 0px 3px rgba(192, 192, 192, 0.5)); }
        50% { filter: drop-shadow(0px 0px 10px rgba(192, 192, 192, 0.8)); }
        100% { filter: drop-shadow(0px 0px 3px rgba(192, 192, 192, 0.5)); }
    }
    
    @keyframes bronzeMedalShine {
        0% { filter: drop-shadow(0px 0px 3px rgba(205, 127, 50, 0.5)); }
        50% { filter: drop-shadow(0px 0px 10px rgba(205, 127, 50, 0.8)); }
        100% { filter: drop-shadow(0px 0px 3px rgba(205, 127, 50, 0.5)); }
    }

    .standing-position {
        font-family: var(--number-font);
        font-size: 36px;
        color: var(--matrix-green);
        min-width: 60px;
        text-align: center;
    }

    .standing-stats {
        display: flex;
        gap: 30px;
        align-items: center;
    }

    .standing-stat {
        text-align: center;
    }

    .stat-label {
        font-family: var(--text-font);
        font-size: 16px;
        color: rgba(255, 255, 255, 0.7);
        margin-bottom: 5px;
    }

    .stat-value {
        font-family: var(--number-font);
        font-size: 32px;
        color: var(--matrix-green);
        text-shadow: 0 0 10px var(--terminal-green);
    }

    .next-game-timer {
        font-family: var(--display-font);
        font-size: 24px;
        color: rgba(255, 255, 255, 0.8);
        margin-top: 30px;
    }

    @keyframes titlePulse {
        0% { text-shadow: 0 0 20px var(--glow-red); }
        50% { text-shadow: 0 0 40px var(--glow-red); }
        100% { text-shadow: 0 0 20px var(--glow-red); }
    }

    .scoring-guide-hud .guide-icon {
      font-size: 18px; /* Bigger icons */
      min-width: 25px;
      text-align: center;
    }

    /* Help Menu Styles */
    .help-menu {
      position: fixed;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      background: linear-gradient(135deg, var(--matrix-dark) 0%, rgba(13, 2, 8, 0.95) 100%);
      border: 2px solid var(--blood-red);
      border-radius: 15px;
      color: #ffffff;
      padding: 25px;
      display: none;
      z-index: 1000;
      min-width: 400px;
      box-shadow: 0 0 30px rgba(255, 0, 0, 0.2);
      font-family: var(--text-font);
    }

    .help-menu.visible {
      display: block;
      animation: slideIn 0.3s ease-out;
    }

    .help-menu.closing {
      animation: slideOut 0.3s ease-in;
    }

    @keyframes slideIn {
      from { transform: translateY(-50%) translateX(50px); opacity: 0; }
      to { transform: translateY(-50%) translateX(0); opacity: 1; }
    }

    @keyframes slideOut {
      from { transform: translateY(-50%) translateX(0); opacity: 1; }
      to { transform: translateY(-50%) translateX(50px); opacity: 0; }
    }

    .help-content {
      font-family: var(--text-font);
      font-size: 18px;
    }

    .help-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 2px solid var(--blood-red);
    }

    .help-title {
      font-family: var(--title-font);
      font-size: 28px;
      color: var(--blood-red);
      letter-spacing: 2px;
      text-shadow: 0 0 10px rgba(255, 0, 0, 0.4);
    }

    .help-key {
      background: rgba(255, 0, 0, 0.2);
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 16px;
      color: var(--blood-red);
      border: 1px solid var(--blood-red);
      text-shadow: 0 0 8px var(--glow-red);
      font-family: var(--display-font);
    }

    .help-section {
      margin-bottom: 25px;
    }

    .help-section h3 {
      font-family: var(--title-font);
      font-size: 20px;
      color: var(--blood-red);
      margin-bottom: 15px;
      letter-spacing: 1px;
      text-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
    }

    .guide-items {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .guide-item {
      display: flex;
      align-items: center;
      gap: 15px;
      font-size: 20px;
      font-family: var(--text-font);
    }

    .guide-text {
      font-family: var(--text-font);
      font-size: 20px;
    }

    .guide-icon {
      font-size: 24px;
      min-width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 0, 0, 0.1);
      border-radius: 50%;
    }

    .control-item {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-bottom: 10px;
    }

    .control-item .key {
      background: rgba(255, 255, 255, 0.1);
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 16px;
      min-width: 60px;
      text-align: center;
      font-family: var(--display-font);
      border: 1px solid rgba(255, 0, 0, 0.3);
      text-shadow: 0 0 5px var(--glow-red);
    }

    .control-item .action {
      font-size: 20px;
      color: rgba(255, 255, 255, 0.9);
      text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
      font-family: var(--text-font);
    }

    /* Subtle HUD Hotkey Hints */
    
    /* Game mode selection */
    #game-mode-select {
      padding: 8px 12px;
      background-color: #2a2a2a;
      color: white;
      border: 1px solid #555;
      border-radius: 4px;
      outline: none;
      font-family: inherit;
      cursor: pointer;
      width: 140px;
      font-size: 14px;
      transition: all 0.2s ease;
    }
    
    #game-mode-select:hover {
      background-color: #3a3a3a;
      border-color: #888;
    }
    
    #game-mode-select option {
      background-color: #2a2a2a;
      color: white;
      padding: 8px;
    }

    /* Game Mode Selection Modal */
    #game-mode-selection {
      /* Initially hidden, will be shown via JavaScript */
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 500px;
      background: rgba(0, 0, 0, 0.95);
      border: 3px solid rgba(255, 255, 255, 0.8);
      border-radius: 10px;
      padding: 30px;
      color: white;
      text-align: center;
      z-index: 10000; /* Ensure it's above everything */
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
    }

    #game-mode-selection h2 {
      font-family: var(--title-font);
      font-size: 38px;
      margin-bottom: 25px;
      color: #FFC107;
      text-shadow: 0 0 10px rgba(255, 193, 7, 0.5);
    }

    #game-mode-selection .mode-buttons {
      display: flex;
      justify-content: center;
      margin-top: 30px;
    }

    #game-mode-selection button {
      background: linear-gradient(to bottom, #134e5e, #71b280);
      color: white;
      border: 2px solid white;
      border-radius: 8px;
      padding: 15px 30px;
      font-family: var(--text-font);
      font-size: 24px;
      cursor: pointer;
      transition: all 0.3s;
      min-width: 180px;
    }

    #game-mode-selection button:hover {
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
    }

    #game-mode-selection button#solo-mode {
      background: linear-gradient(to bottom, #4a00e0, #8e2de2);
      font-size: 32px;
      padding: 25px 40px;
      min-width: 320px;
      margin: 10px auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 15px;
    }

    /* Main text in button */
    .button-main-text {
      font-size: 32px;
      font-weight: bold;
      margin-bottom: 5px;
    }

    /* Key hint styling */
    .key-hint {
      font-size: 32px;
      opacity: 1;
      margin-left: 10px;
      font-weight: bold;
      color: #FFC107;
      text-shadow: 0 0 8px rgba(255, 193, 7, 0.7);
    }
    
    /* Retro prompt styling */
    .retro-prompt {
      font-family: var(--title-font);
      font-size: 22px;
      font-weight: bold;
      color: #FF3366;
      letter-spacing: 2px;
      text-shadow: 0 0 10px rgba(255, 51, 102, 0.7);
      animation: pulse 1.2s infinite alternate;
      margin-top: 5px;
    }
    
    @keyframes pulse {
      from {
        opacity: 0.7;
        transform: scale(0.97);
      }
      to {
        opacity: 1;
        transform: scale(1.03);
      }
    }
    
    .retro-prompt .key-label {
      display: inline-block;
      background: #FF3366;
      color: white;
      padding: 2px 12px;
      margin: 0 5px;
      border-radius: 5px;
      box-shadow: 0 0 10px rgba(255, 51, 102, 0.7);
      font-family: var(--display-font);
    }

    #game-mode-selection button#multiplayer-mode {
      background: linear-gradient(to bottom, #00b09b, #96c93d);
    }
    
    /* Key hint styling */
    .key-hint {
      font-size: 18px;
      opacity: 0.8;
      margin-left: 5px;
      font-weight: normal;
    }
    
    .key-instruction {
      margin-top: 20px;
      font-size: 20px;
      color: #FFC107;
      opacity: 0.9;
    }
    
    .key-label {
      display: inline-block;
      background: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.4);
      border-radius: 5px;
      padding: 2px 8px;
      font-family: var(--display-font);
      margin: 0 3px;
    }

    input[type="range"] {
      width: 300px;
      height: 12px;
    }

    /* System message styling */
    .system-message-container {
      position: fixed;
      top: 20%;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 9999;
      pointer-events: none;
    }
    
    .system-message {
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      margin-bottom: 10px;
      font-family: var(--text-font);
      font-size: 24px;
      text-align: center;
      max-width: 80vw;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      opacity: 0;
      transform: translateY(-20px);
      transition: opacity 0.3s, transform 0.3s;
    }
    
    .system-message.appear {
      opacity: 1;
      transform: translateY(0);
    }
    
    .system-message.disappear {
      opacity: 0;
      transform: translateY(-20px);
    }

    #game-mode-selection button#solo-mode {
      background: linear-gradient(to bottom, #4a00e0, #8e2de2);
      font-size: 32px;
      padding: 25px 40px;
      min-width: 320px;
      margin: 10px auto;
    }

    /* Key hint styling */
    .key-hint {
      font-size: 32px;
      opacity: 1;
      margin-left: 10px;
      font-weight: bold;
      color: #FFC107;
      text-shadow: 0 0 8px rgba(255, 193, 7, 0.7);
    }
    
    /* Retro prompt styling */
    .retro-prompt {
      font-family: var(--title-font);
      font-size: 22px;
      font-weight: bold;
      color: #FF3366;
      letter-spacing: 2px;
      text-shadow: 0 0 10px rgba(255, 51, 102, 0.7);
      animation: pulse 1.2s infinite alternate;
      margin-top: 5px;
    }
    
    @keyframes pulse {
      from {
        opacity: 0.7;
        transform: scale(0.97);
      }
      to {
        opacity: 1;
        transform: scale(1.03);
      }
    }
    
    .retro-prompt .key-label {
      display: inline-block;
      background: #FF3366;
      color: white;
      padding: 2px 12px;
      margin: 0 5px;
      border-radius: 5px;
      box-shadow: 0 0 10px rgba(255, 51, 102, 0.7);
      font-family: var(--display-font);
    }

    #game-mode-selection button:hover {
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
    }

    #game-mode-selection button.button-flash {
      animation: button-flash 0.2s forwards;
    }

    @keyframes button-flash {
      0% {
        transform: scale(1);
        box-shadow: 0 0 0 rgba(255, 255, 255, 0);
      }
      50% {
        transform: scale(1.1);
        box-shadow: 0 0 30px rgba(255, 255, 255, 1);
        background: linear-gradient(to bottom, #8e2de2, #4a00e0);
      }
      100% {
        transform: scale(1);
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
      }
    }

    #game-mode-selection button#solo-mode {
      background: linear-gradient(to bottom, #4a00e0, #8e2de2);
      font-size: 32px;
      padding: 25px 40px;
      min-width: 320px;
      margin: 10px auto;
    }

    @keyframes scoreValueChanged {
      0% { transform: scale(1); }
      50% { transform: scale(1.15); color: #ffcc00; text-shadow: 0 0 12px rgba(255, 204, 0, 0.8); }
      100% { transform: scale(1); }
    }
  </style>
<!-- Scene UI Templates -->
<template id="hit-notification-template">
  <div class="hit-notification">
    <span class="score">+0</span>
  </div>
</template>

<template id="block-destroyed-notification-template">
  <div class="block-destroyed-notification">
    <div class="score">+0</div>
  </div>
</template>

<template id="combo-notification-template">
  <div class="combo-notification">
    <div class="combo-counter">
      <div class="combo-hits"></div>
      <div class="combo-text"></div>
      <div class="combo-bonus"></div>
    </div>
  </div>
</template>

<script>
  // Register Scene UI Templates
  hytopia.registerSceneUITemplate('hit-notification', (id, onState) => {
    const template = document.getElementById('hit-notification-template');
    const clone = template.content.cloneNode(true);
    const scoreElement = clone.querySelector('.score');
    
    onState(state => {
      if (scoreElement && state?.score != null) {
        scoreElement.textContent = `+${Math.round(Number(state.score))}`;
      }
    });
    
    return clone;
  });

  hytopia.registerSceneUITemplate('block-destroyed-notification', (id, onState) => {
    const template = document.getElementById('block-destroyed-notification-template');
    const clone = template.content.cloneNode(true);
    
    // Get both elements - we need to get these before returning the clone
    const scoreElement = clone.querySelector('.score');
    
    // Register the state handler
    onState(state => {
      if (scoreElement && state?.score != null) {
        const score = Math.round(Number(state.score));
        scoreElement.textContent = `+${score}`;
        
        // Apply score class
        if (state.class) {
          scoreElement.className = `score ${state.class}`;
        }
        
        // Apply custom style if provided
        if (state.style) {
          scoreElement.style.cssText = state.style;
        }
      }
    });
    
    return clone;
  });

  // Update the combo notification template registration
  hytopia.registerSceneUITemplate('combo-notification', (id, onState) => {
    const template = document.getElementById('combo-notification-template');
    if (!template) {
      console.error('Could not find combo-notification-template');
      return document.createElement('div');
    }
    
    const clone = template.content.cloneNode(true);
    
    // Get all the elements we need to update
    const container = clone.querySelector('.combo-notification');
    const hitsElement = clone.querySelector('.combo-hits');
    const textElement = clone.querySelector('.combo-text');
    const bonusElement = clone.querySelector('.combo-bonus');
    
    onState(state => {
      if (state && container) {
        // Update the combo class based on hits
        const comboClass = state.hits >= 10 ? 'mega-combo' :
                          state.hits >= 7 ? 'ultra-combo' :
                          state.hits >= 5 ? 'super-combo' :
                          'combo';
        container.className = `combo-notification ${comboClass} active`;
        
        // Update the text content
        if (hitsElement) hitsElement.textContent = `${state.hits}x`;
        if (textElement) textElement.textContent = state.text;
        if (bonusElement) bonusElement.textContent = `+${state.bonus}%`;

        // Clear any existing timeout
        if (comboTimeout) {
          clearTimeout(comboTimeout);
        }

        // Set new timeout to remove active class
        comboTimeout = setTimeout(() => {
          container.classList.remove('active');
        }, 2000);
      }
    });
    
    return clone;
  });
</script>

<div class="scoreboard hidden">
  <div class="scores-wrapper">
    <div class="scores-title">Round Score</div>
    <div id="scores-container">
      <!-- Scores will be added here dynamically -->
    </div>
  </div>
</div>

<!-- Game status elements -->
<div class="game-status">
  <div class="round-number"></div>
  <div class="round-timer"></div>
</div>

<div class="leaderboard">
  <div class="leaderboard-title">Leaderboard</div>
  <div id="leaderboard-container">
    <!-- Leaderboard entries will be added here dynamically -->
  </div>
</div>


<div class="crosshair"></div>

<!-- Add the combo notification element here -->
<div class="combo-notification">
  <div class="combo-counter">
    <div class="combo-hits"></div>
    <div class="combo-text"></div>
    <div class="combo-bonus"></div>
  </div>
</div>

<div class="settings-overlay"></div>
<div class="settings-menu">
  <div class="settings-title">Settings</div>
  
  <!-- Game Settings Section -->
  <div class="settings-section">
    <div class="settings-section-title">Game Settings</div>
    <div class="settings-option">
      <span class="settings-label">Background Music Volume</span>
      <div class="settings-value">
        <input type="range" min="0" max="100" value="10" id="bgm-volume-slider">
        <span id="bgm-volume-value">10</span>
      </div>
    </div>
  </div>

  <!-- Crosshair Settings Section -->
  <div class="settings-section">
    <div class="settings-section-title">Crosshair Settings</div>
    <div class="settings-option">
      <span class="settings-label">Crosshair Color</span>
      <div class="settings-value color-controls">
        <select id="color-preset" class="color-dropdown">
          <option value="">Custom</option>
          <option value="#ffff00">Yellow</option>
          <option value="#00ff7f">Green</option>
          <option value="#ff4d4d">Red</option>
          <option value="#66ffff">Cyan</option>
          <option value="#ff66ff">Magenta</option>
          <option value="#ffffff">White</option>
          <option value="#ffb366">Orange</option>
          <option value="#66ffb3">Mint</option>
          <option value="#b366ff">Purple</option>
          <option value="#ff66b3">Pink</option>
        </select>
        <input type="color" value="#ffff00" id="crosshair-color">
      </div>
    </div>

    <div class="settings-option">
      <span class="settings-label">Crosshair Elements</span>
      <div class="settings-value">
        <label class="checkbox-label">
          <input type="checkbox" id="show-ring" checked>
          Ring
        </label>
        <label class="checkbox-label">
          <input type="checkbox" id="show-dot" checked>
          Dot
        </label>
      </div>
    </div>

    <div class="settings-option">
      <span class="settings-label">Global Size</span>
      <div class="settings-value">
        <input type="range" min="12" max="48" value="24" id="global-size-slider">
        <span id="global-size-value">24px</span>
      </div>
    </div>

    <div class="settings-option">
      <span class="settings-label">Ring Size</span>
      <div class="settings-value">
        <input type="range" min="8" max="40" value="20" id="ring-size-slider">
        <span id="ring-size-value">20px</span>
      </div>
    </div>

    <div class="settings-option">
      <span class="settings-label">Dot Size</span>
      <div class="settings-value">
        <input type="range" min="2" max="12" value="4" id="dot-size-slider">
        <span id="dot-size-value">4px</span>
      </div>
    </div>
  </div>

  <!-- Resume Button -->
  <div class="settings-option">
    <button class="settings-button" id="resume-button">Resume Game</button>
    <button class="settings-button" id="reset-settings-button">Reset to Default</button>
  </div>
</div>

<!-- Help Menu -->
<div class="help-menu">
    <div class="help-header">
        <span class="help-title">GAME GUIDE</span>
        <span class="help-key">[Ctrl+H]</span>
    </div>
    <div class="help-content">
        <div class="help-section scoring">
            <h3>🎯 SCORING SYSTEM</h3>
            <div class="guide-items">
                <div class="guide-item">
                    <span class="guide-icon">🎯</span>
                    <span class="guide-text">DISTANCE = MORE POINTS</span>
                </div>
                <div class="guide-item">
                    <span class="guide-icon">⚡</span>
                    <span class="guide-text">FASTER BLOCKS = BIGGER SCORE</span>
                </div>
                <div class="guide-item">
                    <span class="guide-icon">⏱️</span>
                    <span class="guide-text">QUICK SHOTS COUNT</span>
                </div>
                <div class="guide-item">
                    <span class="guide-icon">🔥</span>
                    <span class="guide-text">CHAIN HITS FOR COMBOS</span>
                </div>
            </div>
        </div>
        <div class="help-section controls">
            <h3>🎮 CONTROLS</h3>
            <div class="control-item">
                <span class="key">[ESC]</span>
                <span class="action">Show Cursor</span>
            </div>
            <div class="control-item">
                <span class="key">[Ctrl+P]</span>
                <span class="action">Settings Menu</span>
            </div>
            <div class="control-item">
                <span class="key">[Ctrl+H]</span>
                <span class="action">Help Guide</span>
            </div>
            <div class="control-item">
                <span class="key">[Ctrl+L]</span>
                <span class="action">Leaderboard</span>
            </div>
            <div class="control-item">
                <span class="key">[T]</span>
                <span class="action">Open Chat</span>
            </div>
        </div>
    </div>
</div>

<div class="hotkey-hints">
    <div class="hotkey-hint">[Ctrl+H] Game Guide</div>
    <div class="hotkey-hint">[Ctrl+P] Settings</div>
    <div class="hotkey-hint">[Ctrl+ESC] Show Cursor</div>
    <div class="hotkey-hint">[Ctrl+L] Leaderboard</div>
    <div class="hotkey-hint">[T] Chat</div>
</div>

<script>
// Removed projectile count variable - projectiles are now unlimited
let particles = [];

const scoresContainer = document.getElementById('scores-container');

// Create particle effect
function createParticle() {
  const particles = document.querySelector('.particles');
  const particle = document.createElement('div');
  particle.className = 'particle';
  
  // Random position
  const x = Math.random() * 100;
  const y = Math.random() * 100;
  
  particle.style.left = x + '%';
  particle.style.top = y + '%';
  
  // Random animation
  const animation = particle.animate([
    { transform: 'translate(0, 0)', opacity: 1 },
    { transform: `translate(${Math.random() * 50 - 25}px, ${Math.random() * 50 - 25}px)`, opacity: 0 }
  ], {
    duration: 1000 + Math.random() * 1000,
    easing: 'cubic-bezier(0,0,0.2,1)'
  });
  
  particles.appendChild(particle);
  animation.onfinish = () => particle.remove();
}

// Create particles periodically
// Commented out to disable automatic particle creation
// setInterval(createParticle, 200);

// Listen for projectile count updates and shoot attempts from the game
hytopia.onData(data => {
  // Projectile count handlers removed - projectiles are now unlimited
  if (data.type === 'updateScores') {
    showScoreboard();
    updateScoreboard(data.scores);
  } else if (data.type === 'roundUpdate') {
    showScoreboard();
    updateRoundInfo(data.data);
  } else if (data.type === 'roundEnd') {
    handleRoundEnd(data.data);
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
  } else if (data.type === 'waitingForPlayers') {
    hideScoreboard();
    showWaitingForPlayers(data.data);
  } else if (data.type === 'updateLeaderboard') {
    updateLeaderboard(data.leaderboard);
  } else if (data.type === 'showCombo') {
    showComboNotification(data.data);
  } else if (data.type === 'resetCombo') {
    const container = document.querySelector('.combo-notification');
    container.classList.remove('active');
    if (window.comboTimeout) {
      clearTimeout(window.comboTimeout);
    }
  } else if (data.type === 'gameEnd') {
    hideScoreboard();
    showGameEnd(data.data);
  } else if (data.type === 'showHitNotification') {
    showLocalHitNotification(data.data);
  } else if (data.type === 'showBlockDestroyedNotification') {
    showLocalBlockDestroyedNotification(data.data);
  } else if (data.type === 'showModeSelection') {
    hideScoreboard();
    console.log('Received showModeSelection event from server, showing game mode selection UI');
    showGameModeSelection();
  } else if (data.type === 'hideGameModeSelection') {
    console.log('Received hideGameModeSelection event from server, hiding game mode selection UI');
    hideGameModeSelection();
  } else if (data.type === 'systemMessage') {
    // Display system message
    showSystemMessage(data.message, data.color || 'FFFFFF');
  } else if (data.type === 'resetUI') {
    resetUI();
  }
});

// Function removed - no longer needed with unlimited projectiles


function showWaitingForPlayers(data) {
  const gameStatus = document.querySelector('.game-status');
  const roundNumber = document.querySelector('.round-number');
  const roundTimer = document.querySelector('.round-timer');
  const leaderboard = document.querySelector('.leaderboard');
  
  // Update game status to show waiting message
  roundNumber.textContent = 'Waiting for Players';
  roundTimer.textContent = `${data.current}/${data.required}`;
  
  // Add waiting style
  gameStatus.classList.add('waiting');
  
  // Update leaderboard to pre-game state
  if (leaderboard) {
    leaderboard.classList.add('pre-game');
    
    // Update leaderboard title to show it's in pre-game state
    const title = leaderboard.querySelector('.leaderboard-title');
    if (title) {
      title.innerHTML = 'WAITING FOR PLAYERS<br><span style="font-size:14px;opacity:0.7;">Game starting soon...</span>';
    }
    
    // Clear any existing entries
    const container = document.getElementById('leaderboard-container');
    if (container) {
      // Create a placeholder entry
      container.innerHTML = `
        <div class="leaderboard-entry pre-game-message">
          <div style="width:100%;text-align:center;padding:10px;opacity:0.7;">
            Players will appear here when the game starts
          </div>
        </div>
      `;
    }
  }
}

let lastTimeRemaining = 0;
let timerInterval = null;
let timerEndTime = 0;

function startLocalTimer(initialTimeMs) {
  // Clear any existing timer
  if (timerInterval) {
    clearInterval(timerInterval);
  }
  
  // Set the end time based on current time plus duration
  timerEndTime = Date.now() + initialTimeMs;
  lastTimeRemaining = initialTimeMs;
  
  function updateTimer() {
    const now = Date.now();
    const remaining = Math.max(0, timerEndTime - now);
    
    // Update lastTimeRemaining for potential server sync
    lastTimeRemaining = remaining;
    
    // Calculate time components, using Math.floor instead of Math.ceil
    const timeRemaining = Math.floor(remaining / 1000);  // Changed from Math.ceil to Math.floor
    const minutes = Math.floor(timeRemaining / 60);
    const seconds = timeRemaining % 60;
    const formattedTime = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    
    const roundTimer = document.querySelector('.round-timer');
    if (roundTimer) {
      roundTimer.textContent = formattedTime;
      
      // Update visual feedback
      roundTimer.classList.remove('warning', 'danger');
      if (timeRemaining <= 10) {
        roundTimer.classList.add('danger');
      } else if (timeRemaining <= 30) {
        roundTimer.classList.add('warning');
      }
    }
    
    // Only clear interval if we've actually reached zero
    if (remaining <= 0) {
      clearInterval(timerInterval);
      timerInterval = null;
      
      // Ensure we show 0:00 at the end
      if (roundTimer) {
        roundTimer.textContent = '0:00';
      }
      
      // Send a message to the game that time is up
      if (typeof hytopia !== 'undefined') {
        hytopia.sendData({ type: 'timeUp' });
      }
    }
  }
  
  // Initial update
  updateTimer();
  
  // Start interval for updates
  timerInterval = setInterval(updateTimer, 100); // Update round timer frequently for smoother display
}

function updateRoundInfo(roundData) {
  const gameStatus = document.querySelector('.game-status');
  const roundNumber = document.querySelector('.round-number');
  const leaderboard = document.querySelector('.leaderboard');
  
  // Remove waiting style
  gameStatus.classList.remove('waiting');
  
  // Update round info
  roundNumber.textContent = `Round ${roundData.round}`;
  
  // Clear any active combo notification
  const comboNotification = document.querySelector('.combo-notification');
  if (comboNotification) {
    comboNotification.classList.remove('active');
    if (window.comboTimeout) {
      clearTimeout(window.comboTimeout);
    }
  }
  
  // Reset leaderboard from pre-game state if necessary
  if (leaderboard && leaderboard.classList.contains('pre-game')) {
    // We need to animate the leaderboard to show it's now active
    leaderboard.classList.add('hidden');
    leaderboard.classList.remove('pre-game');
    
    // Reset the title
    const title = leaderboard.querySelector('.leaderboard-title');
    if (title) {
      title.textContent = 'LEADERBOARD';
    }
    
    // Animate in the leaderboard with a slight delay
    setTimeout(() => {
      leaderboard.classList.remove('hidden');
    }, 500);
  }
  
  // Start or update timer with the full duration
  if (roundData.timeRemaining > 0) {
    startLocalTimer(roundData.timeRemaining);
  }
}

function handleRoundEnd(data) {
  // Hide the scoreboard when round ends with a delay
  setTimeout(() => {
    hideScoreboard();
  }, data.nextRoundIn - 500); // Hide 0.5s before next round
  
  // Only show results if it's not the final round
  if (data.round < data.totalRounds) {
    // Create and show round standings dialog
    if (data.placements && data.placements.length > 0) {
      // Create round end dialog
      const roundEndDialog = document.createElement('div');
      roundEndDialog.className = 'round-end';
      
      // Create title
      const title = document.createElement('div');
      title.className = 'round-end-title';
      title.textContent = `Round ${data.round} Results`;
      roundEndDialog.appendChild(title);
      
      // Add placements
      const placementsContainer = document.createElement('div');
      placementsContainer.className = 'round-end-placements';
      
      data.placements.forEach((placement, index) => {
        const placementDiv = document.createElement('div');
        const isCurrentPlayer = placement.playerId === data.currentPlayerId;
        placementDiv.className = `round-end-placement ${index === 0 ? 'first' : ''} ${isCurrentPlayer ? 'current-player' : ''}`;
        
        // Get player color
        const playerColor = placement.playerColor || '#FFFFFF';
        
        // Highlight current player's entry
        if (isCurrentPlayer) {
          placementDiv.style.borderColor = playerColor;
          placementDiv.style.boxShadow = `0 0 8px ${playerColor}`;
        }
        
        // Add content with player identifier
        placementDiv.innerHTML = `
          <div class="player-info">
            <span class="placement-rank" style="color: ${playerColor}">#${index + 1}</span>
            <span class="player-name" style="color: ${playerColor}">Player ${placement.playerNumber}</span>
            ${isCurrentPlayer ? '<span class="player-you-tag">YOU</span>' : ''}
          </div>
          <span class="placement-points" style="color: ${playerColor}">+${placement.points} pts</span>
        `;
        
        placementsContainer.appendChild(placementDiv);
      });
      
      roundEndDialog.appendChild(placementsContainer);
      
      // Add timer for next round
      const timerDiv = document.createElement('div');
      timerDiv.className = 'next-round-timer';
      timerDiv.textContent = `Next round starting in ${Math.ceil(data.nextRoundIn / 1000)} seconds...`;
      roundEndDialog.appendChild(timerDiv);
      
      // Add to body
      document.body.appendChild(roundEndDialog);
      
      // Remove dialog just before the next round starts
      setTimeout(() => {
        roundEndDialog.remove();
      }, data.nextRoundIn - 200); // Remove 200ms before next round starts
      
      // Update timer countdown
      let secondsLeft = Math.ceil(data.nextRoundIn / 1000);
      const timerInterval = setInterval(() => {
        secondsLeft--;
        if (secondsLeft > 0) {
          timerDiv.textContent = `Next round starting in ${secondsLeft} seconds...`;
        } else {
          clearInterval(timerInterval);
        }
      }, 1000);
    }

  }

  // Reset scores just before the next round starts
  setTimeout(() => {
    // Reset scores for next round
    const scores = document.querySelectorAll('.player-score');
    scores.forEach(score => {
      const totalScore = score.querySelector('.score-value');
      const lastScore = score.querySelector('.round-score');
      if (totalScore) {
        totalScore.textContent = '0';
      }
      if (lastScore) {
        lastScore.textContent = '';  // Hide completely instead of showing +0
      }
    });
  }, data.nextRoundIn - 100); // Reset 100ms before next round starts
}

function updateScoreboard(scores) {
  // Early return if scores array is empty or not defined - this handles the case when game isn't active
  if (!scores || !Array.isArray(scores) || scores.length === 0) {
    hideScoreboard();
    return;
  }

  // Show scoreboard since we have valid scores
  showScoreboard();
  
  const currentPlayerId = scores.currentPlayerId;
  
  // Sort scores to put current player first, then by player number
  const sortedScores = [...scores];
  sortedScores.sort((a, b) => {
    // Always put current player first
    if (a.playerId === currentPlayerId) return -1;
    if (b.playerId === currentPlayerId) return 1;
    // Then sort by player number
    return a.playerNumber - b.playerNumber;
  });
  
  // Get existing player divs
  const existingPlayerDivs = Array.from(scoresContainer.querySelectorAll('.player-score'));
  const existingPlayerIds = existingPlayerDivs.map(div => div.dataset.playerId);
  
  // Check if we need to rebuild the entire list
  const playerIdsChanged = sortedScores.some(score => !existingPlayerIds.includes(score.playerId)) || 
                           existingPlayerIds.some(id => !sortedScores.find(score => score.playerId === id));
  
  // If players changed, or first time loading, rebuild entire list
  if (playerIdsChanged || existingPlayerDivs.length === 0) {
    // Clear and rebuild entire list
    scoresContainer.innerHTML = '';
    
    sortedScores.forEach((score, index) => {
      const playerDiv = document.createElement('div');
      const isCurrentPlayer = score.playerId === currentPlayerId;
      playerDiv.className = `player-score ${isCurrentPlayer ? 'current-player' : ''}`;
      playerDiv.dataset.playerId = score.playerId;
      
      // Add animation delay based on index
      playerDiv.style.setProperty('--index', index);
      
      // Use leaderboardPoints for game end, otherwise use round scoring
      const points = score.isGameEnd ? score.leaderboardPoints : score.totalPoints;
      const lastScore = Number(score.lastScore || 0);
      
      // Player icon/avatar with player color
      const playerColor = score.playerColor || '#FFFFFF';
      
      // Highlight current player's score with a border
      if (isCurrentPlayer) {
        playerDiv.style.borderColor = playerColor;
        playerDiv.style.boxShadow = `0 0 8px ${playerColor}`;
      }
      
      // Build score display - total score and last earned score
      playerDiv.innerHTML = `
        <div class="player-indicator">
          <span class="player-label" style="color: ${playerColor}">Player ${score.playerNumber}</span>
          ${isCurrentPlayer ? '<span class="player-you-tag">YOU</span>' : ''}
        </div>
        <div class="score-info">
          <span class="score-value" data-player-id="${score.playerId}" style="color: ${playerColor}">${points}</span>
          <span class="round-score" data-player-id="${score.playerId}" style="color: ${playerColor}">
            ${!score.isGameEnd && lastScore > 0 ? `+${lastScore}` : ''}
          </span>
        </div>
      `;
      scoresContainer.appendChild(playerDiv);
    });
  } else {
    // Just update scores without rebuilding the entire list
    sortedScores.forEach(score => {
      // Find score elements for this player
      const scoreValueEl = scoresContainer.querySelector(`.score-value[data-player-id="${score.playerId}"]`);
      const lastScoreEl = scoresContainer.querySelector(`.round-score[data-player-id="${score.playerId}"]`);
      
      // Update score value
      if (scoreValueEl) {
        const points = score.isGameEnd ? score.leaderboardPoints : score.totalPoints;
        const currentValue = parseInt(scoreValueEl.textContent);
        
        // Only animate if the value has changed and is different
        if (currentValue !== points) {
          scoreValueEl.textContent = points;
          
          // Apply flash animation for changed score
          scoreValueEl.style.animation = 'none';
          void scoreValueEl.offsetWidth; // Trigger reflow
          scoreValueEl.style.animation = 'scoreValueChanged 0.8s ease-out';
        }
      }
      
      // Update last score with animation if needed
      if (lastScoreEl) {
        const lastScore = Number(score.lastScore || 0);
        if (!score.isGameEnd && lastScore > 0) {
          // Check if the last score has changed
          const currentText = lastScoreEl.textContent;
          const newText = `+${lastScore}`;
          
          if (currentText !== newText) {
            // Apply flash animation for changed score
            lastScoreEl.textContent = newText;
            lastScoreEl.style.animation = 'none';
            void lastScoreEl.offsetWidth; // Trigger reflow
            lastScoreEl.style.animation = 'pulseScore 1.5s ease-out';
          }
        } else {
          lastScoreEl.textContent = '';
        }
      }
    });
  }
}

// Track previous leaderboard state to detect changes
let previousLeaderboard = [];
let leaderboardInitialized = false;

function updateLeaderboard(data) {
  const container = document.getElementById('leaderboard-container');
  const leaderboardElement = document.querySelector('.leaderboard');
  const leaderboardData = data.leaderboard || data;
  const currentPlayerId = data.currentPlayerId;
  
  // Initialize leaderboard state on first load
  if (!leaderboardInitialized) {
    leaderboardElement.classList.add('hidden');
    setTimeout(() => {
      leaderboardElement.classList.remove('hidden');
      leaderboardInitialized = true;
    }, 500);
  }
  
  // Store old container contents to allow for comparing changes
  const oldEntries = Array.from(container.querySelectorAll('.leaderboard-entry'));
  container.innerHTML = '';
  
  leaderboardData.forEach((entry, index) => {
    const isCurrentPlayer = entry.playerId === currentPlayerId;
    const entryDiv = document.createElement('div');
    
    // Check if this entry changed rank or score
    const previousEntry = previousLeaderboard.find(prev => prev.playerId === entry.playerId);
    const isNew = !previousEntry;
    const rankChanged = previousEntry && previousEntry.currentRank !== entry.currentRank;
    const scoreChanged = previousEntry && previousEntry.points !== entry.points;
    
    // Apply appropriate animation classes
    let animationClass = '';
    if (isNew) {
      animationClass = 'new-entry';
    } else if (rankChanged) {
      animationClass = 'rank-changed';
    } else if (scoreChanged) {
      animationClass = 'score-updated';
    }
    
    entryDiv.className = `leaderboard-entry ${entry.isLeading ? 'winner' : ''} ${isCurrentPlayer ? 'current-player' : ''} ${animationClass}`;
    entryDiv.style.animationDelay = `${index * 0.05}s`;
    
    // Create rank change indicator based on the rankChange field
    let rankChangeIndicator = '';
    if (entry.rankChange === 'up') {
      rankChangeIndicator = `<span class="rank-change rank-up">▲</span>`;
    } else if (entry.rankChange === 'down') {
      rankChangeIndicator = `<span class="rank-change rank-down">▼</span>`;
    } else if (entry.rankChange === 'same') {
      rankChangeIndicator = `<span class="rank-change rank-same">●</span>`;
    } else if (entry.rankChange === 'new') {
      rankChangeIndicator = `<span class="rank-change rank-new">★</span>`;
    }
    
    // Add point difference for score animations if score changed
    let pointsDiff = '';
    if (scoreChanged && previousEntry) {
      const diff = entry.points - previousEntry.points;
      if (diff > 0) {
        pointsDiff = `data-diff="+${diff}"`;
      }
    }
    
    // Update the display
    entryDiv.innerHTML = `
      <div class="player-name">
        <span class="player-rank">#${entry.currentRank}</span>
        ${rankChangeIndicator}
        <div class="player-info">
          <span>Player ${entry.playerNumber}</span>
          ${isCurrentPlayer ? '<span class="player-you-tag">YOU</span>' : ''}
        </div>
      </div>
      <span class="player-wins ${scoreChanged ? 'score-change' : ''}" ${pointsDiff}>${entry.points}</span>
    `;
    
    container.appendChild(entryDiv);
  });
  
  // Update our stored state for next comparison
  previousLeaderboard = JSON.parse(JSON.stringify(leaderboardData));
}


// Settings menu functionality
let isSettingsOpen = false;

function toggleSettings(show) {
  const menu = document.querySelector('.settings-menu');
  const overlay = document.querySelector('.settings-overlay');
  isSettingsOpen = show;
  
  if (show) {
    menu.classList.add('visible');
    overlay.classList.add('visible');
    
    // Request current settings when opening menu
    hytopia.sendData({ 
      type: 'requestSettings'
    });
  } else {
    menu.classList.remove('visible');
    overlay.classList.remove('visible');
  }
}

// Listen for Escape key - work with cursor state
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && e.ctrlKey) {
    // If settings are open, close them
    if (isSettingsOpen) {
      toggleSettings(false);
      e.preventDefault(); // Prevent the default escape behavior
    } else {
      // If cursor becomes visible (handled by game), show settings
      setTimeout(() => {
        const cursorStyle = window.getComputedStyle(document.body).cursor;
        if (cursorStyle === 'default' || cursorStyle === 'auto') {
          toggleSettings(true);
        }
      }, 50); // Small delay to ensure cursor state has updated
    }
  } else if (e.key === 'Escape' && !e.ctrlKey) {
    // Regular ESC behavior without Ctrl
    if (isSettingsOpen) {
      toggleSettings(false);
      e.preventDefault(); // Prevent the default escape behavior
    }
  }
});

// Multiple hotkeys for settings
document.addEventListener('keydown', (e) => {
  if ((e.key === 'Tab' || e.key.toLowerCase() === 'p') && e.ctrlKey) { // Added Ctrl requirement
    e.preventDefault(); // Prevent default behavior
    const cursorStyle = window.getComputedStyle(document.body).cursor;
    if (cursorStyle === 'default' || cursorStyle === 'auto') {
      toggleSettings(!isSettingsOpen);
    }
  }
});

// Resume button - close settings and hide cursor
document.getElementById('resume-button').addEventListener('click', () => {
  toggleSettings(false);
  hytopia.sendData({ type: 'hideCursor' }); // Tell game to hide cursor again
});

// Handle settings changes
document.getElementById('sensitivity-slider')?.remove();

// Background music volume handler with debounce
let volumeTimeout;
const volumeSlider = document.getElementById('bgm-volume-slider');
const volumeValue = document.getElementById('bgm-volume-value');

// Initialize volume UI with default value
volumeSlider.value = '10'; // Default value (10%)
volumeValue.textContent = '10';

volumeSlider.addEventListener('input', (e) => {
  const value = e.target.value;
  volumeValue.textContent = value;
  
  // Clear any pending timeout
  if (volumeTimeout) {
    clearTimeout(volumeTimeout);
  }
  
  // Set a new timeout to update the volume
  volumeTimeout = setTimeout(() => {
    // Ensure we send exactly 0 when slider is at minimum
    const volumeValue = Number(value);
    hytopia.sendData({ 
      type: 'updateSettings',
      setting: 'bgmVolume',
      value: volumeValue === 0 ? 0 : volumeValue
    });
  }, 50); // Small delay to prevent too many updates
});

// Listen for settings updates from the game
hytopia.onData(data => {
  if (data.type === 'settingsUpdate' && data.settings) {
    // Update volume slider
    if (data.settings.bgmVolume !== undefined) {
      const uiValue = Math.round(data.settings.bgmVolume * 100);
      volumeSlider.value = String(uiValue);
      volumeValue.textContent = String(uiValue);
    }
  }
});

// Function to update crosshair color
function updateCrosshairColor(color) {
  const root = document.documentElement;
  const colorPicker = document.getElementById('crosshair-color');
  
  // Update color picker value
  colorPicker.value = color;
  
  // Convert hex to rgba for main color
  const r = parseInt(color.slice(1,3), 16);
  const g = parseInt(color.slice(3,5), 16);
  const b = parseInt(color.slice(5,7), 16);
  
  // Set the CSS variables
  root.style.setProperty('--crosshair-color', `rgba(${r}, ${g}, ${b}, 0.8)`);
  root.style.setProperty('--crosshair-glow', color);
  
  // Send to game
  hytopia.sendData({ 
    type: 'updateSettings',
    setting: 'crosshairColor',
    value: color
  });
}

// Color picker handler
document.getElementById('crosshair-color').addEventListener('input', (e) => {
  updateCrosshairColor(e.target.value);
  // Reset dropdown to "Custom" when using color picker
  document.getElementById('color-preset').value = '';
});

// Dropdown handler
document.getElementById('color-preset').addEventListener('change', (e) => {
  if (e.target.value) {
    updateCrosshairColor(e.target.value);
  }
});

// Function to update crosshair sizes
function updateCrosshairSizes() {
  const root = document.documentElement;
  const globalSize = document.getElementById('global-size-slider').value;
  const ringSize = document.getElementById('ring-size-slider').value;
  const dotSize = document.getElementById('dot-size-slider').value;
  
  root.style.setProperty('--crosshair-size', `${globalSize}px`);
  root.style.setProperty('--ring-size', `${ringSize}px`);
  root.style.setProperty('--dot-size', `${dotSize}px`);
  
  // Update display values
  document.getElementById('global-size-value').textContent = `${globalSize}px`;
  document.getElementById('ring-size-value').textContent = `${ringSize}px`;
  document.getElementById('dot-size-value').textContent = `${dotSize}px`;
  
  // Send to game
  hytopia.sendData({
    type: 'updateSettings',
    setting: 'crosshairSizes',
    value: { globalSize, ringSize, dotSize }
  });
}

// Function to update crosshair visibility
function updateCrosshairVisibility() {
  const root = document.documentElement;
  const showRing = document.getElementById('show-ring').checked;
  const showDot = document.getElementById('show-dot').checked;
  
  root.style.setProperty('--show-ring', showRing ? 'block' : 'none');
  root.style.setProperty('--show-dot', showDot ? 'block' : 'none');
  
  // Send to game
  hytopia.sendData({
    type: 'updateSettings',
    setting: 'crosshairVisibility',
    value: { showRing, showDot }
  });
}

// Size slider handlers
document.getElementById('global-size-slider').addEventListener('input', updateCrosshairSizes);
document.getElementById('ring-size-slider').addEventListener('input', updateCrosshairSizes);
document.getElementById('dot-size-slider').addEventListener('input', updateCrosshairSizes);

// Visibility checkbox handlers
document.getElementById('show-ring').addEventListener('change', updateCrosshairVisibility);
document.getElementById('show-dot').addEventListener('change', updateCrosshairVisibility);

// Add this to your existing script section
let isHelpOpen = false;

document.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'h' && e.ctrlKey) {
        e.preventDefault();
        toggleHelp(!isHelpOpen);
    }
});

function toggleHelp(show) {
    const menu = document.querySelector('.help-menu');
    
    if (show) {
        menu.classList.remove('closing');
        menu.classList.add('visible');
        isHelpOpen = true;
    } else {
        if (!menu.classList.contains('visible')) return;
        
        menu.classList.add('closing');
        isHelpOpen = false;
        
        // Wait for animation to complete before hiding
        setTimeout(() => {
            if (!isHelpOpen) { // Check again in case it was reopened
                menu.classList.remove('visible');
                menu.classList.remove('closing');
            }
        }, 300); // Match the animation duration
    }
}



// Add this to your existing script
function updateHotkeysVisibility(show) {
    const hints = document.querySelector('.hotkey-hints');
    if (hints) {
        hints.style.display = show ? 'flex' : 'none';
    }
}

// Hide hotkeys when menus are open
document.addEventListener('keydown', (e) => {
    if ((e.key === 'Escape' || e.key.toLowerCase() === 'p' || e.key.toLowerCase() === 'h') && e.ctrlKey) {
        updateHotkeysVisibility(false);
    }
});

// Show hotkeys when menus are closed
function onMenuClose() {
    updateHotkeysVisibility(true);
}

// Add this to your existing script
let comboTimeout = null;

function showComboNotification(data) {
  const container = document.querySelector('.combo-notification');
  const hitsElement = container.querySelector('.combo-hits');
  const textElement = container.querySelector('.combo-text');
  const bonusElement = container.querySelector('.combo-bonus');
  
  // Update the combo class based on hits
  const comboClass = data.hits >= 10 ? 'mega-combo' :
                    data.hits >= 7 ? 'ultra-combo' :
                    data.hits >= 5 ? 'super-combo' :
                    'combo';
  
  container.className = `combo-notification ${comboClass} active`;
  
  // Update the text content
  hitsElement.textContent = `${data.hits}x`;
  textElement.textContent = data.text;
  bonusElement.textContent = `+${data.bonus}%`;
  
  // Clear any existing timeout
  if (comboTimeout) {
    clearTimeout(comboTimeout);
  }
  
  // Hide after 2 seconds
  comboTimeout = setTimeout(() => {
    container.classList.remove('active');
  }, 2000);
}

// Add help toggle to settings menu
document.querySelector('.settings-menu').addEventListener('click', () => {
    toggleHelp(false); // Close help when opening settings
});

// Add this instead
document.addEventListener('DOMContentLoaded', () => {
    const settingsMenu = document.querySelector('.settings-menu');
    if (settingsMenu) {
        settingsMenu.addEventListener('click', () => {
            toggleHelp(false); // Close help when opening settings
        });
    }
});

function showGameEnd(data) {
    const overlay = document.querySelector('.game-end-overlay');
    const winnerAnnouncement = document.querySelector('.winner-announcement');
    const standingsContainer = document.querySelector('.final-standings');
    const nextGameTimer = document.querySelector('.next-game-timer');
    
    // Get winner details
    const winnerPlayerNumber = data.winner.playerNumber || 1;
    const winnerColor = data.winner.playerColor || '#FFD700';
    const isCurrentPlayerWinner = data.winner.playerId === data.currentPlayerId;
    
    // Pre-calculate ranks to handle ties
    let currentRank = 1;
    let previousPoints = -1;
    const rankedStandings = data.standings.map((standing, index) => {
        // Check if this player has the same points as the previous one
        if (index > 0 && standing.placementPoints === previousPoints) {
            // Keep the same rank for tied players
        } else {
            // New points value = new rank
            currentRank = index + 1;
        }
        
        // Store current points for next iteration
        previousPoints = standing.placementPoints;
        
        // Return standing with rank
        return {
            ...standing,
            rank: currentRank
        };
    });
    
    // Check for ties in first place
    const firstPlaceStandings = rankedStandings.filter(standing => standing.rank === 1);
    const isTiedForFirst = firstPlaceStandings.length > 1;
    
    // Style winner announcement with winner's color
    if (isTiedForFirst) {
        // Show tie message when there's a tie for first place
        const tiedPlayerNumbers = firstPlaceStandings.map(s => s.playerNumber).join(', ').replace(/,([^,]*)$/, ' and$1');
        const isCurrentPlayerInTie = firstPlaceStandings.some(s => s.playerId === data.currentPlayerId);
        
        if (isCurrentPlayerInTie) {
            winnerAnnouncement.innerHTML = `
                <span style="color: ${winnerColor}">It's a tie! You share the victory!</span>
            `;
        } else {
            winnerAnnouncement.innerHTML = `
                <span style="color: ${winnerColor}">It's a tie between Players ${tiedPlayerNumbers}!</span>
            `;
        }
    } else if (isCurrentPlayerWinner) {
        // Show "Victory! You won the game!" when current player is winner
        winnerAnnouncement.innerHTML = `
            <span style="color: ${winnerColor}">Victory! You won the game!</span>
        `;
    } else {
        // Show regular message for other players
        winnerAnnouncement.innerHTML = `
            <span style="color: ${winnerColor}">Player ${winnerPlayerNumber}</span> Wins!
        `;
    }
    winnerAnnouncement.style.textShadow = `0 0 15px ${winnerColor}`;
    
    // Show standings
    standingsContainer.innerHTML = '';
    
    rankedStandings.forEach((standing, index) => {
        const isCurrentPlayer = standing.playerId === data.currentPlayerId;
        const entry = document.createElement('div');
        entry.className = `standing-entry ${index === 0 ? 'winner' : ''} ${isCurrentPlayer ? 'current-player' : ''}`;
        
        // Use player color for styling
        const playerColor = standing.playerColor || '#FFFFFF';
        
        // Highlight current player's entry
        if (isCurrentPlayer) {
            entry.style.borderColor = playerColor;
            entry.style.boxShadow = `0 0 8px ${playerColor}`;
        }
        
        // Create medal element based on actual rank (not index)
        let medalHtml = '';
        if (standing.rank === 1) {
            medalHtml = `<span class="medal gold" title="1st Place">🥇</span>`;
        } else if (standing.rank === 2) {
            medalHtml = `<span class="medal silver" title="2nd Place">🥈</span>`;
        } else if (standing.rank === 3) {
            medalHtml = `<span class="medal bronze" title="3rd Place">🥉</span>`;
        }
        
        entry.innerHTML = `
            <div class="player-info standing-player-info">
                <span class="standing-position" style="color: ${playerColor}">#${standing.rank}</span>
                ${medalHtml}
                <span class="player-name" style="color: ${playerColor}">Player ${standing.playerNumber}</span>
                ${isCurrentPlayer ? '<span class="player-you-tag">YOU</span>' : ''}
            </div>
            <div class="standing-stats">
                <div class="standing-stat">
                    <div class="stat-label">TOTAL SCORE</div>
                    <div class="stat-value" style="color: ${playerColor}">${standing.cumulativeScore || 0}</div>
                </div>
                <div class="standing-stat">
                    <div class="stat-label">POINTS</div>
                    <div class="stat-value" style="color: ${playerColor}">${standing.placementPoints}</div>
                </div>
                <div class="standing-stat">
                    <div class="stat-label">WINS</div>
                    <div class="stat-value" style="color: ${playerColor}">${standing.wins || 0}</div>
                </div>
            </div>
        `;
        
        standingsContainer.appendChild(entry);
    });
    
    // Show next game timer
    let timeLeft = Math.floor(data.nextGameIn / 1000);
    nextGameTimer.textContent = `Next Game in ${timeLeft}s`;
    
    const countdownInterval = setInterval(() => {
        timeLeft--;
        nextGameTimer.textContent = `Next Game in ${timeLeft}s`;
        
        if (timeLeft <= 0) {
            clearInterval(countdownInterval);
            overlay.classList.remove('visible');
        }
    }, 1000);
    
    // Show overlay
    overlay.classList.add('visible');
    
    // Hide overlay after nextGameIn duration
    setTimeout(() => {
        overlay.classList.remove('visible');
    }, data.nextGameIn);
}

// Add these new functions to handle local notifications
function showLocalHitNotification(data) {
  const container = document.createElement('div');
  container.className = 'hit-notification';
  container.style.left = '50%';  // Center horizontally
  container.style.top = '50%';   // Center vertically
  
  const scoreElement = document.createElement('span');
  scoreElement.className = 'score';
  scoreElement.textContent = `+${Math.round(data.score)}`;
  
  container.appendChild(scoreElement);
  document.body.appendChild(container);
  
  // Remove after animation
  setTimeout(() => {
    container.remove();
  }, 1000);
}

function showLocalBlockDestroyedNotification(data) {
  const container = document.createElement('div');
  container.className = 'block-destroyed-notification';
  container.style.left = '50%';  // Center horizontally
  container.style.top = '50%';   // Center vertically
  
  if (data.verticalOffset) {
    container.style.transform = `translate(-50%, -50%) translateY(-${data.verticalOffset}px)`;
  }
  
  const scoreElement = document.createElement('div');
  scoreElement.className = 'score';
  scoreElement.textContent = `+${data.score}`;
  
  if (data.style) {
    scoreElement.style.cssText = data.style;
  }
  
  container.appendChild(scoreElement);
  document.body.appendChild(container);
  
  // Remove after animation
  setTimeout(() => {
    container.remove();
  }, data.duration + 100);
}

// Game Mode Selection Functionality
function showGameModeSelection() {
  console.log('Showing game mode selection');
  const modal = document.getElementById('game-mode-selection');
  if (modal) {
    // Note: We can't directly control pointer lock from UI code
    // The server should call player.ui.lockPointer(false) when sending the showModeSelection event
    modal.style.display = 'block';
  } else {
    console.error('Game mode selection modal not found!');
  }
}

function hideGameModeSelection() {
  console.log('Hiding game mode selection');
  const modal = document.getElementById('game-mode-selection');
  if (modal) {
    modal.style.display = 'none';
    // Note: We can't directly control pointer lock from UI code
    // The game will automatically relock the pointer as needed
  } else {
    console.error('Game mode selection modal not found!');
  }
}

// Set up event listeners for game mode buttons - ONCE when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  console.log('Setting up game mode buttons...');
  const soloButton = document.getElementById('solo-mode');
  const dismissButton = document.getElementById('dismiss-mode-selection');
  
  if (dismissButton) {
    console.log('Dismiss button found, adding click handler');
    dismissButton.addEventListener('click', function() {
      console.log('Dismiss button clicked');
      // Just hide the selection UI
      hideGameModeSelection();
    });
  } else {
    console.log('Dismiss button not found!');
  }
  
  if (soloButton) {
    console.log('Solo button found, adding click handler');
    soloButton.addEventListener('click', function() {
      console.log('Solo mode clicked');
      
      // Add flash effect
      soloButton.classList.add('button-flash');
      setTimeout(() => {
        soloButton.classList.remove('button-flash');
      }, 200);
      
      // Hide selection UI first
      hideGameModeSelection();
      
      // Then send message to game that solo mode was selected
      hytopia.sendData({ 
        type: 'modeSelection',
        mode: 'solo'
      });
    });
  } else {
    console.log('Solo button not found!');
  }
  
  // For debugging - manually show the game mode selection (comment out for production)
  // setTimeout(() => {
  //   console.log('DEBUG: Manually showing game mode selection');
  //   showGameModeSelection();
  // }, 2000);
});

// Comment out the duplicate handler
/*
// Listen for showModeSelection event from the game
hytopia.onData(data => {
  if (data.type === 'showModeSelection') {
    showGameModeSelection();
  }
  // ... existing data handlers
});
*/

// Global keyboard shortcuts for mode selection
document.addEventListener('keydown', (e) => {
  // Process "Ctrl+1" key press to activate solo mode
  if (e.key === '1' && e.ctrlKey) {
    console.log('🎮 KEY PRESSED: "Ctrl+1" - Activating solo mode');
    e.preventDefault(); // Prevent any default behavior
    
    // Check if there's more than one player present
    const playerCount = document.querySelectorAll('.round-end-placement').length;
    if (playerCount > 1) {
      console.log('Multiple players present, ignoring solo mode key press');
      return false; // Ignore the key press completely if multiple players
    }
    
    // Add flash effect to the button if visible
    const soloButton = document.getElementById('solo-mode');
    if (soloButton) {
      soloButton.classList.add('button-flash');
      setTimeout(() => {
        soloButton.classList.remove('button-flash');
      }, 200);
    }
    
    // Hide the selection UI if it's visible
    const modeSelectionElement = document.getElementById('game-mode-selection');
    if (modeSelectionElement && modeSelectionElement.style.display === 'block') {
      hideGameModeSelection();
    }
    
    // Send the data to start solo mode - make this message stand out in logs
    console.log('🚀 SENDING SOLO MODE REQUEST TO SERVER');
    hytopia.sendData({ 
      type: 'modeSelection',
      mode: 'solo'
    });
    
    return false; // Prevent default and stop propagation
  }
  
  // Process "Ctrl+2" key press to dismiss the mode selection UI
  else if (e.key === '2' && e.ctrlKey) {
    console.log('🎮 KEY PRESSED: "Ctrl+2" - Dismissing mode selection');
    e.preventDefault(); // Prevent any default behavior
    
    // Add flash effect to the dismiss button if visible
    const dismissButton = document.getElementById('dismiss-mode-selection');
    if (dismissButton) {
      dismissButton.style.opacity = '1';
      setTimeout(() => {
        dismissButton.style.opacity = '0.7';
      }, 200);
    }
    
    // Hide the selection UI if it's visible
    const modeSelectionElement = document.getElementById('game-mode-selection');
    if (modeSelectionElement && modeSelectionElement.style.display === 'block') {
      hideGameModeSelection();
    }
    
    return false; // Prevent default and stop propagation
  }
});

// Display a system message for brief periods
function showSystemMessage(message, color = 'FFFFFF') {
  console.log('System message:', message);
  
  // Create or get the system message container
  let container = document.querySelector('.system-message-container');
  if (!container) {
    container = document.createElement('div');
    container.className = 'system-message-container';
    document.body.appendChild(container);
  }
  
  // Create the message element
  const messageElement = document.createElement('div');
  messageElement.className = 'system-message';
  messageElement.innerHTML = message;
  messageElement.style.color = `#${color}`;
  
  // Add to container
  container.appendChild(messageElement);
  container.style.display = 'flex';
  
  // Add appearing animation
  messageElement.classList.add('appear');
  
  // Remove after 5 seconds
  setTimeout(() => {
    messageElement.classList.add('disappear');
    setTimeout(() => {
      messageElement.remove();
      
      // Hide container if no more messages
      if (container.children.length === 0) {
        container.style.display = 'none';
      }
    }, 500);
  }, 5000);
}

// Function removed - no longer needed with unlimited projectiles

// Function to reset UI elements to their default state
function resetUI() {
  // Hide scoreboard with animation
  hideScoreboard();
  
  // Clear scores container
  const scoresContainer = document.getElementById('scores-container');
  if (scoresContainer) {
    scoresContainer.innerHTML = '';
  }
  
  // Reset game status if applicable
  const gameStatus = document.querySelector('.game-status');
  if (gameStatus) {
    gameStatus.classList.remove('waiting');
  }
  
  // Reset round timer display
  if (timerInterval) {
    clearInterval(timerInterval);
    timerInterval = null;
  }
}

// Animation functions for scoreboard
function showScoreboard() {
  const scoreboard = document.querySelector('.scoreboard');
  if (scoreboard) {
    // Make sure it's in the DOM with display block
    scoreboard.style.display = 'flex';
    
    // Apply the animation
    scoreboard.style.animation = 'scoreboardSlideIn 0.5s cubic-bezier(0.19, 1, 0.22, 1) forwards';
    
    // Remove the hidden class after animation starts
    setTimeout(() => {
      scoreboard.classList.remove('hidden');
    }, 50);
  }
}

function hideScoreboard() {
  const scoreboard = document.querySelector('.scoreboard');
  if (scoreboard) {
    // Apply the slide out animation
    scoreboard.style.animation = 'scoreboardSlideOut 0.5s cubic-bezier(0.19, 1, 0.22, 1) forwards';
    
    // Add hidden class
    scoreboard.classList.add('hidden');
    
    // After animation completes, set display to none
    setTimeout(() => {
      if (scoreboard.classList.contains('hidden')) {
        scoreboard.style.display = 'none';
      }
    }, 500);
  }
}

// Add reset settings button handler
document.getElementById('reset-settings-button').addEventListener('click', () => {
  if (confirm('Are you sure you want to reset all settings to default values?')) {
    hytopia.sendData({ 
      type: 'resetSettings'
    });
    
    // Also close the settings menu
    toggleSettings(false);
    hytopia.sendData({ type: 'hideCursor' }); // Tell game to hide cursor again
  }
});
</script>

<!-- Game Mode Selection Modal -->
<div id="game-mode-selection">
  <h2>WAITING FOR ANOTHER PLAYER</h2>
  <div class="mode-buttons">
    <button id="solo-mode" style="display: flex; flex-direction: column; align-items: center; background: rgba(0, 0, 0, 0.7); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 30px 50px; min-width: 350px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);">
      <div class="button-main-text" style="font-size: 42px; font-weight: bold; color: #ffffff; margin-bottom: 15px;">START SOLO</div>
      <div style="font-family: var(--text-font); font-size: 24px; color: #ffffff; opacity: 0.8;">PRESS CTRL+1 TO START</div>
      <div id="dismiss-mode-selection" style="font-family: var(--text-font); font-size: 18px; color: #ffffff; opacity: 0.7; cursor: pointer; margin-top: 15px;">PRESS CTRL+2 TO DISMISS</div>
    </button>
  </div>
</div>

<div class="game-end-overlay">
    <div class="game-end-content">
        <div class="game-end-title">GAME OVER</div>
        <div class="winner-announcement"></div>
        <div class="final-standings"></div>
        <div class="next-game-timer"></div>
    </div>
</div>

<!-- Remove the duplicate script tag with mode functions -->
<!--
<script>
// Direct onclick handlers for mode buttons
function modeSolo() {
  console.log('Solo mode selected via onclick');
  hideGameModeSelection();
  hytopia.sendData({ 
    type: 'modeSelection',
    mode: 'solo'
  });
}

function modeMultiplayer() {
  console.log('Multiplayer mode selected via onclick');
  hideGameModeSelection();
  hytopia.sendData({ 
    type: 'modeSelection',
    mode: 'multiplayer'
  });
}
</script>
-->

<div id="leaderboard-panel" class="game-panel" style="display: none;">
  <div class="panel-header">
    <h2>Leaderboard</h2>
    <button id="close-leaderboard" class="close-button">×</button>
  </div>
  
  <div class="tab-container">
    <button class="tab-button active" data-tab="all-time">All-Time High Scores</button>
    <button class="tab-button" data-tab="round">Best Round Scores</button>
    <button class="tab-button" data-tab="personal">Personal Bests</button>
  </div>
  
  <div id="all-time-tab" class="tab-content active">
    <table class="leaderboard-table">
      <thead>
        <tr>
          <th>Rank</th>
          <th>Player</th>
          <th>Score</th>
          <th>Date</th>
        </tr>
      </thead>
      <tbody id="all-time-scores">
        <!-- Dynamically populated -->
      </tbody>
    </table>
  </div>
  
  <div id="round-tab" class="tab-content">
    <div class="round-selector">
      <label for="round-select">Select Round:</label>
      <select id="round-select">
        <!-- Dynamically populated based on total rounds -->
      </select>
    </div>
    <table class="leaderboard-table">
      <thead>
        <tr>
          <th>Rank</th>
          <th>Player</th>
          <th>Round</th>
          <th>Score</th>
          <th>Date</th>
        </tr>
      </thead>
      <tbody id="round-scores">
        <!-- Dynamically populated based on selected round -->
      </tbody>
    </table>
  </div>
  
  <div id="personal-tab" class="tab-content">
    <div class="personal-total">
      <h3>Total High Score</h3>
      <div id="personal-total-score" class="stat-value">0</div>
    </div>
    
    <h3>Round High Scores</h3>
    <div class="round-selector personal-round-selector">
      <label for="personal-round-select">Select Round:</label>
      <select id="personal-round-select">
        <!-- Dynamically populated based on total rounds -->
      </select>
    </div>
    <div id="personal-round-scores" class="personal-rounds">
      <!-- Dynamically populated -->
    </div>
    
    <div class="personal-stats">
      <div class="stat-row">
        <span class="stat-label">Games Played:</span>
        <span class="stat-value" id="personal-games-played">0</span>
      </div>
      <!-- Total Wins and Last Updated sections removed -->
    </div>
    
    <!-- Leaderboard settings section removed -->
  </div>
</div>

<!-- Removed in-world leaderboard marker -->

<style>
  /* Leaderboard styling */
  .game-panel {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.85);
    border: 2px solid var(--matrix-green);
    border-radius: 8px;
    padding: 20px;
    color: white;
    width: 80%;
    max-width: 600px;
    max-height: 80%;
    overflow-y: auto;
    z-index: 1000;
    box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
  }
  
  .panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
  }
  
  .panel-header h2 {
    font-family: var(--title-font);
    color: var(--matrix-green);
    margin: 0;
    font-size: 24px;
    text-transform: uppercase;
    letter-spacing: 2px;
    text-shadow: 0 0 5px var(--matrix-green);
  }
  
  .close-button {
    background: transparent;
    border: none;
    color: white;
    font-size: 24px;
    cursor: pointer;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 20px;
    transition: all 0.2s ease;
  }
  
  .close-button:hover {
    background: rgba(255, 255, 255, 0.1);
    color: var(--matrix-green);
  }
  
  .tab-container {
    display: flex;
    margin-bottom: 15px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  }
  
  .tab-button {
    background: transparent;
    border: none;
    color: rgba(255, 255, 255, 0.6);
    padding: 10px 15px;
    cursor: pointer;
    font-family: var(--text-font);
    font-size: 16px;
    transition: all 0.2s ease;
    border-bottom: 2px solid transparent;
  }
  
  .tab-button.active {
    color: var(--matrix-green);
    border-bottom: 2px solid var(--matrix-green);
  }
  
  .tab-content {
    display: none;
  }
  
  .tab-content.active {
    display: block;
  }
  
  .leaderboard-table {
    width: 100%;
    border-collapse: collapse;
    font-family: var(--number-font);
  }
  
  .leaderboard-table th {
    text-align: left;
    padding: 10px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    color: var(--matrix-green);
  }
  
  .leaderboard-table td {
    padding: 10px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  }
  
  /* Set width for rank column */
  .leaderboard-table th:first-child,
  .leaderboard-table td:first-child {
    width: 60px;
    text-align: center;
  }
  
  /* Styling for tied entries */
  .leaderboard-table tr.tied-entry td {
    border-top: none;
  }
  
  .tie-indicator {
    font-size: 8px;
    vertical-align: super;
    color: rgba(255, 255, 255, 0.7);
    margin-left: 3px;
  }
  
  .leaderboard-table tr:hover td {
    background: rgba(255, 255, 255, 0.05);
  }
  
  /* Styles for top ranked rows */
  .leaderboard-table tr.top-rank td {
    font-weight: bold;
    transition: all 0.3s ease;
  }
  
  .leaderboard-table tr.rank-1 td {
    background: rgba(255, 215, 0, 0.1);
    border-bottom: 1px solid rgba(255, 215, 0, 0.3);
  }
  
  .leaderboard-table tr.rank-2 td {
    background: rgba(192, 192, 192, 0.1);
    border-bottom: 1px solid rgba(192, 192, 192, 0.3);
  }
  
  .leaderboard-table tr.rank-3 td {
    background: rgba(205, 127, 50, 0.1);
    border-bottom: 1px solid rgba(205, 127, 50, 0.3);
  }
  
  .leaderboard-table tr.top-rank:hover td {
    background-color: rgba(255, 255, 255, 0.2);
  }
  
  .personal-stats, .personal-settings {
    background: rgba(0, 0, 0, 0.3);
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 15px;
  }
  
  .stat-row, .setting-row {
    display: flex;
    justify-content: space-between;
    padding: 8px 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  }
  
  /* Round selector styling */
  .round-selector {
    margin: 15px 0;
    display: flex;
    align-items: center;
  }
  
  .round-selector label {
    margin-right: 10px;
    font-weight: bold;
    color: var(--matrix-green);
  }
  
  .round-selector select {
    background-color: rgba(0, 0, 0, 0.5);
    color: white;
    border: 1px solid #555;
    padding: 6px 12px;
    border-radius: 4px;
    font-size: 14px;
    outline: none;
  }
  
  .round-selector select:hover {
    background-color: rgba(0, 0, 0, 0.7);
  }
  
  /* Personal best round scores */
  .personal-total {
    margin-bottom: 20px;
    padding: 15px;
    background-color: rgba(0, 0, 0, 0.3);
    border-radius: 8px;
    text-align: center;
  }
  
  .personal-total h3 {
    margin-top: 0;
    margin-bottom: 10px;
    color: var(--matrix-green);
  }
  
  #personal-total-score {
    font-size: 32px;
    font-weight: bold;
    margin-bottom: 5px;
  }
  
  .stat-date {
    font-size: 12px;
    color: #aaa;
  }
  
  .personal-rounds {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 15px;
    margin: 15px 0 30px 0;
  }
  
  .personal-round-selector {
    margin-top: 5px;
    margin-bottom: 15px;
  }
  
  .no-scores-message {
    grid-column: 1 / -1;
    text-align: center;
    padding: 20px;
    color: rgba(255, 255, 255, 0.6);
    font-style: italic;
  }
  
  .round-score {
    background-color: rgba(0, 0, 0, 0.3);
    border-radius: 6px;
    padding: 12px;
    text-align: center;
  }
  
  .round-label {
    font-weight: bold;
    color: var(--matrix-green);
    margin-bottom: 8px;
  }
  
  .round-value {
    font-size: 22px;
    font-weight: bold;
    margin-bottom: 5px;
  }
  
  .round-date {
    font-size: 11px;
    color: #aaa;
  }
  
  .stat-row:last-child, .setting-row:last-child {
    border-bottom: none;
  }
  
  .stat-label, .setting-label {
    color: rgba(255, 255, 255, 0.8);
  }
  
  .stat-value {
    font-family: var(--number-font);
    color: var(--matrix-green);
    font-weight: bold;
  }
  
  .achievement-date {
    font-size: 0.9em;
    color: rgba(255, 255, 255, 0.6);
  }
  
  /* Toggle switch styling */
  .toggle-switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 24px;
  }
  
  .toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }
  
  .toggle-slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #333;
    transition: .4s;
    border-radius: 34px;
  }
  
  .toggle-slider:before {
    position: absolute;
    content: "";
    height: 16px;
    width: 16px;
    left: 4px;
    bottom: 4px;
    background-color: white;
    transition: .4s;
    border-radius: 50%;
  }
  
  input:checked + .toggle-slider {
    background-color: var(--matrix-green);
  }
  
  input:checked + .toggle-slider:before {
    transform: translateX(26px);
  }
  
  /* In-world leaderboard marker styling */
  .leaderboard-marker {
    background: rgba(0, 0, 0, 0.8);
    border-radius: 8px;
    padding: 12px;
    color: white;
    width: 200px;
    border: 1px solid var(--matrix-green);
    box-shadow: 0 0 10px rgba(0, 255, 65, 0.3);
  }
  
  .marker-title {
    font-family: var(--title-font);
    font-size: 14px;
    color: var(--matrix-green);
    text-align: center;
    margin-bottom: 8px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    padding-bottom: 4px;
  }
  
  .marker-scores {
    font-family: var(--number-font);
  }
  
  .marker-score {
    display: flex;
    justify-content: space-between;
    padding: 3px 0;
  }
  
  .marker-score .rank {
    width: 25px;
    opacity: 0.8;
  }
  
  .marker-score .name {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    margin: 0 5px;
  }
  
  .marker-score .score {
    font-weight: bold;
    color: var(--matrix-green);
  }
</style>

<script>
  // Handle data from the server
  hytopia.onData(data => {
    // Log all incoming messages
    console.log('📩 UI received data from server:', data);
    
    if (data.type === 'toggleLeaderboard') {
      const panel = document.getElementById('leaderboard-panel');
      panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
    }
    else if (data.type === 'displayLeaderboard') {
      displayLeaderboardData(data.data);
    }
    else if (data.type === 'personalStats') {
      displayPersonalStats(data.data);
    }
    else if (data.type === 'addTestButton') {
      // Add test button to the UI
      addTestButton(data.label, data.action);
    }
    else if (data.type === 'injectHTML') {
      // Inject HTML directly into the page
      const container = document.createElement('div');
      container.innerHTML = data.html;
      document.body.appendChild(container.firstElementChild);
    }
    else if (data.type === 'showNotification') {
      // Show a temporary notification
      showTemporaryNotification(data.message, data.duration || 5000);
    }
    else if (data.type === 'systemMessage') {
      // Show a system message as a notification as well
      showTemporaryNotification(data.message, 5000);
    }
  });

  // Function to show a temporary notification message
  function showTemporaryNotification(message, duration) {
    // Create notification element
    const notification = document.createElement('div');
    notification.textContent = message;
    notification.style.cssText = `
      position: fixed;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 12px 20px;
      border-radius: 5px;
      font-size: 16px;
      font-weight: bold;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
      z-index: 9999;
      text-align: center;
    `;
    
    // Add to body
    document.body.appendChild(notification);
    
    // Remove after duration
    setTimeout(() => {
      if (notification.parentNode) {
        notification.parentNode.removeChild(notification);
      }
    }, duration);
  }

  // Send data to the server when closing the leaderboard
  document.getElementById('close-leaderboard').addEventListener('click', () => {
    document.getElementById('leaderboard-panel').style.display = 'none';
    hytopia.sendData({ type: 'closeLeaderboard' });
  });

  // Tab switching functionality
  document.querySelectorAll('.tab-button').forEach(button => {
    button.addEventListener('click', () => {
      // Switch active tab
      document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
      button.classList.add('active');
      
      // Show corresponding content
      document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
      document.getElementById(`${button.dataset.tab}-tab`).classList.add('active');
    });
  });

  // Leaderboard visibility setting removed

  // Register scene UI template for in-world leaderboard markers
  // Removed leaderboard marker template registration

  function displayLeaderboardData(data) {
    const panel = document.getElementById('leaderboard-panel');
    panel.style.display = 'block';
    
    // Store leaderboard data globally for access by other functions
    window.leaderboardData = data;
    
    // Calculate ranks for all-time high scores to handle ties
    let currentRank = 1;
    let previousScore = -1;
    let position = 0;
    const rankedScores = data.allTimeHighScores.map((score, index) => {
      position = index + 1; // Track the actual position (1-based)
      
      // Check if this player has the same score as the previous one
      if (index > 0 && score.score === previousScore) {
        // Keep the same rank for tied players (do nothing)
      } else {
        // New score value = new rank (update the rank to match the current position)
        currentRank = position;
      }
      
      // Store current score for next iteration
      previousScore = score.score;
      
      // Return score with rank
      return {
        ...score,
        rank: currentRank
      };
    });
    
    // Display all-time high scores with medals for top 3
    document.getElementById('all-time-scores').innerHTML = rankedScores
      .map((score, index) => {
        // For top 3, show medals instead of rank numbers
        let rankDisplay = '';
        if (score.rank === 1) {
          rankDisplay = `<span class="medal gold" title="1st Place">🥇</span>`;
        } else if (score.rank === 2) {
          rankDisplay = `<span class="medal silver" title="2nd Place">🥈</span>`;
        } else if (score.rank === 3) {
          rankDisplay = `<span class="medal bronze" title="3rd Place">🥉</span>`;
        } else {
          // For positions 4+, just show the rank number
          rankDisplay = `${score.rank}`;
        }
        
        // Get previous score for comparison (to indicate ties visually)
        const previousEntry = index > 0 ? rankedScores[index - 1] : null;
        const isTied = previousEntry && score.score === previousEntry.score;
        
        return `
        <tr class="${score.rank <= 3 ? 'top-rank rank-' + score.rank : ''} ${isTied ? 'tied-entry' : ''}">
          <td>${rankDisplay}${isTied ? '<span class="tie-indicator" title="Tied">•</span>' : ''}</td>
          <td>${score.playerName}</td>
          <td>${score.score}</td>
          <td>${new Date(score.date).toLocaleDateString()}</td>
        </tr>
        `;
      })
      .join('');
      
    // Populate round selector based on total rounds
    // Use at least 5 rounds since we know the game has 5 rounds
    populateRoundSelector(Math.max(data.totalRounds || 5, 5));
    
    // Display round scores
    displayRoundScores(1, data.roundHighScores); // Default to round 1
  }
  
  // Function to populate the round selector
  function populateRoundSelector(totalRounds) {
    const selector = document.getElementById('round-select');
    
    // Save current selection if any
    const currentSelection = selector.value ? parseInt(selector.value) : 1;
    
    // Clear existing options
    selector.innerHTML = '';
    
    // Ensure totalRounds is at least 5 (the default max rounds)
    const maxRounds = Math.max(totalRounds || 5, 5);
    
    // Create an option for each round
    for (let i = 1; i <= maxRounds; i++) {
      const option = document.createElement('option');
      option.value = i.toString();
      option.textContent = `Round ${i}`;
      selector.appendChild(option);
    }
    
    // Restore selection if valid, otherwise select round 1
    if (currentSelection && currentSelection <= maxRounds) {
      selector.value = currentSelection.toString();
    } else {
      selector.value = "1";
    }
    
    // Add event listener to update displayed scores when selection changes
    selector.addEventListener('change', () => {
      const selectedRound = parseInt(selector.value);
      
      // Instead of getting scores from DOM, get them from the global data
      const leaderboardData = window.leaderboardData || { roundHighScores: [] };
      
      // Display filtered scores for the selected round
      displayRoundScores(selectedRound, leaderboardData.roundHighScores);
    });
  }
  
  // Display scores for a specific round
  function displayRoundScores(roundNumber, allRoundScores) {
    // Filter scores for the selected round
    const roundScores = allRoundScores.filter(score => score.roundNumber === roundNumber);
    
    // Sort by score (highest first)
    roundScores.sort((a, b) => b.roundScore - a.roundScore);
    
    if (roundScores.length === 0) {
      // Display a message when no scores are available for this round
      document.getElementById('round-scores').innerHTML = `
        <tr>
          <td colspan="5" style="text-align: center; padding: 20px;">
            No scores available for Round ${roundNumber}
          </td>
        </tr>
      `;
    } else {
      // Calculate ranks to handle ties
      let currentRank = 1;
      let previousScore = -1;
      let position = 0;
      const rankedScores = roundScores.map((score, index) => {
        position = index + 1; // Track the actual position (1-based)
        
        // Check if this player has the same score as the previous one
        if (index > 0 && score.roundScore === previousScore) {
          // Keep the same rank for tied players (do nothing)
        } else {
          // New score value = new rank (update the rank to match the current position)
          currentRank = position;
        }
        
        // Store current score for next iteration
        previousScore = score.roundScore;
        
        // Return score with rank
        return {
          ...score,
          rank: currentRank
        };
      });
      
      // Display the scores with medals for top 3
      document.getElementById('round-scores').innerHTML = rankedScores
        .map((score, index) => {
          // For top 3, show medals instead of rank numbers
          let rankDisplay = '';
          if (score.rank === 1) {
            rankDisplay = `<span class="medal gold" title="1st Place">🥇</span>`;
          } else if (score.rank === 2) {
            rankDisplay = `<span class="medal silver" title="2nd Place">🥈</span>`;
          } else if (score.rank === 3) {
            rankDisplay = `<span class="medal bronze" title="3rd Place">🥉</span>`;
          } else {
            // For positions 4+, just show the rank number
            rankDisplay = `${score.rank}`;
          }
          
          // Get previous score for comparison (to indicate ties visually)
          const previousEntry = index > 0 ? rankedScores[index - 1] : null;
          const isTied = previousEntry && score.roundScore === previousEntry.roundScore;
          
          return `
          <tr class="${score.rank <= 3 ? 'top-rank rank-' + score.rank : ''} ${isTied ? 'tied-entry' : ''}">
            <td>${rankDisplay}${isTied ? '<span class="tie-indicator" title="Tied">•</span>' : ''}</td>
            <td data-player-id="${score.playerId}">${score.playerName}</td>
            <td>${score.roundNumber}</td>
            <td>${score.roundScore}</td>
            <td data-date="${score.date}">${new Date(score.date).toLocaleDateString()}</td>
          </tr>
          `;
        })
        .join('');
    }
  }

  function displayPersonalStats(data) {
    // Update personal total score
    document.getElementById('personal-total-score').textContent = data.personalBest.totalScore || 0;
    
    // If roundScores object is empty, try to check global leaderboard for this player's scores
    // This is a temporary client-side fix until the server properly syncs the data
    const playerRoundScores = data.personalBest.roundScores || {};
    let roundScoresToUse = playerRoundScores;
    
    // If we have access to the global leaderboard data and personal round scores are empty
    if (window.leaderboardData && 
        window.leaderboardData.roundHighScores && 
        Object.keys(playerRoundScores).length === 0) {
      
      console.log("Personal round scores empty, trying to use global leaderboard data");
      
      // Get current player ID - infer from the data if possible
      const playerId = data.playerId || (data.personalId ? String(data.personalId) : null);
      
      if (playerId) {
        // Create a synthetic roundScores object from the global leaderboard
        const syntheticRoundScores = {};
        
        window.leaderboardData.roundHighScores
          .filter(entry => entry.playerId === playerId)
          .forEach(entry => {
            const roundNum = entry.roundNumber;
            // Only add if this round isn't already in the personal bests
            if (!playerRoundScores[roundNum]) {
              syntheticRoundScores[roundNum] = {
                score: entry.roundScore,
                date: entry.date
              };
            }
          });
        
        // If we found any scores for this player
        if (Object.keys(syntheticRoundScores).length > 0) {
          console.log("Using synthetic round scores from global leaderboard:", syntheticRoundScores);
          roundScoresToUse = syntheticRoundScores;
        }
      }
    }
    
    // Store data globally for personal round selector access
    window.personalRoundData = roundScoresToUse;
    
    // Populate the personal round selector
    populatePersonalRoundSelector(roundScoresToUse);
    
    // Display round scores based on selection or default to showing all
    const personalRoundSelect = document.getElementById('personal-round-select');
    const selectedRound = personalRoundSelect.value === 'all' 
      ? 'all' 
      : parseInt(personalRoundSelect.value);
    
    displayPersonalRoundScores(selectedRound, roundScoresToUse);
    
    // Update games played
    document.getElementById('personal-games-played').textContent = data.gamesPlayed || 0;
  }
  
  // Function to populate the personal round selector
  function populatePersonalRoundSelector(roundScores) {
    const selector = document.getElementById('personal-round-select');
    
    // Save current selection if any
    const currentSelection = selector.value || 'all';
    
    // Clear existing options
    selector.innerHTML = '';
    
    // Add "All Rounds" option
    const allOption = document.createElement('option');
    allOption.value = 'all';
    allOption.textContent = 'All Rounds';
    selector.appendChild(allOption);
    
    // Sort round numbers numerically
    const roundNumbers = Object.keys(roundScores)
      .map(Number)
      .sort((a, b) => a - b);
    
    // Create an option for each round that has a score
    roundNumbers.forEach(roundNum => {
      const option = document.createElement('option');
      option.value = roundNum.toString();
      option.textContent = `Round ${roundNum}`;
      selector.appendChild(option);
    });
    
    // Restore selection if valid, otherwise select "All Rounds"
    if (currentSelection === 'all') {
      selector.value = 'all';
    } else {
      const roundNum = parseInt(currentSelection);
      if (!isNaN(roundNum) && roundNumbers.includes(roundNum)) {
        selector.value = roundNum.toString();
      } else {
        selector.value = 'all';
      }
    }
    
    // Add event listener to update displayed scores when selection changes
    selector.addEventListener('change', () => {
      const selected = selector.value === 'all' ? 'all' : parseInt(selector.value);
      displayPersonalRoundScores(selected, window.personalRoundData);
    });
  }
  
  // Function to display personal round scores based on selection
  function displayPersonalRoundScores(selectedRound, roundScores) {
    const roundScoresContainer = document.getElementById('personal-round-scores');
    roundScoresContainer.innerHTML = '';
    
    if (!roundScores || Object.keys(roundScores).length === 0) {
      roundScoresContainer.innerHTML = `
        <div class="no-scores-message">
          No round scores available
        </div>
      `;
      return;
    }
    
    // Get round numbers to display
    let roundsToDisplay = [];
    if (selectedRound === 'all') {
      // Display all rounds
      roundsToDisplay = Object.keys(roundScores).map(Number).sort((a, b) => a - b);
    } else {
      // Display only the selected round if it exists
      if (roundScores[selectedRound]) {
        roundsToDisplay = [selectedRound];
      }
    }
    
    if (roundsToDisplay.length === 0) {
      roundScoresContainer.innerHTML = `
        <div class="no-scores-message">
          No scores available for Round ${selectedRound}
        </div>
      `;
      return;
    }
    
    // Display each round score
    roundsToDisplay.forEach(round => {
      const scoreData = roundScores[round];
      roundScoresContainer.innerHTML += `
        <div class="round-score">
          <div class="round-label">Round ${round}</div>
          <div class="round-value">${scoreData.score}</div>
          <div class="round-date">${new Date(scoreData.date).toLocaleDateString()}</div>
        </div>
      `;
    });
  }
</script>

<!-- Add keyboard shortcut for leaderboard -->
<script>
document.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 'l' && e.ctrlKey) {
    console.log('Leaderboard toggled via Ctrl+L key');
    e.preventDefault(); // Prevent default behavior
    
    const panel = document.getElementById('leaderboard-panel');
    const newVisibility = panel.style.display === 'none' ? 'block' : 'none';
    panel.style.display = newVisibility;
    
    // If showing the leaderboard, request data
    if (newVisibility === 'block') {
      hytopia.sendData({ type: 'showLeaderboard' });
    } else {
      // If hiding, notify server
      hytopia.sendData({ type: 'closeLeaderboard' });
    }
  }
  
  // B key to run leaderboard tests
  if (e.key.toLowerCase() === 'b' && e.ctrlKey) {
    console.log('Running leaderboard tests via Ctrl+B key');
    e.preventDefault(); // Prevent default behavior
    
    // Show a message that tests are running
    showTemporaryNotification('Running leaderboard tests...', 3000);
    
    // Send message to server to run tests
    hytopia.sendData({ type: 'runLeaderboardTests' });
  }
});
</script>

<!-- Add global event logging -->
<script>
  // Log all data received from the server
  hytopia.onData(data => {
    console.log('📩 UI received data from server:', data);
    // Process the data below...
  });
</script>

<!-- Process specific event types -->
<script>
  // Handle data from the server
  hytopia.onData(data => {
    if (data.type === 'toggleLeaderboard') {
      const panel = document.getElementById('leaderboard-panel');
      panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
    }
    // ... rest of the handler code ...
  });
</script>

<!-- Add event handlers for buttons -->
<script>
  // Button to run leaderboard tests
  document.getElementById('run-leaderboard-tests').addEventListener('click', () => {
    console.log('Running leaderboard tests via button click');
    
    // Show a message that tests are running
    showTemporaryNotification('Running leaderboard tests...', 3000);
    
    // Send message to server to run tests
    hytopia.sendData({ type: 'runLeaderboardTests' });
  });
</script>
</body>
</html>
  