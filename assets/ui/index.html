<style>
  .projectile-counter {
    position: absolute;
    bottom: 40px;
    right: 40px;
    background: rgba(0, 0, 0, 0.4);
    padding: 15px 25px;
    border-radius: 16px;
    color: #ffffff;
    font-family: 'Arial', sans-serif;
    display: flex;
    align-items: center;
    gap: 12px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    transition: all 0.3s ease;
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
  }

  .projectile-counter::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border-radius: 16px;
    background: linear-gradient(45deg, rgba(255,255,255,0.1), rgba(255,255,255,0));
    z-index: -1;
  }

  .projectile-counter.low {
    background: rgba(255, 0, 0, 0.2);
    border-color: rgba(255, 0, 0, 0.3);
  }

  .projectile-counter.shake {
    animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
    transform-origin: center center;
    backface-visibility: hidden;
    perspective: 1000px;
  }

  .projectile-icon {
    width: 28px;
    height: 28px;
    background: radial-gradient(circle at 30% 30%, #6ae675, #4CAF50);
    border-radius: 50%;
    position: relative;
    display: inline-block;
    box-shadow: 0 0 15px #4CAF50;
    transition: all 0.3s ease;
  }

  .projectile-icon::after {
    content: '';
    position: absolute;
    top: 15%;
    left: 15%;
    width: 30%;
    height: 30%;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 50%;
    filter: blur(1px);
  }

  .projectile-count {
    font-size: 28px;
    font-weight: bold;
    min-width: 35px;
    text-align: center;
    text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
  }

  .count-change {
    animation: pulse 0.5s ease-out;
  }

  @keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); }
  }

  @keyframes shake {
    0%, 100% { transform: translate3d(0, 0, 0) rotate(0deg); }
    10%, 90% { transform: translate3d(-2px, 1px, 0) rotate(-1deg); }
    20%, 80% { transform: translate3d(3px, -1px, 0) rotate(1deg); }
    30%, 50%, 70% { transform: translate3d(-4px, 2px, 0) rotate(-2deg); }
    40%, 60% { transform: translate3d(4px, -2px, 0) rotate(2deg); }
  }

  .particles {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    overflow: hidden;
    z-index: -1;
  }

  .particle {
    position: absolute;
    width: 4px;
    height: 4px;
    background: rgba(255, 255, 255, 0.5);
    border-radius: 50%;
    pointer-events: none;
  }

  .scoreboard {
    position: fixed;
    top: 100px;
    left: 40px;
    background: rgba(0, 0, 0, 0.4);
    padding: 15px 25px;
    border-radius: 16px;
    color: #ffffff;
    font-family: 'Arial', sans-serif;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 10px;
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
    min-width: 200px;
  }

  .leaderboard {
    width: 100%;
    margin-top: 10px;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
    padding-top: 10px;
  }

  .leaderboard-title {
    font-size: 16px;
    color: #FFD700;
    margin-bottom: 8px;
    text-align: center;
    width: 100%;
  }

  .leaderboard-entry {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 0;
    width: 100%;
  }

  .leaderboard-entry.winner {
    color: #FFD700;
    font-weight: bold;
  }

  .player-name {
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .player-rank {
    width: 20px;
    text-align: center;
    font-size: 14px;
    opacity: 0.8;
  }

  .player-wins {
    font-weight: bold;
    color: #4CAF50;
  }

  .round-info {
    text-align: left;
    padding: 5px 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    width: 100%;
  }

  .waiting-message {
    font-size: 24px;
    color: #FFD700;
    text-align: left;
    animation: pulse 1s infinite;
    margin: 10px 0;
  }

  .player-count {
    font-size: 18px;
    color: #ffffff;
    text-align: left;
  }

  .round-number {
    font-size: 20px;
    font-weight: bold;
    color: #FFD700;
  }

  .round-timer {
    font-size: 24px;
    color: #ffffff;
    font-weight: bold;
    padding: 5px 15px;
    border-radius: 8px;
    margin: 5px 0;
    transition: all 0.3s ease;
  }

  .round-timer.warning {
    color: #FFD700;
    animation: pulse-warning 1s infinite;
  }

  .round-timer.danger {
    color: #ff6b6b;
    animation: pulse-danger 0.5s infinite;
  }

  @keyframes pulse-warning {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
  }

  @keyframes pulse-danger {
    0% { transform: scale(1); text-shadow: 0 0 10px rgba(255, 0, 0, 0.5); }
    50% { transform: scale(1.1); text-shadow: 0 0 20px rgba(255, 0, 0, 0.8); }
    100% { transform: scale(1); text-shadow: 0 0 10px rgba(255, 0, 0, 0.5); }
  }

  .score-target {
    font-size: 14px;
    color: #4CAF50;
  }

  .scores-wrapper {
    display: flex;
    gap: 20px;
  }

  .player-score {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .player-label {
    color: #FFD700;
    font-weight: bold;
  }

  .score-value {
    font-size: 24px;
    min-width: 30px;
    text-align: center;
  }

  .countdown-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
  }

  .countdown-overlay.visible {
    opacity: 1;
  }

  .countdown-number {
    font-size: 120px;
    color: #FFD700;
    font-weight: bold;
    text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
    animation: countdown-pulse 0.5s ease-out;
  }

  .countdown-go {
    font-size: 150px;
    color: #4CAF50;
    font-weight: bold;
    text-shadow: 0 0 30px rgba(76, 175, 80, 0.5);
    animation: countdown-zoom 0.5s ease-out;
  }

  @keyframes countdown-pulse {
    0% { transform: scale(1.5); opacity: 0; }
    50% { transform: scale(0.9); opacity: 1; }
    100% { transform: scale(1); opacity: 1; }
  }

  @keyframes countdown-zoom {
    0% { transform: scale(0.5); opacity: 0; }
    50% { transform: scale(1.2); opacity: 1; }
    100% { transform: scale(1); opacity: 1; }
  }
</style>

<div class="countdown-overlay">
  <div class="countdown-display"></div>
</div>

<div class="scoreboard">
  <div class="round-info">
    <div class="waiting-message" style="display: none">Waiting for Players</div>
    <div class="player-count" style="display: none">Players: 0/2</div>
    <div class="round-number">Round 1</div>
    <div class="round-timer">Time: 60s</div>
  </div>
  <div class="scores-wrapper">
    <div id="scores-container">
      <!-- Scores will be added here dynamically -->
    </div>
  </div>
  <div class="leaderboard">
    <div class="leaderboard-title">Leaderboard</div>
    <div id="leaderboard-container">
      <!-- Leaderboard entries will be added here dynamically -->
    </div>
  </div>
</div>

<div class="projectile-counter">
  <div class="particles"></div>
  <div class="projectile-icon"></div>
  <div class="projectile-count">5</div>
</div>

<script>
let projectileCount = 5;
let particles = [];

const scoresContainer = document.getElementById('scores-container');

// Create particle effect
function createParticle() {
  const particles = document.querySelector('.particles');
  const particle = document.createElement('div');
  particle.className = 'particle';
  
  // Random position
  const x = Math.random() * 100;
  const y = Math.random() * 100;
  
  particle.style.left = x + '%';
  particle.style.top = y + '%';
  
  // Random animation
  const animation = particle.animate([
    { transform: 'translate(0, 0)', opacity: 1 },
    { transform: `translate(${Math.random() * 50 - 25}px, ${Math.random() * 50 - 25}px)`, opacity: 0 }
  ], {
    duration: 1000 + Math.random() * 1000,
    easing: 'cubic-bezier(0,0,0.2,1)'
  });
  
  particles.appendChild(particle);
  animation.onfinish = () => particle.remove();
}

// Create particles periodically
setInterval(createParticle, 200);

// Listen for projectile count updates and shoot attempts from the game
hytopia.onData(data => {
  console.log('Received data:', data); // Add logging
  if (data.type === 'updateProjectileCount') {
    updateProjectileCount(data.count);
  } else if (data.type === 'attemptShootNoAmmo') {
    triggerShakeAnimation();
  } else if (data.type === 'updateScores') {
    updateScoreboard(data.scores);
  } else if (data.type === 'roundUpdate') {
    console.log('Round update received:', data.data); // Add logging
    updateRoundInfo(data.data);
  } else if (data.type === 'roundEnd') {
    handleRoundEnd(data.data);
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
  } else if (data.type === 'waitingForPlayers') {
    showWaitingForPlayers(data.data);
  } else if (data.type === 'countdown') {
    showCountdown(data.count);
  } else if (data.type === 'updateLeaderboard') {
    updateLeaderboard(data.leaderboard);
  }
});

function triggerShakeAnimation() {
  const counterElement = document.querySelector('.projectile-counter');
  counterElement.classList.remove('shake');
  void counterElement.offsetWidth; // Trigger reflow
  counterElement.classList.add('shake');
  
  // Remove the class after animation completes
  setTimeout(() => {
    counterElement.classList.remove('shake');
  }, 820); // Match the animation duration
}

function updateProjectileCount(count) {
  const countElement = document.querySelector('.projectile-count');
  const counterElement = document.querySelector('.projectile-counter');
  const iconElement = document.querySelector('.projectile-icon');
  
  // Add pulse animation
  countElement.classList.remove('count-change');
  void countElement.offsetWidth; // Trigger reflow
  countElement.classList.add('count-change');
  
  // Update count with transition
  countElement.textContent = count;
  
  // Visual feedback for low ammo
  if (count <= 2) {
    counterElement.classList.add('low');
    iconElement.style.background = 'radial-gradient(circle at 30% 30%, #ff6b6b, #ff0000)';
    iconElement.style.boxShadow = '0 0 15px #ff0000';
  } else {
    counterElement.classList.remove('low');
    iconElement.style.background = 'radial-gradient(circle at 30% 30%, #6ae675, #4CAF50)';
    iconElement.style.boxShadow = '0 0 15px #4CAF50';
  }
  
  projectileCount = count;
}

function showWaitingForPlayers(data) {
  const waitingMessage = document.querySelector('.waiting-message');
  const playerCount = document.querySelector('.player-count');
  const gameElements = document.querySelectorAll('.round-number, .round-timer');
  
  // Show waiting elements
  waitingMessage.style.display = 'block';
  playerCount.style.display = 'block';
  playerCount.textContent = `Players: ${data.current}/${data.required}`;
  
  // Hide game elements
  gameElements.forEach(el => el.style.display = 'none');
}

let lastTimeRemaining = 0;
let timerInterval = null;
let timerEndTime = 0;

function startLocalTimer(initialTimeMs) {
  // Clear any existing timer
  if (timerInterval) {
    clearInterval(timerInterval);
  }
  
  // Set the end time based on current time plus duration
  timerEndTime = Date.now() + initialTimeMs;
  lastTimeRemaining = initialTimeMs;
  
  function updateTimer() {
    const now = Date.now();
    const remaining = Math.max(0, timerEndTime - now);
    
    // Update lastTimeRemaining for potential server sync
    lastTimeRemaining = remaining;
    
    const timeRemaining = Math.ceil(remaining / 1000);
    const minutes = Math.floor(timeRemaining / 60);
    const seconds = timeRemaining % 60;
    const formattedTime = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
    
    const roundTimer = document.querySelector('.round-timer');
    if (roundTimer) {
      roundTimer.textContent = formattedTime;
      
      // Update visual feedback
      roundTimer.classList.remove('warning', 'danger');
      if (timeRemaining <= 10) {
        roundTimer.classList.add('danger');
      } else if (timeRemaining <= 30) {
        roundTimer.classList.add('warning');
      }
    }
    
    // Only clear interval if we've actually reached zero
    if (remaining <= 0) {
      clearInterval(timerInterval);
      timerInterval = null;
      
      // Send a message to the game that time is up
      if (typeof hytopia !== 'undefined') {
        hytopia.sendData({ type: 'timeUp' });
      }
    }
  }
  
  // Initial update
  updateTimer();
  
  // Start interval for updates
  timerInterval = setInterval(updateTimer, 100); // Update more frequently for smoother countdown
}

function updateRoundInfo(roundData) {
  const waitingMessage = document.querySelector('.waiting-message');
  const playerCount = document.querySelector('.player-count');
  const gameElements = document.querySelectorAll('.round-number, .round-timer');
  
  // Hide waiting elements
  waitingMessage.style.display = 'none';
  playerCount.style.display = 'none';
  
  // Show game elements
  gameElements.forEach(el => el.style.display = 'block');
  
  // Update round info
  const roundNumber = document.querySelector('.round-number');
  roundNumber.textContent = `Round ${roundData.round}`;
  
  // Start or update timer with the full duration
  if (roundData.timeRemaining > 0) {
    console.log('Starting timer with duration:', roundData.timeRemaining);
    startLocalTimer(roundData.timeRemaining);
  }
}

function handleRoundEnd(data) {
  const roundInfo = document.querySelector('.round-info');
  
  // Add temporary status message
  const statusMessage = document.createElement('div');
  statusMessage.style.color = '#4CAF50';
  statusMessage.textContent = 'Round Complete!';
  statusMessage.style.fontSize = '24px';
  statusMessage.style.fontWeight = 'bold';
  statusMessage.style.animation = 'pulse 0.5s ease-out infinite';
  
  roundInfo.appendChild(statusMessage);
  
  // Remove after transition to next round
  setTimeout(() => {
    statusMessage.remove();
  }, data.nextRoundIn);
}

function updateScoreboard(scores) {
  scoresContainer.innerHTML = '';
  scores.forEach((score, index) => {
    const playerDiv = document.createElement('div');
    playerDiv.className = 'player-score';
    playerDiv.innerHTML = `
      <span class="player-label">P${index + 1}</span>
      <span class="score-value">${score.totalScore}</span>
      <span class="round-score">(+${score.roundScore})</span>
    `;
    scoresContainer.appendChild(playerDiv);
  });
}

function showCountdown(count) {
  const overlay = document.querySelector('.countdown-overlay');
  const display = document.querySelector('.countdown-display');
  
  // Show overlay
  overlay.classList.add('visible');
  
  // Update display
  if (count === 'GO!') {
    display.className = 'countdown-display countdown-go';
  } else {
    display.className = 'countdown-display countdown-number';
  }
  display.textContent = count;
  
  // Remove overlay after GO!
  if (count === 'GO!') {
    setTimeout(() => {
      overlay.classList.remove('visible');
    }, 1000);
  }
}

function updateLeaderboard(leaderboardData) {
  const container = document.getElementById('leaderboard-container');
  container.innerHTML = '';
  
  leaderboardData.forEach((entry, index) => {
    const entryDiv = document.createElement('div');
    entryDiv.className = `leaderboard-entry ${entry.isWinning ? 'winner' : ''}`;
    
    entryDiv.innerHTML = `
      <div class="player-name">
        <span class="player-rank">#${index + 1}</span>
        <span>P${entry.playerNumber}</span>
      </div>
      <span class="player-wins">${entry.wins} wins</span>
    `;
    
    container.appendChild(entryDiv);
  });
}
</script>
