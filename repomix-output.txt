This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitattributes
.gitignore
assets/certs/localhost.crt
assets/certs/README.md
assets/LICENSE.md
assets/package.json
assets/README.md
assets/styles/game.css
assets/ui/index.html
assets/ui/README.md
assets/ui/styles/combo-notification.css
assets/ui/templates/combo-notification.html
CLAUDE.md
generate_cone.py
index.ts
jest.config.js
LICENSE
package.json
README.md
src/__tests__/block-movement.test.ts
src/__tests__/mocks/hytopia.ts
src/__tests__/moving-block-entity.test.ts
src/__tests__/raycast-handler.test.ts
src/__tests__/round-manager.test.ts
src/__tests__/round-scoring.test.ts
src/__tests__/score-manager.test.ts
src/config/particle-config.js
src/config/particle-config.ts
src/effects/block-particle-effects.js
src/effects/block-particle-effects.ts
src/entities/projectile-entity.js
src/entities/projectile-entity.ts
src/entities/README.md
src/managers/audio-manager.js
src/managers/audio-manager.ts
src/managers/player-projectile-manager.ts
src/managers/player-settings-manager.ts
src/managers/README.md
src/managers/round-manager.ts
src/managers/score-manager.js
src/managers/score-manager.ts
src/moving_blocks/block-movement.js
src/moving_blocks/block-movement.ts
src/moving_blocks/moving-block-entity.js
src/moving_blocks/moving-block-entity.ts
src/raycast/raycast-handler.js
src/raycast/raycast-handler.ts
src/raycast/README.md
src/scene-ui/scene-ui-manager.js
src/scene-ui/scene-ui-manager.ts
src/test-round-transitions.js
src/types.js
src/types.ts
src/utils/test-spawner.ts
tsconfig.json

================================================================
Files
================================================================

================
File: .gitattributes
================
# Auto detect text files and perform LF normalization
* text=auto

================
File: .gitignore
================
# Based on https://raw.githubusercontent.com/github/gitignore/main/Node.gitignore

# Logs

logs
_.log
npm-debug.log_
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Caches

.cache

# Diagnostic reports (https://nodejs.org/api/report.html)

report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# Runtime data

pids
_.pid
_.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover

lib-cov

# Coverage directory used by tools like istanbul

coverage
*.lcov

# nyc test coverage

.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)

.grunt

# Bower dependency directory (https://bower.io/)

bower_components

# node-waf configuration

.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)

build/Release

# Dependency directories

node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)

web_modules/

# TypeScript cache

*.tsbuildinfo

# Optional npm cache directory

.npm

# Optional eslint cache

.eslintcache

# Optional stylelint cache

.stylelintcache

# Microbundle cache

.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history

.node_repl_history

# Output of 'npm pack'

*.tgz

# Yarn Integrity file

.yarn-integrity

# dotenv environment variable files

.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)

.parcel-cache

# Next.js build output

.next
out

# Nuxt.js build / generate output

.nuxt
dist

# Gatsby files

# Comment in the public line in if your project uses Gatsby and not Next.js

# https://nextjs.org/blog/next-9-1#public-directory-support

# public

# vuepress build output

.vuepress/dist

# vuepress v2.x temp and cache directory

.temp

# Docusaurus cache and generated files

.docusaurus

# Serverless directories

.serverless/

# FuseBox cache

.fusebox/

# DynamoDB Local files

.dynamodb/

# TernJS port file

.tern-port

# Stores VSCode versions used for testing VSCode extensions

.vscode-test

# yarn v2

.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store    

# Project assets
assets/blocks/
assets/maps/
assets/map.json
assets/skyboxes/
assets/models/

# Third-party models - removed from project
assets/models/projectiles/bomb.gltf
assets/models/projectiles/textures/Stylized_Bomb_mat_*

================
File: assets/certs/localhost.crt
================
-----BEGIN CERTIFICATE-----
MIIDRjCCAi6gAwIBAgIFOTEzNTIwDQYJKoZIhvcNAQELBQAwWDEQMA4GA1UEAxMH
SFlUT1BJQTELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNV
BAcTB1NlYXR0bGUxEDAOBgNVBAoTB0hZVE9QSUEwHhcNMjQxMTEzMjIyMjEwWhcN
MzQxMTExMjIyMjEwWjAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwggEiMA0GCSqGSIb3
DQEBAQUAA4IBDwAwggEKAoIBAQCo2i9L13+4KxvR9dxBeE3Xrj5WtoGFBwbUZkeV
3B8n+ehJ2LWD13sGvCuHvSDovbSOxLxqbESQzWBRVrmfJMR1qe+o7kd/SMaLHosC
2BWASn1oV9rGLktvd2Xs6xRf75cejzrr/OrNoTpICp3j1Z0Kd+73TuYyVFPfCbqH
N6mwS+yCmG2/w3sXwbOGymNuYpaPoD8XVcIhO7GPZsCVqqSKP2xsGF+oP5+Isma+
y3usNUnFnVW5ckk6SWWdxP9kuOW2xXoFFwj43STaE4OvXbTPCG7jowUpDH1aMvFA
ceXUfuaE7H8QfZqoUNu8jCb8LiqTL+uL5kHbl2kQ7sQCN9gjAgMBAAGjWzBZMAwG
A1UdEwEB/wQCMAAwDgYDVR0PAQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMB
BggrBgEFBQcDAjAaBgNVHREEEzARgglsb2NhbGhvc3SHBH8AAAEwDQYJKoZIhvcN
AQELBQADggEBAHSINJsVuu11kmzx7/2yEiDSIQVzdzk/+hnx0iQt6rDy9ZNVdI8w
JOUYaPjxDFfZ5gaPqrlb0n248lBMdGrp6xmhbgXL8eWkXRDcR6kuYBQrQmFitg7G
KFFWnzCuQMLn5Mn6VA+sBf9n2LVaOQCci9jU0awRpaQTUNf894USjILo+PvbcUGU
XlMtqc1abkN4NehDdaXsxMwyPgUCPkN5X80s8hxx5NgzwtwDtoTYj/PBRBXBddA+
oN1rwkugWiTpIPU0wKb0ufLsq96I24UDQWd2jJGbD2W23Z0lwVz/Bq6uc4aOJn68
JbejJgFyF3/m6oFDxgqMnuV5q5olVZHAWL8=
-----END CERTIFICATE-----

================
File: assets/certs/README.md
================
For local development self-signed certs are stored here.
The server will look for assets/certs/localhost.key and
assets/certs/localhost.cert and use those for localhost SSL.

We use these self-signed certs to allow https://localhost
& wss://localhost support. Without this, play.hytopia.com
requires a bunch of funky browser flag workarounds in
order to connect to your local server. This is only used
for local development and will be ignored when your game
is deployed to HYTOPIA servers.

================
File: assets/LICENSE.md
================
## HYTOPIA LIMITED USE LICENSE

This Limited Use License (the "License") governs your access to and use of certain software and assets provided by HYTOPIA ("HYTOPIA").

By downloading, accessing, or using the accompanying software and materials—which may include data, datasets, images, models, audio, and documentation (collectively, the "Licensed Software")—you agree to be bound by the terms and conditions of this License. The term "you" refers to any individual or entity receiving a copy of the Licensed Software, whether directly from HYTOPIA or through another source.

Accessing and using the Licensed Software may require you in the future to apply for and maintain an active registration and account with HYTOPIA. The use of such an account and associated services (collectively, the "Service") is governed by separate terms (the "Terms of Service").

### 1. License Grant
Subject to your complete and ongoing compliance with this License (including any applicable Terms of Service), HYTOPIA grants you a limited, non-exclusive, non-transferable, non-sublicensable, and revocable permission to access and use the Licensed Software during the License Term (defined below), in accordance with the documentation. This permission is granted solely for the following purposes (collectively, the "Purpose"):

1. Internally incorporating the Licensed Software into your larger applications for deployment through the HYTOPIA platform.
1. Using it in connection with HYTOPIA products and services for which the Licensed Software was designed.
You may collaborate with other developers who have also agreed to and comply with this License, including distributing copies of the Licensed Software to them, as part of exercising your rights under this License.

### 2. Source Code
This License also grants you the right to modify any portions of the Licensed Software provided by HYTOPIA in source code form (the "Licensed Source") and to use these modified versions for the Purpose.

### 3. Usage Guidelines
You must not use the Licensed Software to:

- Transmit unlawful or objectionable material.
- Transmit viruses or other harmful computer code.
- Interfere with the performance of the Service or the data it contains.
- Attempt to gain unauthorized access to the Service or related networks.
- Interfere with another person's use of the Service.
- Access or use the Licensed Software or the Service in connection with any alternative or competitive service.
- Use the Licensed Software or the Service to reproduce, emulate, or replace features of the Service.
- Remove any attribution information or proprietary notices in the Licensed Software.

The Licensed Software may use, reference, or rely on materials separately available from HYTOPIA or other sources. Additional terms and conditions may apply to access and use any such dependencies.

### 4. Feedback
You may choose, but are not required, to provide HYTOPIA with feedback regarding the Licensed Software. This includes:

- Reporting errors you encounter.
- Providing suggestions for modifications and enhancements.
- Submitting bug fixes, contributions, or other associated code.
- Making other similar submissions (collectively, "Feedback").

You retain ownership of your rights in any Feedback you provide. However, by submitting or making Feedback available to HYTOPIA, you irrevocably grant HYTOPIA and its successors an unrestricted, unlimited, worldwide, non-exclusive, transferable, sublicensable, fully paid-up, royalty-free license to:
- Reproduce, distribute, publicly perform or display, and prepare derivative works of the Feedback.
- Make, have made, use, sell, offer for sale, and import any product or service.
- Practice any method disclosed in the Feedback.

This license is granted in any form or manner and without limitation, attribution, or compensation.

### 5. Reservation of Rights
HYTOPIA retains all rights, title, and interest—including all intellectual property rights—in and to the Licensed Software and any derivatives thereof. Nothing in this License grants or confers on you any ownership of these rights, whether expressly, by implication, estoppel, or otherwise.

### 6. Disclaimer; Limitation of Liability
THE LICENSED SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS. To the maximum extent permitted by applicable law, HYTOPIA disclaims all warranties, whether express, implied, statutory, or otherwise. This includes, without limitation, any warranties of merchantability, non-infringement, fitness for a particular purpose, or that the Licensed Software will be error-free or uninterrupted.

In no event will HYTOPIA have any direct or indirect liability to you under this License. This includes any lost profits, loss of data, loss of use, costs of procuring substitute goods or services, or any special, punitive, or exemplary damages—however caused and under any theory of liability—whether in contract, tort, or otherwise, even if HYTOPIA has been advised of the possibility of such damages.

You acknowledge and understand that the Licensed Software may be provided on an alpha, beta, or other pre-release basis. HYTOPIA is under no obligation to make any further releases, including any production release. Any subsequent release may differ from the Licensed Software in any manner HYTOPIA sees fit, including adding, modifying, or removing features and functionality present in the Licensed Software.

You agree that the limitations of liability and disclaimers of warranties and damages set forth herein form an essential basis of your agreement with HYTOPIA. They will survive and apply even if found to have failed of their essential purpose, to the fullest extent permissible under applicable law.

### 7. Term and Termination
This Agreement begins on the date you accept this License and, unless terminated earlier as described below or extended by mutual written agreement, will terminate upon the later of:

(a) The License Term specified when you access the Licensed Software, or
(b) The public release of the production version of the Licensed Software (the "License Term").
HYTOPIA may terminate this License (and your access to the Licensed Software and any associated materials) at any time, for any reason or no reason.

Any provisions that by their nature or express terms survive expiration or termination of this License will survive such expiration or termination. Your obligations regarding Confidential Information and Feedback will survive indefinitely, regardless of any eventual publication of a commercial or production version of the Licensed Software.

Upon expiration or termination of this License for any reason, you must cease using the Licensed Software and return or destroy all copies of the Licensed Software or Licensed Source (and any derivatives thereof) and any other Confidential Information in your possession.

================
File: assets/package.json
================
{
  "name": "@hytopia.com/assets",
  "version": "0.2.5",
  "description": "A variety of default assets for HYTOPIA games.",
  "main": "index.js",
  "private": false,
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/hytopiagg/assets.git"
  },
  "keywords": [
    "hytopia",
    "gltf",
    "models",
    "assets",
    "3d",
    "game",
    "builder",
    "minecraft",
    "roblox",
    "tools",
    "free"
  ],
  "author": "HYTOPIA <hytopia.com>",
  "license": "SEE LICENSE IN LICENSE.md",
  "bugs": {
    "url": "https://github.com/hytopiagg/assets/issues"
  },
  "homepage": "https://github.com/hytopiagg/assets#readme"
}

================
File: assets/README.md
================
# HYTOPIA Assets

This package contains the default set of assets provided by HYTOPIA for creating games with. You may use these assets as you like to develop your HYTOPIA games.

When creating a new HYTOPIA project using the HYTOPIA SDK, the latest version of these assets will automatically be copied into your `assets` folder of your project.

================
File: assets/styles/game.css
================
/* Combo Notifications */
.combo-notification {
  position: fixed;
  top: 20%;
  left: 50%;
  transform: translateX(-50%);
  z-index: 1000;
  pointer-events: none;
  animation: comboSlideIn 0.3s ease-out;
}

.combo-counter {
  display: flex;
  flex-direction: column;
  align-items: center;
  font-family: 'Arial', sans-serif;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
  color: white;
  padding: 10px;
  border-radius: 8px;
  background: rgba(0,0,0,0.7);
}

.combo-hits {
  font-size: 48px;
  font-weight: bold;
  margin-bottom: 5px;
}

.combo-text {
  font-size: 24px;
  margin-bottom: 5px;
}

.combo-bonus {
  font-size: 20px;
  color: #ffdd00;
}

/* Combo tiers */
.combo { color: #00ff00; }
.super-combo { color: #00ffff; }
.ultra-combo { color: #ff00ff; }
.mega-combo { 
  color: #ff0000;
  animation: pulse 0.5s infinite;
}

/* Animations */
@keyframes comboSlideIn {
  from {
    transform: translateX(-50%) translateY(-20px);
    opacity: 0;
  }
  to {
    transform: translateX(-50%) translateY(0);
    opacity: 1;
  }
}

@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}

.fade-out {
  animation: fadeOut 0.5s forwards;
}

@keyframes fadeOut {
  to {
    opacity: 0;
    transform: translateX(-50%) translateY(-20px);
  }
}

/* Persistent Combo Display */
.combo-display {
  position: fixed;
  top: 100px;
  right: 20px;
  background: rgba(0,0,0,0.7);
  padding: 10px;
  border-radius: 8px;
  color: white;
  font-family: 'Arial', sans-serif;
  display: flex;
  flex-direction: column;
  align-items: flex-end;
}

.combo-display.active {
  animation: glowPulse 1s infinite;
}

@keyframes glowPulse {
  0% { box-shadow: 0 0 5px #ffdd00; }
  50% { box-shadow: 0 0 20px #ffdd00; }
  100% { box-shadow: 0 0 5px #ffdd00; }
}

================
File: assets/ui/index.html
================
<!DOCTYPE html>
<html>
<head>
  <link href="https://fonts.googleapis.com/css2?family=Permanent+Marker&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Audiowide&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
  <style>
    :root {
      --matrix-green: #00ff41;
      --matrix-dark: #0d0208;
      --matrix-light: #003b00;
      --blood-red: #ff1717;
      --dark-red: #8b0000;
      --glow-red: #ff000d;
      --terminal-green: #39ff14;
      --matrix-bg: rgba(0, 15, 2, 0.85);
      --title-font: 'Press Start 2P', cursive;
      --display-font: 'VT323', monospace;
      --number-font: 'VT323', monospace;
      --text-font: 'VT323', monospace;
    }

    .projectile-counter {
      position: absolute;
      bottom: 40px;
      right: 40px;
      background: linear-gradient(135deg, var(--matrix-dark) 0%, rgba(13, 2, 8, 0.95) 100%);
      padding: 15px 25px;
      border-radius: 16px;
      color: #ffffff;
      font-family: 'Arial', sans-serif;
      display: flex;
      align-items: center;
      gap: 12px;
      backdrop-filter: blur(10px);
      border: 1px solid var(--blood-red);
      transition: all 0.3s ease;
      box-shadow: 0 0 20px rgba(255, 0, 0, 0.2),
                  inset 0 0 10px rgba(255, 0, 0, 0.1);
    }

    .projectile-counter::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 16px;
      background: linear-gradient(45deg, rgba(255,255,255,0.1), rgba(255,255,255,0));
      z-index: -1;
    }

    .projectile-counter.low {
      background: linear-gradient(135deg, rgba(45, 27, 78, 0.85) 0%, rgba(45, 27, 78, 0.95) 100%);
      border-color: var(--neon-pink);
      box-shadow: 0 0 20px rgba(255, 113, 206, 0.3),
                  inset 0 0 15px rgba(255, 113, 206, 0.2);
    }

    .projectile-counter.shake {
      animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
      transform-origin: center center;
      backface-visibility: hidden;
      perspective: 1000px;
    }

    .projectile-icon {
      width: 28px;
      height: 28px;
      background: radial-gradient(circle at 30% 30%, var(--blood-red), var(--dark-red)) !important;
      border-radius: 50%;
      position: relative;
      display: inline-block;
      box-shadow: 0 0 15px var(--glow-red) !important;
      transition: all 0.3s ease;
    }

    .projectile-icon::after {
      content: '';
      position: absolute;
      top: 15%;
      left: 15%;
      width: 30%;
      height: 30%;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      filter: blur(1px);
    }

    .projectile-counter.low .projectile-icon {
      background: radial-gradient(circle at 30% 30%, var(--neon-pink), #ff0055) !important;
      box-shadow: 0 0 15px var(--neon-pink) !important;
    }

    .projectile-count {
      font-family: var(--number-font);
      font-size: 36px;
      font-weight: bold;
      min-width: 35px;
      text-align: center;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
      letter-spacing: 2px;
    }

    .count-change {
      animation: pulse 0.5s ease-out;
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }

    @keyframes shake {
      0%, 100% { transform: translate3d(0, 0, 0) rotate(0deg); }
      10%, 90% { transform: translate3d(-2px, 1px, 0) rotate(-1deg); }
      20%, 80% { transform: translate3d(3px, -1px, 0) rotate(1deg); }
      30%, 50%, 70% { transform: translate3d(-4px, 2px, 0) rotate(-2deg); }
      40%, 60% { transform: translate3d(4px, -2px, 0) rotate(2deg); }
    }

    .particles {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      overflow: hidden;
      z-index: -1;
    }

    .particle {
      position: absolute;
      width: 4px;
      height: 4px;
      background: var(--blood-red);
      border-radius: 50%;
      pointer-events: none;
      box-shadow: 0 0 5px var(--glow-red);
    }

    .scoreboard {
      position: fixed;
      top: 100px;
      left: 40px;
      background: linear-gradient(135deg, var(--matrix-dark) 0%, rgba(13, 2, 8, 0.95) 100%);
      padding: 20px;
      border-radius: 10px;
      color: #ffffff;
      font-family: var(--text-font);
      backdrop-filter: blur(10px);
      border: 1px solid var(--blood-red);
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 10px;
      box-shadow: 0 0 20px rgba(255, 0, 0, 0.2),
                  inset 0 0 10px rgba(255, 0, 0, 0.1);
      min-width: 240px;
      text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
    }

    .leaderboard {
      position: fixed;
      top: 100px;
      right: 40px;
      background: linear-gradient(135deg, var(--matrix-dark) 0%, rgba(13, 2, 8, 0.95) 100%);
      padding: 20px;
      border-radius: 10px;
      color: #ffffff;
      font-family: var(--text-font);
      backdrop-filter: blur(10px);
      border: 1px solid var(--blood-red);
      box-shadow: 0 0 20px rgba(255, 0, 0, 0.2),
                  inset 0 0 10px rgba(255, 0, 0, 0.1);
      min-width: 240px;
      z-index: 100;
    }

    .leaderboard-title {
      font-family: var(--title-font);
      font-size: 18px;
      color: var(--blood-red);
      margin-bottom: 15px;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-shadow: 0 0 10px var(--glow-red),
                   0 0 20px var(--glow-red);
      transform: none;
    }

    .leaderboard-entry {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(90deg, rgba(0, 0, 0, 0.3) 0%, rgba(0, 0, 0, 0.1) 100%);
      margin: 10px 0;
      padding: 12px 15px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.3s ease;
    }

    .leaderboard-entry:hover {
      transform: translateX(-5px);
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.05) 0%, rgba(0, 0, 0, 0.2) 100%);
    }

    .leaderboard-entry.winner {
      background: linear-gradient(90deg, rgba(255, 215, 0, 0.1) 0%, rgba(0, 0, 0, 0.2) 100%);
      border-color: #ffd700;
    }
    
    .leaderboard-entry.current-player {
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.1) 0%, rgba(0, 0, 0, 0.2) 100%);
      border-width: 2px;
    }

    .player-name {
      font-family: var(--text-font);
      font-size: 16px;
      letter-spacing: 1px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .player-info {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .player-rank {
      font-family: var(--number-font);
      font-size: 24px;
      min-width: 30px;
      text-align: center;
      text-shadow: 0 0 5px rgba(255, 255, 255, 0.4);
    }
    
    .rank-change {
      font-size: 16px;
      margin: 0 5px;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      border-radius: 50%;
    }
    
    .rank-up {
      color: #4CAF50;
      animation: pulse-green 2s infinite;
    }
    
    .rank-down {
      color: #F44336;
      animation: pulse-red 2s infinite;
    }
    
    .rank-same {
      color: #FFD700;
    }
    
    .rank-new {
      color: #2196F3;
      animation: sparkle 1.5s infinite;
    }
    
    @keyframes pulse-green {
      0% { transform: scale(1); text-shadow: 0 0 2px rgba(76, 175, 80, 0.5); }
      50% { transform: scale(1.1); text-shadow: 0 0 10px rgba(76, 175, 80, 0.8); }
      100% { transform: scale(1); text-shadow: 0 0 2px rgba(76, 175, 80, 0.5); }
    }
    
    @keyframes pulse-red {
      0% { transform: scale(1); text-shadow: 0 0 2px rgba(244, 67, 54, 0.5); }
      50% { transform: scale(1.1); text-shadow: 0 0 10px rgba(244, 67, 54, 0.8); }
      100% { transform: scale(1); text-shadow: 0 0 2px rgba(244, 67, 54, 0.5); }
    }
    
    @keyframes sparkle {
      0% { transform: scale(1) rotate(0deg); text-shadow: 0 0 5px rgba(33, 150, 243, 0.7); }
      25% { transform: scale(1.2) rotate(15deg); text-shadow: 0 0 15px rgba(33, 150, 243, 1); }
      50% { transform: scale(1) rotate(0deg); text-shadow: 0 0 5px rgba(33, 150, 243, 0.7); }
      75% { transform: scale(1.2) rotate(-15deg); text-shadow: 0 0 15px rgba(33, 150, 243, 1); }
      100% { transform: scale(1) rotate(0deg); text-shadow: 0 0 5px rgba(33, 150, 243, 0.7); }
    }

    .player-wins {
      font-family: var(--number-font);
      font-size: 28px;
      text-shadow: 0 0 5px rgba(255, 255, 255, 0.4);
      letter-spacing: 1px;
    }

    .round-info {
      border-bottom: 1px solid var(--blood-red);
      padding-bottom: 15px;
      margin-bottom: 15px;
    }

    .waiting-message {
      font-family: var(--display-font);
      font-size: 16px;
      letter-spacing: 2px;
    }

    .player-count {
      font-size: 18px;
      color: #ffffff;
      text-align: left;
    }

    .round-number {
      font-family: var(--display-font);
      font-size: 16px;
      color: var(--blood-red);
      text-shadow: 0 0 10px var(--glow-red);
      letter-spacing: 1px;
      margin-bottom: 8px;
    }

    .round-timer {
      position: fixed;
      top: 40px;
      left: 50%;
      transform: translateX(-50%);
      font-family: var(--display-font);
      font-size: 32px;
      color: var(--matrix-green);
      text-shadow: 0 0 10px var(--terminal-green);
      background: rgba(13, 2, 8, 0.9);
      padding: 15px 30px;
      border-radius: 8px;
      border: 1px solid var(--matrix-green);
      z-index: 1000;  /* Increased z-index to ensure it's above other elements */
      text-align: center;
      min-width: 200px;
      pointer-events: none;  /* Ensure it doesn't interfere with clicking */
    }

    .round-timer.warning {
      color: var(--blood-red);
      text-shadow: 0 0 10px var(--glow-red);
    }

    .round-timer.danger {
      color: var(--blood-red);
      text-shadow: 0 0 15px var(--glow-red);
      animation: matrix-flicker 0.5s infinite;
    }

    @keyframes matrix-pulse {
      0% { opacity: 0.8; text-shadow: 0 0 5px var(--glow-red); }
      50% { opacity: 1; text-shadow: 0 0 20px var(--glow-red); }
      100% { opacity: 0.8; text-shadow: 0 0 5px var(--glow-red); }
    }

    @keyframes matrix-flicker {
      0% { opacity: 0.8; text-shadow: 0 0 10px var(--glow-red); }
      25% { opacity: 0.3; }
      50% { opacity: 1; text-shadow: 0 0 30px var(--glow-red); }
      75% { opacity: 0.5; }
      100% { opacity: 0.8; text-shadow: 0 0 10px var(--glow-red); }
    }

    .score-target {
      font-size: 14px;
      color: #4CAF50;
    }

    .scores-wrapper {
      display: flex;
      gap: 20px;
    }

    .player-score {
      font-family: var(--text-font);
      background: linear-gradient(90deg, rgba(0, 0, 0, 0.3) 0%, rgba(0, 0, 0, 0.1) 100%);
      padding: 12px 15px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      margin: 8px 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.3s ease;
    }
    
    .player-score.current-player {
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.1) 0%, rgba(0, 0, 0, 0.2) 100%);
      border-width: 2px;
      transform: translateX(5px);
    }
    
    .player-score:hover {
      transform: translateX(5px);
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.05) 0%, rgba(0, 0, 0, 0.2) 100%);
    }
    
    .player-indicator {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .player-avatar {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: inline-block;
      box-shadow: 0 0 8px rgba(255, 255, 255, 0.4);
    }
    
    .player-avatar.large {
      width: 32px;
      height: 32px;
      margin-right: 10px;
      box-shadow: 0 0 12px rgba(255, 255, 255, 0.6);
    }
    
    .player-label {
      font-size: 16px;
      font-weight: bold;
      letter-spacing: 1px;
      text-shadow: 0 0 5px rgba(255, 255, 255, 0.4);
    }
    
    .player-you-tag {
      font-size: 12px;
      background: rgba(255, 255, 255, 0.2);
      padding: 2px 6px;
      border-radius: 10px;
      margin-left: 5px;
      color: white;
      text-shadow: none;
    }
    
    .score-info {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
    }

    .score-value {
      font-family: var(--number-font);
      font-size: 32px;
      text-shadow: 0 0 8px rgba(255, 255, 255, 0.4);
      letter-spacing: 2px;
    }
    
    .round-score {
      font-size: 18px;
      opacity: 0.8;
      animation: pulseScore 1.5s ease-out;
    }
    
    @keyframes pulseScore {
      0% { opacity: 1; transform: scale(1.2); }
      70% { opacity: 0.9; }
      100% { opacity: 0.8; transform: scale(1); }
    }

    .crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: var(--crosshair-size, 24px);
      height: var(--crosshair-size, 24px);
      pointer-events: none;
      z-index: 1000;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* Outer circle */
    .crosshair::before {
      content: '';
      position: absolute;
      width: var(--ring-size, 20px);
      height: var(--ring-size, 20px);
      border: 2px solid var(--crosshair-color, rgba(255, 255, 0, 0.8));
      border-radius: 50%;
      box-shadow: 0 0 4px var(--crosshair-glow, #ffff00),
                  inset 0 0 4px var(--crosshair-glow, #ffff00),
                  0 0 0 1px rgba(0, 0, 0, 0.5);
      display: var(--show-ring, block);
    }

    /* Center dot */
    .crosshair::after {
      content: '';
      position: absolute;
      width: var(--dot-size, 4px);
      height: var(--dot-size, 4px);
      background-color: var(--crosshair-color, rgba(255, 255, 0, 0.9));
      border-radius: 50%;
      box-shadow: 0 0 4px var(--crosshair-glow, #ffff00),
                  0 0 2px rgba(0, 0, 0, 0.8);
      display: var(--show-dot, block);
    }

    /* Scene UI Container and Notifications */
    .scene-ui-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1000;
    }

    .hit-notification {
      position: absolute;
      transform: translate(-50%, -50%);
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 1001;
    }

    .hit-notification .score {
      color: var(--matrix-green);
      font-family: var(--display-font);
      font-size: 28px;
      text-shadow: 0 0 10px var(--terminal-green),
                   0 0 20px var(--terminal-green),
                   0 0 30px var(--terminal-green);
      animation: hitNotification 1s cubic-bezier(0.22, 1, 0.36, 1) forwards;
      opacity: 0;
      transform: scale(0.5) translateZ(0);
      transform-origin: center center;
    }

    .block-destroyed-notification {
      position: absolute;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      pointer-events: none;
      z-index: 1001;
    }

    .block-destroyed-notification .score {
      font-family: var(--display-font);
      font-size: 48px;
      font-weight: bold;
      opacity: 0;
      transform: scale(0.5) translateZ(0);
      transform-origin: center center;
      perspective: 1000px;
      --pop-intensity: calc(var(--score-value, 0) * 0.01);
      --glow-intensity: calc(var(--intensity, 0.5) * 100%);
    }

    @keyframes scoreAnimation {
      0% {
        opacity: 0;
        transform: scale(0.5) translateZ(-300px) translateY(calc(50px * var(--pop-intensity))) rotate3d(1, 0, 0, -45deg);
        filter: brightness(calc(100% + var(--glow-intensity)));
      }
      15% {
        opacity: 1;
        transform: scale(1.8) translateZ(200px) translateY(calc(-100px * var(--pop-intensity))) rotate3d(1, 0, 0, 30deg);
        filter: brightness(calc(150% + var(--glow-intensity)));
      }
      30% {
        opacity: 1;
        transform: scale(2) translateZ(150px) translateY(calc(-150px * var(--pop-intensity))) rotate3d(1, 0, 0, 15deg);
        filter: brightness(calc(200% + var(--glow-intensity)));
      }
      50% {
        opacity: 1;
        transform: scale(1.8) translateZ(100px) translateY(calc(-200px * var(--pop-intensity))) rotate3d(1, 0, 0, 0deg);
        filter: brightness(calc(150% + var(--glow-intensity)));
      }
      70% {
        opacity: 0.9;
        transform: scale(1.5) translateZ(50px) translateY(calc(-250px * var(--pop-intensity))) rotate3d(1, 0, 0, -10deg);
        filter: brightness(calc(125% + var(--glow-intensity)));
      }
      85% {
        opacity: 0.7;
        transform: scale(1.2) translateZ(25px) translateY(calc(-300px * var(--pop-intensity))) rotate3d(1, 0, 0, -20deg);
        filter: brightness(calc(110% + var(--glow-intensity)));
      }
      100% {
        opacity: 0;
        transform: scale(1) translateZ(0) translateY(calc(-350px * var(--pop-intensity))) rotate3d(1, 0, 0, -30deg);
        filter: brightness(100%);
      }
    }

    /* Settings Menu */
    .settings-menu {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.95);
      background: linear-gradient(135deg, var(--matrix-dark) 0%, rgba(13, 2, 8, 0.98) 100%);
      padding: 60px;
      border-radius: 20px;
      color: #ffffff;
      font-family: var(--text-font);
      backdrop-filter: blur(10px);
      border: 3px solid var(--blood-red);
      box-shadow: 0 0 40px rgba(255, 0, 0, 0.2),
                  inset 0 0 20px rgba(255, 0, 0, 0.1);
      z-index: 2000;
      min-width: 700px;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .settings-menu.visible {
      opacity: 1;
      visibility: visible;
    }

    .settings-title {
      font-family: var(--title-font);
      font-size: 48px;
      color: var(--blood-red);
      text-align: center;
      margin-bottom: 50px;
      text-shadow: 0 0 10px var(--glow-red);
      letter-spacing: 4px;
    }

    .settings-section {
      margin-bottom: 40px;
      padding: 30px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 15px;
      border: 1px solid rgba(255, 0, 0, 0.2);
    }

    .settings-section-title {
      font-family: var(--title-font);
      font-size: 48px;
      color: var(--blood-red);
      margin-bottom: 40px;
      text-shadow: 0 0 8px rgba(255, 0, 0, 0.4);
      letter-spacing: 3px;
      text-transform: uppercase;
      border-bottom: 2px solid rgba(255, 0, 0, 0.3);
      padding-bottom: 20px;
    }

    .settings-option {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 30px 0;
      border-bottom: 2px solid rgba(255, 0, 0, 0.2);
    }

    .settings-option:last-child {
      border-bottom: none;
    }

    .settings-label {
      font-size: 32px;
      color: #ffffff;
      text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
      letter-spacing: 2px;
    }

    .settings-value {
      display: flex;
      align-items: center;
      gap: 30px;
    }

    .settings-button {
      background: linear-gradient(135deg, var(--blood-red) 0%, var(--dark-red) 100%);
      border: none;
      padding: 20px 40px;
      border-radius: 12px;
      color: white;
      font-family: var(--text-font);
      font-size: 32px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
      box-shadow: 0 0 10px rgba(255, 0, 0, 0.2);
      margin-top: 30px;
      letter-spacing: 2px;
    }

    .settings-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 15px rgba(255, 0, 0, 0.3);
    }

    .settings-button:active {
      transform: translateY(0);
    }

    /* Settings overlay background */
    .settings-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(3px);
      z-index: 1999;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

    .settings-overlay.visible {
      opacity: 1;
      visibility: visible;
    }

    .color-dropdown {
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid var(--blood-red);
      color: white;
      padding: 15px 25px;
      border-radius: 8px;
      font-family: var(--text-font);
      font-size: 28px;
      cursor: pointer;
      margin-right: 20px;
      min-width: 200px;
      letter-spacing: 1px;
    }

    .color-dropdown option {
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 15px;
      font-size: 28px;
    }

    .color-controls {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    input[type="range"] {
      width: 300px;
      height: 12px;
    }

    input[type="color"] {
      width: 70px;
      height: 70px;
      padding: 0;
      border: none;
      border-radius: 8px;
    }

    #sensitivity-value {
      font-size: 32px;
      min-width: 60px;
      text-align: center;
      letter-spacing: 2px;
    }

    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 28px;
      color: white;
      cursor: pointer;
    }

    .checkbox-label input[type="checkbox"] {
      width: 24px;
      height: 24px;
      cursor: pointer;
    }

    #global-size-value,
    #ring-size-value,
    #dot-size-value {
      font-size: 32px;
      min-width: 80px;
      text-align: center;
      letter-spacing: 2px;
    }

    /* Updated HUD Guide Styles */
    .scoring-guide-hud {
      position: fixed;
      left: 40px;
      top: 300px; /* Moved down further */
      background: linear-gradient(135deg, var(--matrix-dark) 0%, rgba(13, 2, 8, 0.85) 100%);
      padding: 15px;
      border-radius: 10px;
      color: #ffffff;
      font-family: var(--text-font);
      border: 1px solid var(--blood-red);
      box-shadow: 0 0 15px rgba(255, 0, 0, 0.15);
      max-width: 320px; /* Increased width */
      opacity: 0.85;
      transition: opacity 0.3s;
    }

    .scoring-guide-hud .guide-header {
      font-family: var(--title-font);
      font-size: 16px; /* Bigger header */
      color: var(--blood-red);
      margin-bottom: 10px;
      letter-spacing: 1.5px;
      text-align: center;
    }

    .scoring-guide-hud .guide-item {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 15px; /* Bigger text */
      letter-spacing: 0.5px;
      padding: 4px 0;
    }

    .scoring-guide-hud .guide-icon {
      font-size: 18px; /* Bigger icons */
      min-width: 25px;
      text-align: center;
    }

    /* Subtle HUD Hotkey Hints */
    .hotkey-hints {
      position: fixed;
      right: 250px;   /* Moved even more to the left (from 150px) */
      bottom: 40px;
      display: flex;
      gap: 20px;
      font-family: var(--display-font);
      font-size: 18px;
      opacity: 0.7;
      transition: opacity 0.3s;
      background: rgba(0, 0, 0, 0.3);
      padding: 10px 15px;
      border-radius: 8px;
      z-index: 999;
    }

    .hotkey-hints:hover {
      opacity: 1;
    }

    .hotkey-hint {
      color: var(--matrix-green);
      text-shadow: 0 0 8px var(--terminal-green);
      letter-spacing: 0.5px;
    }

    /* Add combo notification styles directly here */
    .combo-notification {
      position: fixed;
      left: 50%;
      bottom: 80px;  /* Moved lower, closer to the bottom */
      transform: translateX(-50%);
      pointer-events: none;
      font-family: var(--display-font);
      text-align: center;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .combo-notification.active {
      opacity: 1;
    }

    .combo-counter {
      background: rgba(0, 0, 0, 0.3);
      padding: 4px 12px;
      border-radius: 4px;
      backdrop-filter: blur(2px);
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 8px;
      justify-content: center;
    }

    .combo-hits {
      font-size: 24px;
      font-weight: bold;
      color: var(--matrix-green);
      text-shadow: 0 0 6px var(--terminal-green);
      opacity: 0.9;
    }

    .combo-text {
      font-size: 18px;
      color: rgba(255, 255, 255, 0.8);
      text-shadow: 0 0 4px rgba(255, 255, 255, 0.4);
      letter-spacing: 1px;
    }

    .combo-bonus {
      font-size: 16px;
      color: rgba(255, 255, 0, 0.8);
      text-shadow: 0 0 4px rgba(255, 255, 0, 0.4);
      letter-spacing: 1px;
      margin-left: 4px;
    }

    @keyframes comboSlideIn {
      from {
        transform: translateX(-50%) translateY(20px);
        opacity: 0;
      }
      to {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
      }
    }

    /* Combo tiers with different colors */
    .combo .combo-hits { 
      color: rgba(255, 255, 255, 0.9);
      text-shadow: 0 0 4px rgba(255, 255, 255, 0.4);
    }
    .super-combo .combo-hits { 
      color: rgba(0, 255, 255, 0.9);
      text-shadow: 0 0 4px rgba(0, 255, 255, 0.4);
    }
    .ultra-combo .combo-hits { 
      color: rgba(255, 0, 255, 0.9);
      text-shadow: 0 0 4px rgba(255, 0, 255, 0.4);
    }
    .mega-combo .combo-hits { 
      color: rgba(255, 0, 0, 0.9);
      text-shadow: 0 0 4px rgba(255, 0, 0, 0.4);
    }

    .system-message {
      position: fixed;
      top: 20%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: var(--display-font);
      font-size: 24px;
      color: var(--blood-red);
      text-shadow: 0 0 10px var(--glow-red);
      background: rgba(13, 2, 8, 0.9);
      padding: 15px 30px;
      border-radius: 8px;
      border: 1px solid var(--blood-red);
      z-index: 1000;
      animation: fadeInOut 4s ease-in-out;
    }

    @keyframes fadeInOut {
      0% { opacity: 0; transform: translate(-50%, -60%); }
      10% { opacity: 1; transform: translate(-50%, -50%); }
      90% { opacity: 1; transform: translate(-50%, -50%); }
      100% { opacity: 0; transform: translate(-50%, -40%); }
    }

    .round-end {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, var(--matrix-dark) 0%, rgba(13, 2, 8, 0.95) 100%);
      padding: 40px;
      border-radius: 20px;
      color: #ffffff;
      font-family: var(--text-font);
      backdrop-filter: blur(10px);
      border: 3px solid var(--blood-red);
      box-shadow: 0 0 60px rgba(255, 0, 0, 0.4),
                  inset 0 0 30px rgba(255, 0, 0, 0.2);
      z-index: 1000;
      min-width: 450px;
      text-align: center;
      animation: pulseDialog 2s infinite alternate;
    }
    
    @keyframes pulseDialog {
      0% { box-shadow: 0 0 40px rgba(255, 0, 0, 0.3), inset 0 0 20px rgba(255, 0, 0, 0.2); }
      100% { box-shadow: 0 0 60px rgba(255, 0, 0, 0.5), inset 0 0 30px rgba(255, 0, 0, 0.3); }
    }

    .round-end-title {
      font-family: var(--title-font);
      font-size: 32px;
      color: var(--blood-red);
      margin-bottom: 30px;
      text-transform: uppercase;
      letter-spacing: 3px;
      text-shadow: 0 0 20px var(--glow-red);
      animation: titleGlow 1.5s infinite alternate;
    }
    
    @keyframes titleGlow {
      0% { text-shadow: 0 0 15px var(--glow-red); }
      100% { text-shadow: 0 0 25px var(--glow-red); }
    }

    .round-end-placement {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 10px 0;
      padding: 15px 20px;
      background: linear-gradient(90deg, rgba(0, 0, 0, 0.3) 0%, rgba(0, 0, 0, 0.1) 100%);
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.3s ease;
    }

    .round-end-placement.first {
      background: linear-gradient(90deg, rgba(255, 215, 0, 0.1) 0%, rgba(0, 0, 0, 0.2) 100%);
      border: 1px solid #ffd700;
    }
    
    .round-end-placement.current-player {
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.1) 0%, rgba(0, 0, 0, 0.2) 100%);
      border-width: 2px;
    }
    
    .round-end-placement .player-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .round-end-placement .player-name {
      font-family: var(--text-font);
      font-size: 18px;
      letter-spacing: 1px;
    }
    
    .round-end-placement .player-avatar {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: inline-block;
      box-shadow: 0 0 8px rgba(255, 255, 255, 0.4);
    }

    .placement-rank {
      font-family: var(--number-font);
      font-size: 28px;
      min-width: 40px;
      text-shadow: 0 0 5px rgba(255, 255, 255, 0.4);
    }

    .placement-points {
      font-family: var(--number-font);
      font-size: 28px;
      text-shadow: 0 0 5px rgba(255, 255, 255, 0.4);
      letter-spacing: 1px;
    }
    
    .round-end-placements {
      margin: 20px 0;
    }

    .next-round-timer {
      font-family: var(--display-font);
      font-size: 22px;
      color: var(--matrix-green);
      margin-top: 30px;
      padding: 10px;
      border-radius: 5px;
      background: rgba(0, 0, 0, 0.3);
      text-shadow: 0 0 10px var(--terminal-green);
    }

    .round-complete-message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);  /* Changed to center both vertically and horizontally */
      font-family: var(--display-font);
      font-size: 48px;  /* Made even larger */
      color: var(--matrix-green);
      text-shadow: 0 0 20px var(--terminal-green);  /* Increased glow */
      background: rgba(13, 2, 8, 0.9);
      padding: 20px 40px;  /* Increased padding */
      border-radius: 8px;
      border: 2px solid var(--matrix-green);  /* Made border thicker */
      z-index: 1000;  /* Increased z-index to ensure it's on top */
      text-align: center;
      animation: pulseCenter 0.5s ease-out infinite;
    }

    @keyframes pulseCenter {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.1); }  /* Increased scale effect */
      100% { transform: translate(-50%, -50%) scale(1); }
    }

    /* Game status elements */
    .game-status {
      position: fixed;
      top: 40px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
      pointer-events: none;
      z-index: 1000;
    }

    .game-status .round-number {
      font-family: var(--display-font);
      font-size: 32px;
      color: var(--matrix-green);
      text-shadow: 0 0 10px var(--terminal-green);
      text-align: center;
      background: rgba(13, 2, 8, 0.9);
      padding: 5px 20px;
      border-radius: 8px;
      border: 1px solid var(--matrix-green);
      margin-bottom: 5px;
    }

    .game-status .round-timer {
      font-family: var(--display-font);
      font-size: 24px;
      color: var(--blood-red);
      text-shadow: 0 0 10px var(--glow-red);
      text-align: center;
      background: rgba(13, 2, 8, 0.9);
      padding: 5px 15px;
      border-radius: 4px;
      border: 1px solid var(--blood-red);
    }

    .game-status.waiting {
      border-color: var(--blood-red);
    }

    .game-status.waiting .round-number,
    .game-status.waiting .round-timer {
      color: var(--blood-red);
      text-shadow: 0 0 10px var(--glow-red);
    }

    .scores-title {
      font-family: var(--display-font);
      font-size: 24px;
      color: var(--blood-red);
      text-shadow: 0 0 10px var(--glow-red);
      margin-bottom: 15px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    /* Add this to the style section */
    .game-end-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, rgba(13, 2, 8, 0.95) 0%, rgba(13, 2, 8, 0.98) 100%);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 2000;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.5s ease;
    }

    .game-end-overlay.visible {
        opacity: 1;
        pointer-events: auto;
    }

    .game-end-content {
        background: linear-gradient(135deg, var(--matrix-dark) 0%, rgba(13, 2, 8, 0.95) 100%);
        padding: 40px;
        border-radius: 20px;
        border: 3px solid var(--blood-red);
        box-shadow: 0 0 50px rgba(255, 0, 0, 0.3),
                    inset 0 0 25px rgba(255, 0, 0, 0.2);
        text-align: center;
        max-width: 800px;
        width: 90%;
    }

    .game-end-title {
        font-family: var(--title-font);
        font-size: 64px;
        color: var(--blood-red);
        text-shadow: 0 0 20px var(--glow-red);
        margin-bottom: 30px;
        letter-spacing: 4px;
        animation: titlePulse 2s infinite;
    }

    .winner-announcement {
        font-family: var(--display-font);
        font-size: 48px;
        color: #ffd700;
        text-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        margin-bottom: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .final-standings {
        margin: 30px 0;
        width: 100%;
    }
    
    .standing-player-info {
        display: flex;
        align-items: center;
        gap: 12px;
        min-width: 150px;
    }
    
    .standing-stats {
        display: flex;
        gap: 30px;
        align-items: center;
        flex-wrap: wrap;
        justify-content: center;
    }

    .standing-entry {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: linear-gradient(90deg, rgba(255, 0, 0, 0.1) 0%, transparent 100%);
        margin: 10px 0;
        padding: 20px;
        border-radius: 10px;
        border: 1px solid rgba(255, 0, 0, 0.2);
        transition: all 0.3s ease;
    }

    .standing-entry.winner {
        background: linear-gradient(90deg, rgba(255, 215, 0, 0.2) 0%, transparent 100%);
        border: 1px solid #ffd700;
    }

    .standing-position {
        font-family: var(--number-font);
        font-size: 36px;
        color: var(--matrix-green);
        min-width: 60px;
        text-align: center;
    }

    .standing-stats {
        display: flex;
        gap: 30px;
        align-items: center;
    }

    .standing-stat {
        text-align: center;
    }

    .stat-label {
        font-family: var(--text-font);
        font-size: 16px;
        color: rgba(255, 255, 255, 0.7);
        margin-bottom: 5px;
    }

    .stat-value {
        font-family: var(--number-font);
        font-size: 32px;
        color: var(--matrix-green);
        text-shadow: 0 0 10px var(--terminal-green);
    }

    .next-game-timer {
        font-family: var(--display-font);
        font-size: 24px;
        color: rgba(255, 255, 255, 0.8);
        margin-top: 30px;
    }

    @keyframes titlePulse {
        0% { text-shadow: 0 0 20px var(--glow-red); }
        50% { text-shadow: 0 0 40px var(--glow-red); }
        100% { text-shadow: 0 0 20px var(--glow-red); }
    }

    .scoring-guide-hud .guide-icon {
      font-size: 18px; /* Bigger icons */
      min-width: 25px;
      text-align: center;
    }

    /* Help Menu Styles */
    .help-menu {
      position: fixed;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      background: linear-gradient(135deg, var(--matrix-dark) 0%, rgba(13, 2, 8, 0.95) 100%);
      border: 2px solid var(--blood-red);
      border-radius: 15px;
      color: #ffffff;
      padding: 25px;
      display: none;
      z-index: 1000;
      min-width: 400px;
      box-shadow: 0 0 30px rgba(255, 0, 0, 0.2);
      font-family: var(--text-font);
    }

    .help-menu.visible {
      display: block;
      animation: slideIn 0.3s ease-out;
    }

    .help-menu.closing {
      animation: slideOut 0.3s ease-in;
    }

    @keyframes slideIn {
      from { transform: translateY(-50%) translateX(50px); opacity: 0; }
      to { transform: translateY(-50%) translateX(0); opacity: 1; }
    }

    @keyframes slideOut {
      from { transform: translateY(-50%) translateX(0); opacity: 1; }
      to { transform: translateY(-50%) translateX(50px); opacity: 0; }
    }

    .help-content {
      font-family: var(--text-font);
      font-size: 18px;
    }

    .help-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 2px solid var(--blood-red);
    }

    .help-title {
      font-family: var(--title-font);
      font-size: 28px;
      color: var(--blood-red);
      letter-spacing: 2px;
      text-shadow: 0 0 10px rgba(255, 0, 0, 0.4);
    }

    .help-key {
      background: rgba(255, 0, 0, 0.2);
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 16px;
      color: var(--blood-red);
      border: 1px solid var(--blood-red);
      text-shadow: 0 0 8px var(--glow-red);
      font-family: var(--display-font);
    }

    .help-section {
      margin-bottom: 25px;
    }

    .help-section h3 {
      font-family: var(--title-font);
      font-size: 20px;
      color: var(--blood-red);
      margin-bottom: 15px;
      letter-spacing: 1px;
      text-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
    }

    .guide-items {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .guide-item {
      display: flex;
      align-items: center;
      gap: 15px;
      font-size: 20px;
      font-family: var(--text-font);
    }

    .guide-text {
      font-family: var(--text-font);
      font-size: 20px;
    }

    .guide-icon {
      font-size: 24px;
      min-width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 0, 0, 0.1);
      border-radius: 50%;
    }

    .control-item {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-bottom: 10px;
    }

    .control-item .key {
      background: rgba(255, 255, 255, 0.1);
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 16px;
      min-width: 60px;
      text-align: center;
      font-family: var(--display-font);
      border: 1px solid rgba(255, 0, 0, 0.3);
      text-shadow: 0 0 5px var(--glow-red);
    }

    .control-item .action {
      font-size: 20px;
      color: rgba(255, 255, 255, 0.9);
      text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
      font-family: var(--text-font);
    }

    /* Subtle HUD Hotkey Hints */
  </style>
</head>
<body>
<!-- Scene UI Templates -->
<template id="hit-notification-template">
  <div class="hit-notification">
    <span class="score">+0</span>
  </div>
</template>

<template id="block-destroyed-notification-template">
  <div class="block-destroyed-notification">
    <div class="score">+0</div>
  </div>
</template>

<template id="combo-notification-template">
  <div class="combo-notification">
    <div class="combo-counter">
      <div class="combo-hits"></div>
      <div class="combo-text"></div>
      <div class="combo-bonus"></div>
    </div>
  </div>
</template>

<script>
  // Register Scene UI Templates
  hytopia.registerSceneUITemplate('hit-notification', (id, onState) => {
    const template = document.getElementById('hit-notification-template');
    const clone = template.content.cloneNode(true);
    const scoreElement = clone.querySelector('.score');
    
    onState(state => {
      if (scoreElement && state?.score != null) {
        scoreElement.textContent = `+${Math.round(Number(state.score))}`;
      }
    });
    
    return clone;
  });

  hytopia.registerSceneUITemplate('block-destroyed-notification', (id, onState) => {
    const template = document.getElementById('block-destroyed-notification-template');
    const clone = template.content.cloneNode(true);
    
    // Get both elements - we need to get these before returning the clone
    const scoreElement = clone.querySelector('.score');
    
    // Register the state handler
    onState(state => {
      if (scoreElement && state?.score != null) {
        const score = Math.round(Number(state.score));
        scoreElement.textContent = `+${score}`;
        
        // Apply score class
        if (state.class) {
          scoreElement.className = `score ${state.class}`;
        }
        
        // Apply custom style if provided
        if (state.style) {
          scoreElement.style.cssText = state.style;
        }
      }
    });
    
    return clone;
  });

  // Update the combo notification template registration
  hytopia.registerSceneUITemplate('combo-notification', (id, onState) => {
    const template = document.getElementById('combo-notification-template');
    if (!template) {
      console.error('Could not find combo-notification-template');
      return document.createElement('div');
    }
    
    const clone = template.content.cloneNode(true);
    
    // Get all the elements we need to update
    const container = clone.querySelector('.combo-notification');
    const hitsElement = clone.querySelector('.combo-hits');
    const textElement = clone.querySelector('.combo-text');
    const bonusElement = clone.querySelector('.combo-bonus');
    
    onState(state => {
      if (state && container) {
        // Update the combo class based on hits
        const comboClass = state.hits >= 10 ? 'mega-combo' :
                          state.hits >= 7 ? 'ultra-combo' :
                          state.hits >= 5 ? 'super-combo' :
                          'combo';
        container.className = `combo-notification ${comboClass} active`;
        
        // Update the text content
        if (hitsElement) hitsElement.textContent = `${state.hits}x`;
        if (textElement) textElement.textContent = state.text;
        if (bonusElement) bonusElement.textContent = `+${state.bonus}%`;

        // Clear any existing timeout
        if (comboTimeout) {
          clearTimeout(comboTimeout);
        }

        // Set new timeout to remove active class
        comboTimeout = setTimeout(() => {
          container.classList.remove('active');
        }, 2000);
      }
    });
    
    return clone;
  });
</script>

<div class="scoreboard">
  <div class="scores-wrapper">
    <div class="scores-title">Round Score</div>
    <div id="scores-container">
      <!-- Scores will be added here dynamically -->
    </div>
  </div>
</div>

<!-- Game status elements -->
<div class="game-status">
  <div class="round-number"></div>
  <div class="round-timer"></div>
</div>

<div class="leaderboard">
  <div class="leaderboard-title">Leaderboard</div>
  <div id="leaderboard-container">
    <!-- Leaderboard entries will be added here dynamically -->
  </div>
</div>

<div class="projectile-counter">
  <div class="particles"></div>
  <div class="projectile-icon"></div>
  <div class="projectile-count">5</div>
</div>

<div class="crosshair"></div>

<!-- Add the combo notification element here -->
<div class="combo-notification">
  <div class="combo-counter">
    <div class="combo-hits"></div>
    <div class="combo-text"></div>
    <div class="combo-bonus"></div>
  </div>
</div>

<div class="settings-overlay"></div>
<div class="settings-menu">
  <div class="settings-title">Settings</div>
  
  <!-- Game Settings Section -->
  <div class="settings-section">
    <div class="settings-section-title">Game Settings</div>
    <div class="settings-option">
      <span class="settings-label">Background Music Volume</span>
      <div class="settings-value">
        <input type="range" min="0" max="100" value="10" id="bgm-volume-slider">
        <span id="bgm-volume-value">10</span>
      </div>
    </div>
  </div>

  <!-- Crosshair Settings Section -->
  <div class="settings-section">
    <div class="settings-section-title">Crosshair Settings</div>
    <div class="settings-option">
      <span class="settings-label">Crosshair Color</span>
      <div class="settings-value color-controls">
        <select id="color-preset" class="color-dropdown">
          <option value="">Custom</option>
          <option value="#ffff00">Yellow</option>
          <option value="#00ff7f">Green</option>
          <option value="#ff4d4d">Red</option>
          <option value="#66ffff">Cyan</option>
          <option value="#ff66ff">Magenta</option>
          <option value="#ffffff">White</option>
          <option value="#ffb366">Orange</option>
          <option value="#66ffb3">Mint</option>
          <option value="#b366ff">Purple</option>
          <option value="#ff66b3">Pink</option>
        </select>
        <input type="color" value="#ffff00" id="crosshair-color">
      </div>
    </div>

    <div class="settings-option">
      <span class="settings-label">Crosshair Elements</span>
      <div class="settings-value">
        <label class="checkbox-label">
          <input type="checkbox" id="show-ring" checked>
          Ring
        </label>
        <label class="checkbox-label">
          <input type="checkbox" id="show-dot" checked>
          Dot
        </label>
      </div>
    </div>

    <div class="settings-option">
      <span class="settings-label">Global Size</span>
      <div class="settings-value">
        <input type="range" min="12" max="48" value="24" id="global-size-slider">
        <span id="global-size-value">24px</span>
      </div>
    </div>

    <div class="settings-option">
      <span class="settings-label">Ring Size</span>
      <div class="settings-value">
        <input type="range" min="8" max="40" value="20" id="ring-size-slider">
        <span id="ring-size-value">20px</span>
      </div>
    </div>

    <div class="settings-option">
      <span class="settings-label">Dot Size</span>
      <div class="settings-value">
        <input type="range" min="2" max="12" value="4" id="dot-size-slider">
        <span id="dot-size-value">4px</span>
      </div>
    </div>
  </div>

  <!-- Resume Button -->
  <div class="settings-option">
    <button class="settings-button" id="resume-button">Resume Game</button>
  </div>
</div>

<!-- Help Menu -->
<div class="help-menu">
    <div class="help-header">
        <span class="help-title">GAME GUIDE</span>
        <span class="help-key">[H]</span>
    </div>
    <div class="help-content">
        <div class="help-section scoring">
            <h3>🎯 SCORING SYSTEM</h3>
            <div class="guide-items">
                <div class="guide-item">
                    <span class="guide-icon">🎯</span>
                    <span class="guide-text">DISTANCE = MORE POINTS</span>
                </div>
                <div class="guide-item">
                    <span class="guide-icon">⚡</span>
                    <span class="guide-text">FASTER BLOCKS = BIGGER SCORE</span>
                </div>
                <div class="guide-item">
                    <span class="guide-icon">⏱️</span>
                    <span class="guide-text">QUICK SHOTS COUNT</span>
                </div>
                <div class="guide-item">
                    <span class="guide-icon">🔥</span>
                    <span class="guide-text">CHAIN HITS FOR COMBOS</span>
                </div>
            </div>
        </div>
        <div class="help-section controls">
            <h3>🎮 CONTROLS</h3>
            <div class="control-item">
                <span class="key">[ESC]</span>
                <span class="action">Show Cursor</span>
            </div>
            <div class="control-item">
                <span class="key">[P]</span>
                <span class="action">Settings Menu</span>
            </div>
            <div class="control-item">
                <span class="key">[H]</span>
                <span class="action">Help Guide</span>
            </div>
        </div>
    </div>
</div>

<div class="hotkey-hints">
    <div class="hotkey-hint">[H] Game Guide</div>
    <div class="hotkey-hint">[P] Settings</div>
    <div class="hotkey-hint">[ESC] Show Cursor</div>
</div>

<script>
let projectileCount = 5;
let particles = [];

const scoresContainer = document.getElementById('scores-container');

// Create particle effect
function createParticle() {
  const particles = document.querySelector('.particles');
  const particle = document.createElement('div');
  particle.className = 'particle';
  
  // Random position
  const x = Math.random() * 100;
  const y = Math.random() * 100;
  
  particle.style.left = x + '%';
  particle.style.top = y + '%';
  
  // Random animation
  const animation = particle.animate([
    { transform: 'translate(0, 0)', opacity: 1 },
    { transform: `translate(${Math.random() * 50 - 25}px, ${Math.random() * 50 - 25}px)`, opacity: 0 }
  ], {
    duration: 1000 + Math.random() * 1000,
    easing: 'cubic-bezier(0,0,0.2,1)'
  });
  
  particles.appendChild(particle);
  animation.onfinish = () => particle.remove();
}

// Create particles periodically
setInterval(createParticle, 200);

// Listen for projectile count updates and shoot attempts from the game
hytopia.onData(data => {
  if (data.type === 'updateProjectileCount') {
    updateProjectileCount(data.count);
  } else if (data.type === 'attemptShootNoAmmo') {
    triggerShakeAnimation();
  } else if (data.type === 'updateScores') {
    updateScoreboard(data.scores);
  } else if (data.type === 'roundUpdate') {
    updateRoundInfo(data.data);
  } else if (data.type === 'roundEnd') {
    handleRoundEnd(data.data);
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
  } else if (data.type === 'waitingForPlayers') {
    showWaitingForPlayers(data.data);
  } else if (data.type === 'updateLeaderboard') {
    updateLeaderboard(data.leaderboard);
  } else if (data.type === 'showCombo') {
    showComboNotification(data.data);
  } else if (data.type === 'resetCombo') {
    const container = document.querySelector('.combo-notification');
    container.classList.remove('active');
    if (window.comboTimeout) {
      clearTimeout(window.comboTimeout);
    }
  } else if (data.type === 'gameEnd') {
    showGameEnd(data.data);
  } else if (data.type === 'showHitNotification') {
    showLocalHitNotification(data.data);
  } else if (data.type === 'showBlockDestroyedNotification') {
    showLocalBlockDestroyedNotification(data.data);
  }
});

function triggerShakeAnimation() {
  const counterElement = document.querySelector('.projectile-counter');
  counterElement.classList.remove('shake');
  void counterElement.offsetWidth; // Trigger reflow
  counterElement.classList.add('shake');
  
  // Remove the class after animation completes
  setTimeout(() => {
    counterElement.classList.remove('shake');
  }, 820); // Match the animation duration
}

function updateProjectileCount(count) {
  const countElement = document.querySelector('.projectile-count');
  const counterElement = document.querySelector('.projectile-counter');
  const iconElement = document.querySelector('.projectile-icon');
  
  // Add pulse animation
  countElement.classList.remove('count-change');
  void countElement.offsetWidth; // Trigger reflow
  countElement.classList.add('count-change');
  
  // Update count with transition
  countElement.textContent = count;
  
  // Visual feedback for low ammo
  if (count <= 2) {
    counterElement.classList.add('low');
    iconElement.style.background = 'radial-gradient(circle at 30% 30%, #ff6b6b, #ff0000)';
    iconElement.style.boxShadow = '0 0 15px #ff0000';
  } else {
    counterElement.classList.remove('low');
    iconElement.style.background = 'radial-gradient(circle at 30% 30%, #6ae675, #4CAF50)';
    iconElement.style.boxShadow = '0 0 15px #4CAF50';
  }
  
  projectileCount = count;
}

function showWaitingForPlayers(data) {
  const gameStatus = document.querySelector('.game-status');
  const roundNumber = document.querySelector('.round-number');
  const roundTimer = document.querySelector('.round-timer');
  
  // Update game status to show waiting message
  roundNumber.textContent = 'Waiting for Players';
  roundTimer.textContent = `${data.current}/${data.required}`;
  
  // Add waiting style
  gameStatus.classList.add('waiting');
}

let lastTimeRemaining = 0;
let timerInterval = null;
let timerEndTime = 0;

function startLocalTimer(initialTimeMs) {
  // Clear any existing timer
  if (timerInterval) {
    clearInterval(timerInterval);
  }
  
  // Set the end time based on current time plus duration
  timerEndTime = Date.now() + initialTimeMs;
  lastTimeRemaining = initialTimeMs;
  
  function updateTimer() {
    const now = Date.now();
    const remaining = Math.max(0, timerEndTime - now);
    
    // Update lastTimeRemaining for potential server sync
    lastTimeRemaining = remaining;
    
    // Calculate time components, using Math.floor instead of Math.ceil
    const timeRemaining = Math.floor(remaining / 1000);  // Changed from Math.ceil to Math.floor
    const minutes = Math.floor(timeRemaining / 60);
    const seconds = timeRemaining % 60;
    const formattedTime = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
    
    const roundTimer = document.querySelector('.round-timer');
    if (roundTimer) {
      roundTimer.textContent = formattedTime;
      
      // Update visual feedback
      roundTimer.classList.remove('warning', 'danger');
      if (timeRemaining <= 10) {
        roundTimer.classList.add('danger');
      } else if (timeRemaining <= 30) {
        roundTimer.classList.add('warning');
      }
    }
    
    // Only clear interval if we've actually reached zero
    if (remaining <= 0) {
      clearInterval(timerInterval);
      timerInterval = null;
      
      // Ensure we show 0:00 at the end
      if (roundTimer) {
        roundTimer.textContent = 'Time: 0:00';
      }
      
      // Send a message to the game that time is up
      if (typeof hytopia !== 'undefined') {
        hytopia.sendData({ type: 'timeUp' });
      }
    }
  }
  
  // Initial update
  updateTimer();
  
  // Start interval for updates
  timerInterval = setInterval(updateTimer, 100); // Update round timer frequently for smoother display
}

function updateRoundInfo(roundData) {
  const gameStatus = document.querySelector('.game-status');
  const roundNumber = document.querySelector('.round-number');
  
  // Remove waiting style
  gameStatus.classList.remove('waiting');
  
  // Update round info
  roundNumber.textContent = `Round ${roundData.round}`;
  
  // Clear any active combo notification
  const comboNotification = document.querySelector('.combo-notification');
  if (comboNotification) {
    comboNotification.classList.remove('active');
    if (window.comboTimeout) {
      clearTimeout(window.comboTimeout);
    }
  }
  
  // Start or update timer with the full duration
  if (roundData.timeRemaining > 0) {
    startLocalTimer(roundData.timeRemaining);
  }
}

function handleRoundEnd(data) {
  // Only show results if it's not the final round
  if (data.round < data.totalRounds) {
    // Create and show round standings dialog
    if (data.placements && data.placements.length > 0) {
      // Create round end dialog
      const roundEndDialog = document.createElement('div');
      roundEndDialog.className = 'round-end';
      
      // Create title
      const title = document.createElement('div');
      title.className = 'round-end-title';
      title.textContent = `Round ${data.round} Results`;
      roundEndDialog.appendChild(title);
      
      // Add placements
      const placementsContainer = document.createElement('div');
      placementsContainer.className = 'round-end-placements';
      
      data.placements.forEach((placement, index) => {
        const placementDiv = document.createElement('div');
        const isCurrentPlayer = placement.playerId === data.currentPlayerId;
        placementDiv.className = `round-end-placement ${index === 0 ? 'first' : ''} ${isCurrentPlayer ? 'current-player' : ''}`;
        
        // Get player color
        const playerColor = placement.playerColor || '#FFFFFF';
        
        // Highlight current player's entry
        if (isCurrentPlayer) {
          placementDiv.style.borderColor = playerColor;
          placementDiv.style.boxShadow = `0 0 8px ${playerColor}`;
        }
        
        // Add content with player identifier
        placementDiv.innerHTML = `
          <div class="player-info">
            <span class="placement-rank" style="color: ${playerColor}">#${index + 1}</span>
            <span class="player-avatar" style="background-color: ${playerColor}"></span>
            <span class="player-name" style="color: ${playerColor}">Player ${placement.playerNumber}</span>
            ${isCurrentPlayer ? '<span class="player-you-tag">YOU</span>' : ''}
          </div>
          <span class="placement-points" style="color: ${playerColor}">+${placement.points} pts</span>
        `;
        
        placementsContainer.appendChild(placementDiv);
      });
      
      roundEndDialog.appendChild(placementsContainer);
      
      // Add timer for next round
      const timerDiv = document.createElement('div');
      timerDiv.className = 'next-round-timer';
      timerDiv.textContent = `Next round starting in ${Math.ceil(data.nextRoundIn / 1000)} seconds...`;
      roundEndDialog.appendChild(timerDiv);
      
      // Add to body
      document.body.appendChild(roundEndDialog);
      
      // Remove dialog just before the next round starts
      setTimeout(() => {
        roundEndDialog.remove();
      }, data.nextRoundIn - 200); // Remove 200ms before next round starts
      
      // Update timer countdown
      let secondsLeft = Math.ceil(data.nextRoundIn / 1000);
      const timerInterval = setInterval(() => {
        secondsLeft--;
        if (secondsLeft > 0) {
          timerDiv.textContent = `Next round starting in ${secondsLeft} seconds...`;
        } else {
          clearInterval(timerInterval);
        }
      }, 1000);
    }

  }

  // Reset scores just before the next round starts
  setTimeout(() => {
    // Reset scores for next round
    const scores = document.querySelectorAll('.player-score');
    scores.forEach(score => {
      const totalScore = score.querySelector('.score-value');
      const lastScore = score.querySelector('.round-score');
      if (totalScore) {
        totalScore.textContent = '0';
      }
      if (lastScore) {
        lastScore.textContent = '';  // Hide completely instead of showing +0
      }
    });
  }, data.nextRoundIn - 100); // Reset 100ms before next round starts
}

function updateScoreboard(scores) {
  scoresContainer.innerHTML = '';
  const currentPlayerId = scores.currentPlayerId;
  
  // Sort scores to put current player first, then by player number
  const sortedScores = [...scores];
  sortedScores.sort((a, b) => {
    // Always put current player first
    if (a.playerId === currentPlayerId) return -1;
    if (b.playerId === currentPlayerId) return 1;
    // Then sort by player number
    return a.playerNumber - b.playerNumber;
  });
  
  sortedScores.forEach((score) => {
    const playerDiv = document.createElement('div');
    const isCurrentPlayer = score.playerId === currentPlayerId;
    playerDiv.className = `player-score ${isCurrentPlayer ? 'current-player' : ''}`;
    
    // Use leaderboardPoints for game end, otherwise use round scoring
    const points = score.isGameEnd ? score.leaderboardPoints : score.totalPoints;
    const lastScore = Number(score.lastScore || 0);
    
    // Player icon/avatar with player color
    const playerColor = score.playerColor || '#FFFFFF';
    
    // Highlight current player's score with a border
    if (isCurrentPlayer) {
      playerDiv.style.borderColor = playerColor;
      playerDiv.style.boxShadow = `0 0 8px ${playerColor}`;
    }
    
    // Build score display - total score and last earned score
    playerDiv.innerHTML = `
      <div class="player-indicator">
        <span class="player-avatar" style="background-color: ${playerColor}"></span>
        <span class="player-label" style="color: ${playerColor}">Player ${score.playerNumber}</span>
        ${isCurrentPlayer ? '<span class="player-you-tag">YOU</span>' : ''}
      </div>
      <div class="score-info">
        <span class="score-value" style="color: ${playerColor}">${points}</span>
        ${!score.isGameEnd && lastScore > 0 ? `<span class="round-score" style="color: ${playerColor}">(+${lastScore})</span>` : ''}
      </div>
    `;
    scoresContainer.appendChild(playerDiv);
  });
}

function updateLeaderboard(data) {
  const container = document.getElementById('leaderboard-container');
  container.innerHTML = '';
  
  const leaderboardData = data.leaderboard || data;
  const currentPlayerId = data.currentPlayerId;
  
  leaderboardData.forEach((entry, index) => {
    const isCurrentPlayer = entry.playerId === currentPlayerId;
    const entryDiv = document.createElement('div');
    entryDiv.className = `leaderboard-entry ${entry.isLeading ? 'winner' : ''} ${isCurrentPlayer ? 'current-player' : ''}`;
    
    // Get player color
    const playerColor = entry.playerColor || '#FFFFFF';
    
    // Highlight current player's entry with a border
    if (isCurrentPlayer) {
      entryDiv.style.borderColor = playerColor;
      entryDiv.style.boxShadow = `0 0 8px ${playerColor}`;
    }
    
    // Create rank change indicator based on the rankChange field
    let rankChangeIndicator = '';
    if (entry.rankChange === 'up') {
      rankChangeIndicator = `<span class="rank-change rank-up">▲</span>`;
    } else if (entry.rankChange === 'down') {
      rankChangeIndicator = `<span class="rank-change rank-down">▼</span>`;
    } else if (entry.rankChange === 'same') {
      rankChangeIndicator = `<span class="rank-change rank-same">●</span>`;
    } else if (entry.rankChange === 'new') {
      rankChangeIndicator = `<span class="rank-change rank-new">★</span>`;
    }
    
    // Update the display to show placement points with player color
    entryDiv.innerHTML = `
      <div class="player-name">
        <span class="player-rank" style="color: ${playerColor}">#${entry.currentRank}</span>
        ${rankChangeIndicator}
        <div class="player-info">
          <span class="player-avatar" style="background-color: ${playerColor}"></span>
          <span>Player ${entry.playerNumber}</span>
          ${isCurrentPlayer ? '<span class="player-you-tag">YOU</span>' : ''}
        </div>
      </div>
      <span class="player-wins" style="color: ${playerColor}">${entry.points} pts</span>
    `;
    
    container.appendChild(entryDiv);
  });
}

// Settings menu functionality
let isSettingsOpen = false;

function toggleSettings(show) {
  const menu = document.querySelector('.settings-menu');
  const overlay = document.querySelector('.settings-overlay');
  isSettingsOpen = show;
  
  if (show) {
    menu.classList.add('visible');
    overlay.classList.add('visible');
    
    // Request current settings when opening menu
    hytopia.sendData({ 
      type: 'requestSettings'
    });
  } else {
    menu.classList.remove('visible');
    overlay.classList.remove('visible');
  }
}

// Listen for Escape key - work with cursor state
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    // If settings are open, close them
    if (isSettingsOpen) {
      toggleSettings(false);
      e.preventDefault(); // Prevent the default escape behavior
    } else {
      // If cursor becomes visible (handled by game), show settings
      setTimeout(() => {
        const cursorStyle = window.getComputedStyle(document.body).cursor;
        if (cursorStyle === 'default' || cursorStyle === 'auto') {
          toggleSettings(true);
        }
      }, 50); // Small delay to ensure cursor state has updated
    }
  }
});

// Multiple hotkeys for settings
document.addEventListener('keydown', (e) => {
  if (e.key === 'Tab' || e.key.toLowerCase() === 'p') { // Added 'P' key
    e.preventDefault(); // Prevent default behavior
    const cursorStyle = window.getComputedStyle(document.body).cursor;
    if (cursorStyle === 'default' || cursorStyle === 'auto') {
      toggleSettings(!isSettingsOpen);
    }
  }
});

// Resume button - close settings and hide cursor
document.getElementById('resume-button').addEventListener('click', () => {
  toggleSettings(false);
  hytopia.sendData({ type: 'hideCursor' }); // Tell game to hide cursor again
});

// Handle settings changes
document.getElementById('sensitivity-slider')?.remove();

// Background music volume handler with debounce
let volumeTimeout;
const volumeSlider = document.getElementById('bgm-volume-slider');
const volumeValue = document.getElementById('bgm-volume-value');

// Initialize volume UI with default value
volumeSlider.value = '10'; // Default value (10%)
volumeValue.textContent = '10';

volumeSlider.addEventListener('input', (e) => {
  const value = e.target.value;
  volumeValue.textContent = value;
  
  // Clear any pending timeout
  if (volumeTimeout) {
    clearTimeout(volumeTimeout);
  }
  
  // Set a new timeout to update the volume
  volumeTimeout = setTimeout(() => {
    // Ensure we send exactly 0 when slider is at minimum
    const volumeValue = Number(value);
    hytopia.sendData({ 
      type: 'updateSettings',
      setting: 'bgmVolume',
      value: volumeValue === 0 ? 0 : volumeValue
    });
  }, 50); // Small delay to prevent too many updates
});

// Listen for settings updates from the game
hytopia.onData(data => {
  if (data.type === 'settingsUpdate' && data.settings) {
    // Update volume slider
    if (data.settings.bgmVolume !== undefined) {
      const uiValue = Math.round(data.settings.bgmVolume * 100);
      volumeSlider.value = String(uiValue);
      volumeValue.textContent = String(uiValue);
    }
  }
});

// Function to update crosshair color
function updateCrosshairColor(color) {
  const root = document.documentElement;
  const colorPicker = document.getElementById('crosshair-color');
  
  // Update color picker value
  colorPicker.value = color;
  
  // Convert hex to rgba for main color
  const r = parseInt(color.slice(1,3), 16);
  const g = parseInt(color.slice(3,5), 16);
  const b = parseInt(color.slice(5,7), 16);
  
  // Set the CSS variables
  root.style.setProperty('--crosshair-color', `rgba(${r}, ${g}, ${b}, 0.8)`);
  root.style.setProperty('--crosshair-glow', color);
  
  // Send to game
  hytopia.sendData({ 
    type: 'updateSettings',
    setting: 'crosshairColor',
    value: color
  });
}

// Color picker handler
document.getElementById('crosshair-color').addEventListener('input', (e) => {
  updateCrosshairColor(e.target.value);
  // Reset dropdown to "Custom" when using color picker
  document.getElementById('color-preset').value = '';
});

// Dropdown handler
document.getElementById('color-preset').addEventListener('change', (e) => {
  if (e.target.value) {
    updateCrosshairColor(e.target.value);
  }
});

// Function to update crosshair sizes
function updateCrosshairSizes() {
  const root = document.documentElement;
  const globalSize = document.getElementById('global-size-slider').value;
  const ringSize = document.getElementById('ring-size-slider').value;
  const dotSize = document.getElementById('dot-size-slider').value;
  
  root.style.setProperty('--crosshair-size', `${globalSize}px`);
  root.style.setProperty('--ring-size', `${ringSize}px`);
  root.style.setProperty('--dot-size', `${dotSize}px`);
  
  // Update display values
  document.getElementById('global-size-value').textContent = `${globalSize}px`;
  document.getElementById('ring-size-value').textContent = `${ringSize}px`;
  document.getElementById('dot-size-value').textContent = `${dotSize}px`;
  
  // Send to game
  hytopia.sendData({
    type: 'updateSettings',
    setting: 'crosshairSizes',
    value: { globalSize, ringSize, dotSize }
  });
}

// Function to update crosshair visibility
function updateCrosshairVisibility() {
  const root = document.documentElement;
  const showRing = document.getElementById('show-ring').checked;
  const showDot = document.getElementById('show-dot').checked;
  
  root.style.setProperty('--show-ring', showRing ? 'block' : 'none');
  root.style.setProperty('--show-dot', showDot ? 'block' : 'none');
  
  // Send to game
  hytopia.sendData({
    type: 'updateSettings',
    setting: 'crosshairVisibility',
    value: { showRing, showDot }
  });
}

// Size slider handlers
document.getElementById('global-size-slider').addEventListener('input', updateCrosshairSizes);
document.getElementById('ring-size-slider').addEventListener('input', updateCrosshairSizes);
document.getElementById('dot-size-slider').addEventListener('input', updateCrosshairSizes);

// Visibility checkbox handlers
document.getElementById('show-ring').addEventListener('change', updateCrosshairVisibility);
document.getElementById('show-dot').addEventListener('change', updateCrosshairVisibility);

// Add this to your existing script section
let isHelpOpen = false;

document.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'h') {
        e.preventDefault();
        toggleHelp(!isHelpOpen);
    }
});

function toggleHelp(show) {
    const menu = document.querySelector('.help-menu');
    
    if (show) {
        menu.classList.remove('closing');
        menu.classList.add('visible');
        isHelpOpen = true;
    } else {
        if (!menu.classList.contains('visible')) return;
        
        menu.classList.add('closing');
        isHelpOpen = false;
        
        // Wait for animation to complete before hiding
        setTimeout(() => {
            if (!isHelpOpen) { // Check again in case it was reopened
                menu.classList.remove('visible');
                menu.classList.remove('closing');
            }
        }, 300); // Match the animation duration
    }
}



// Add this to your existing script
function updateHotkeysVisibility(show) {
    const hints = document.querySelector('.hotkey-hints');
    if (hints) {
        hints.style.display = show ? 'flex' : 'none';
    }
}

// Hide hotkeys when menus are open
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' || e.key.toLowerCase() === 'p' || e.key.toLowerCase() === 'h') {
        updateHotkeysVisibility(false);
    }
});

// Show hotkeys when menus are closed
function onMenuClose() {
    updateHotkeysVisibility(true);
}

// Add this to your existing script
let comboTimeout = null;

function showComboNotification(data) {
  const container = document.querySelector('.combo-notification');
  const hitsElement = container.querySelector('.combo-hits');
  const textElement = container.querySelector('.combo-text');
  const bonusElement = container.querySelector('.combo-bonus');
  
  // Update the combo class based on hits
  const comboClass = data.hits >= 10 ? 'mega-combo' :
                    data.hits >= 7 ? 'ultra-combo' :
                    data.hits >= 5 ? 'super-combo' :
                    'combo';
  
  container.className = `combo-notification ${comboClass} active`;
  
  // Update the text content
  hitsElement.textContent = `${data.hits}x`;
  textElement.textContent = data.text;
  bonusElement.textContent = `+${data.bonus}%`;
  
  // Clear any existing timeout
  if (comboTimeout) {
    clearTimeout(comboTimeout);
  }
  
  // Hide after 2 seconds
  comboTimeout = setTimeout(() => {
    container.classList.remove('active');
  }, 2000);
}

// Add help toggle to settings menu
document.querySelector('.settings-menu').addEventListener('click', () => {
    toggleHelp(false); // Close help when opening settings
});

// Add this instead
document.addEventListener('DOMContentLoaded', () => {
    const settingsMenu = document.querySelector('.settings-menu');
    if (settingsMenu) {
        settingsMenu.addEventListener('click', () => {
            toggleHelp(false); // Close help when opening settings
        });
    }
});

function showGameEnd(data) {
    const overlay = document.querySelector('.game-end-overlay');
    const winnerAnnouncement = document.querySelector('.winner-announcement');
    const standingsContainer = document.querySelector('.final-standings');
    const nextGameTimer = document.querySelector('.next-game-timer');
    
    // Get winner details
    const winnerPlayerNumber = data.winner.playerNumber || 1;
    const winnerColor = data.winner.playerColor || '#FFD700';
    
    // Style winner announcement with winner's color
    winnerAnnouncement.innerHTML = `
        <span class="player-avatar large" style="background-color: ${winnerColor}"></span>
        <span style="color: ${winnerColor}">Player ${winnerPlayerNumber}</span> Wins!
    `;
    winnerAnnouncement.style.textShadow = `0 0 15px ${winnerColor}`;
    
    // Show standings
    standingsContainer.innerHTML = '';
    data.standings.forEach((standing, index) => {
        const isCurrentPlayer = standing.playerId === data.currentPlayerId;
        const entry = document.createElement('div');
        entry.className = `standing-entry ${index === 0 ? 'winner' : ''} ${isCurrentPlayer ? 'current-player' : ''}`;
        
        // Use player color for styling
        const playerColor = standing.playerColor || '#FFFFFF';
        
        // Highlight current player's entry
        if (isCurrentPlayer) {
            entry.style.borderColor = playerColor;
            entry.style.boxShadow = `0 0 8px ${playerColor}`;
        }
        
        entry.innerHTML = `
            <div class="player-info standing-player-info">
                <span class="standing-position" style="color: ${playerColor}">#${index + 1}</span>
                <span class="player-avatar" style="background-color: ${playerColor}"></span>
                <span class="player-name" style="color: ${playerColor}">Player ${standing.playerNumber}</span>
                ${isCurrentPlayer ? '<span class="player-you-tag">YOU</span>' : ''}
            </div>
            <div class="standing-stats">
                <div class="standing-stat">
                    <div class="stat-label">POINTS</div>
                    <div class="stat-value" style="color: ${playerColor}">${standing.placementPoints}</div>
                </div>
                <div class="standing-stat">
                    <div class="stat-label">WINS</div>
                    <div class="stat-value" style="color: ${playerColor}">${standing.wins || 0}</div>
                </div>
                <div class="standing-stat">
                    <div class="stat-label">SCORE</div>
                    <div class="stat-value" style="color: ${playerColor}">${standing.totalScore || 0}</div>
                </div>
            </div>
        `;
        
        standingsContainer.appendChild(entry);
    });
    
    // Show next game timer
    let timeLeft = Math.floor(data.nextGameIn / 1000);
    nextGameTimer.textContent = `Next Game in ${timeLeft}s`;
    
    const countdownInterval = setInterval(() => {
        timeLeft--;
        nextGameTimer.textContent = `Next Game in ${timeLeft}s`;
        
        if (timeLeft <= 0) {
            clearInterval(countdownInterval);
            overlay.classList.remove('visible');
        }
    }, 1000);
    
    // Show overlay
    overlay.classList.add('visible');
    
    // Hide overlay after nextGameIn duration
    setTimeout(() => {
        overlay.classList.remove('visible');
    }, data.nextGameIn);
}

// Add these new functions to handle local notifications
function showLocalHitNotification(data) {
  const container = document.createElement('div');
  container.className = 'hit-notification';
  container.style.left = '50%';  // Center horizontally
  container.style.top = '50%';   // Center vertically
  
  const scoreElement = document.createElement('span');
  scoreElement.className = 'score';
  scoreElement.textContent = `+${Math.round(data.score)}`;
  
  container.appendChild(scoreElement);
  document.body.appendChild(container);
  
  // Remove after animation
  setTimeout(() => {
    container.remove();
  }, 1000);
}

function showLocalBlockDestroyedNotification(data) {
  const container = document.createElement('div');
  container.className = 'block-destroyed-notification';
  container.style.left = '50%';  // Center horizontally
  container.style.top = '50%';   // Center vertically
  
  if (data.verticalOffset) {
    container.style.transform = `translate(-50%, -50%) translateY(-${data.verticalOffset}px)`;
  }
  
  const scoreElement = document.createElement('div');
  scoreElement.className = 'score';
  scoreElement.textContent = `+${data.score}`;
  
  if (data.style) {
    scoreElement.style.cssText = data.style;
  }
  
  container.appendChild(scoreElement);
  document.body.appendChild(container);
  
  // Remove after animation
  setTimeout(() => {
    container.remove();
  }, data.duration + 100);
}
</script>

<div class="game-end-overlay">
    <div class="game-end-content">
        <div class="game-end-title">GAME OVER</div>
        <div class="winner-announcement"></div>
        <div class="final-standings"></div>
        <div class="next-game-timer"></div>
    </div>
</div>

</body>
</html>

================
File: assets/ui/README.md
================
# Projectile Counter UI

A modern, animated UI component that displays the player's projectile count with visual feedback and animations.

## Features

### Visual Elements
- Modern glassmorphism design with blur effects and gradient overlays
- Dynamic projectile icon with glow effects
- Ambient particle system in the background
- Responsive counter with smooth transitions
- Color-coded feedback for low ammo states

### Animations
1. **Count Change Animation**
   - Smooth pulse effect when the count updates
   - Scale transform with ease-out timing
   - Duration: 0.5s

2. **Low Ammo State**
   - Red gradient background
   - Red glow effect on the projectile icon
   - Color transition with 0.3s ease

3. **No Ammo Feedback**
   - Dynamic shake animation when attempting to shoot with no ammo
   - Combined translation and rotation effects
   - 0.5s duration with custom easing
   - Triggers only on shoot attempt, not continuously

4. **Particle System**
   - Continuous ambient particles in the background
   - Random movement patterns
   - Fade-out effect
   - Creates new particles every 200ms

## Implementation Details

### Modified Files

1. `assets/ui/index.html`
   - Main UI implementation
   - CSS styles and animations
   - Event handling and DOM manipulation
   - Particle system implementation

2. `src/managers/player-projectile-manager.ts`
   - Added UI event triggering for no-ammo attempts
   - Modified `handleProjectileInput` to accept player object
   - Integrated UI feedback with game logic

3. `index.ts`
   - Updated projectile manager initialization
   - Added player object to handleProjectileInput calls
   - Configured UI update events

### Communication Flow

1. Game State → UI Updates
   - `updateProjectileCount` event: Updates counter value
   - `attemptShootNoAmmo` event: Triggers shake animation

2. Visual Feedback States
   - Normal state: Green projectile icon
   - Low ammo (≤2): Red warning state
   - No ammo + shoot attempt: Shake animation

### CSS Animations

```css
// Shake Animation
@keyframes shake {
  0%, 100% { transform: translate3d(0, 0, 0) rotate(0deg); }
  10%, 90% { transform: translate3d(-2px, 1px, 0) rotate(-1deg); }
  20%, 80% { transform: translate3d(3px, -1px, 0) rotate(1deg); }
  30%, 50%, 70% { transform: translate3d(-4px, 2px, 0) rotate(-2deg); }
  40%, 60% { transform: translate3d(4px, -2px, 0) rotate(2deg); }
}

// Pulse Animation
@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.2); }
  100% { transform: scale(1); }
}
```

## Performance Considerations

- Used `transform` and `opacity` for animations to leverage GPU acceleration
- Implemented `backface-visibility: hidden` and `perspective: 1000px` for smoother animations
- Particle system auto-removes elements after animation
- Efficient DOM updates with class toggling
- Debounced animations with proper cleanup

## Future Improvements

Potential enhancements that could be added:
- Sound effects for low ammo and no-ammo states
- Customizable color schemes
- Additional animation variations
- Projectile type indicators
- Ammo pickup animations

## Important Points

1. **File Structure**
   - UI files must be placed in the `assets/ui` directory
   - Main entry point must be named `index.html`
   - Do NOT include `<!DOCTYPE html>`, `<html>`, `<head>`, or `<body>` tags

2. **Loading the UI**
   ```typescript
   // Must load the UI before sending any data
   player.ui.load('ui/index.html');
   ```

3. **Server-to-UI Communication**
   ```typescript
   // Send data from server to UI
   player.ui.sendData({
     type: 'updateProjectileCount',
     count: number
   });
   ```

4. **UI-to-Server Communication**
   ```javascript
   // Receive data in UI from server
   hytopia.onData(data => {
     if (data.type === 'updateProjectileCount') {
       // Handle the update
     }
   });
   ```

### Message Format

The UI expects messages in the following format:
```typescript
{
  type: 'updateProjectileCount',
  count: number  // The number of projectiles remaining
}
```

### CSS Considerations

- Use `position: absolute` for overlay positioning
- Avoid using viewport units (vh/vw) as they may not work as expected
- Use rgba/transparency for better visual integration
- Consider using `backdrop-filter` for blur effects (when supported)

### Best Practices

1. Always load the UI before sending any data to it
2. Use consistent message types between server and UI
3. Keep the UI file lightweight and focused
4. Handle edge cases (e.g., negative counts, missing data)
5. Use clear class names to avoid conflicts
6. Implement smooth transitions for better UX

### Common Issues

1. **UI Not Showing**
   - Ensure UI is loaded before sending data
   - Check for HTML tag restrictions
   - Verify file path is correct relative to assets directory

2. **Updates Not Working**
   - Verify message type matches exactly
   - Check that selectors match HTML structure
   - Ensure DOM is ready before attaching listeners

3. **Visual Glitches**
   - Test with different resolutions
   - Avoid fixed pixel values for critical measurements
   - Use flexbox/grid for better layout stability

## Example Usage

```typescript
// Server-side (index.ts)
world.onPlayerJoin = player => {
  // Load UI first
  player.ui.load('ui/index.html');
  
  // Then send initial data
  player.ui.sendData({
    type: 'updateProjectileCount',
    count: initialCount
  });
};
```

================
File: assets/ui/styles/combo-notification.css
================
:root {
  --blood-red: #ff1717;
  --dark-red: #8b0000;
  --glow-red: #ff000d;
  --matrix-green: #00ff41;
  --terminal-green: #39ff14;
  --matrix-dark: #0d0208;
}

.combo-notification {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  pointer-events: none;
  animation: comboSlideIn 0.3s ease-out;
  font-family: 'Press Start 2P', monospace;
  text-align: center;
  z-index: 1000;
}

.combo-counter {
  background: rgba(0, 0, 0, 0.85);
  padding: 15px 25px;
  border-radius: 12px;
  border: 2px solid #ff1717;
  box-shadow: 0 0 20px rgba(255, 0, 0, 0.3),
              inset 0 0 15px rgba(255, 0, 0, 0.2);
  animation: glowPulse 1.5s infinite;
  transform: scale(1.5);
}

.combo-hits {
  font-size: 48px;
  font-weight: bold;
  color: #ff1717;
  text-shadow: 0 0 15px #ff000d;
  display: block;
  margin-bottom: 8px;
  animation: scalePulse 0.5s infinite;
}

.combo-text {
  font-size: 32px;
  color: #00ff41;
  text-shadow: 0 0 12px #39ff14;
  display: block;
  margin-bottom: 8px;
  letter-spacing: 2px;
}

.combo-bonus {
  font-size: 28px;
  color: #ffff00;
  text-shadow: 0 0 12px rgba(255, 255, 0, 0.8);
  display: block;
  letter-spacing: 1px;
}

/* Combo tiers with different colors */
.combo .combo-hits { color: #00ff00; }
.super-combo .combo-hits { color: #00ffff; }
.ultra-combo .combo-hits { 
  color: #ff00ff;
  animation: pulse 0.5s infinite;
}
.mega-combo .combo-hits { 
  color: #ff0000;
  animation: pulse 0.5s infinite;
}

/* Animations */
@keyframes comboSlideIn {
  from {
    transform: translateX(-50%) translateY(-50px) scale(1.5);
    opacity: 0;
  }
  to {
    transform: translateX(-50%) translateY(0) scale(1.5);
    opacity: 1;
  }
}

@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}

@keyframes scalePulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}

@keyframes glowPulse {
  0% { 
    box-shadow: 0 0 20px rgba(255, 0, 0, 0.5), 
                inset 0 0 15px rgba(255, 0, 0, 0.4);
  }
  50% { 
    box-shadow: 0 0 30px rgba(255, 0, 0, 0.7), 
                inset 0 0 25px rgba(255, 0, 0, 0.6);
  }
  100% { 
    box-shadow: 0 0 20px rgba(255, 0, 0, 0.5), 
                inset 0 0 15px rgba(255, 0, 0, 0.4);
  }
}

.fade-out {
  animation: fadeOut 0.5s forwards;
}

@keyframes fadeOut {
  to {
    opacity: 0;
    transform: translateX(-50%) translateY(-20px) scale(1.5);
  }
}

================
File: assets/ui/templates/combo-notification.html
================
<div class="combo-notification">
  <div class="combo-counter {{hits >= 10 ? 'mega-combo' : hits >= 7 ? 'ultra-combo' : hits >= 5 ? 'super-combo' : 'combo'}}">
    <span class="combo-hits">{{hits}}x</span>
    <span class="combo-text">{{text}}</span>
    <span class="combo-bonus">+{{bonus}}%</span>
  </div>
</div>

================
File: CLAUDE.md
================
# Astro Breaker Development Guide

## Commands
- **Test**: `npm test` (all tests)
- **Single test**: `npm test -- -t "test name pattern" --config=jest.config.js` 
- **TypeCheck**: `npx tsc --noEmit`
- **Build**: `npx tsc`

## Code Style
- **Naming**: camelCase for variables/functions, PascalCase for classes/interfaces
- **Imports**: Group imports by source (external libraries first, then local modules)
- **Interfaces**: Define interfaces for complex object structures
- **Error Handling**: Use try/catch for critical operations with console.error for logging
- **Entity Ticking**: Use event system - register with `entity.on(EntityEvent.TICK, ({ tickDeltaMs }) => {...})`
- **File Organization**: 
  - TypeScript source files in src/
  - Tests in src/__tests__/
  - Manager classes in src/managers/
- **Project Structure**: Follows component-based architecture with organized managers
- **Documentation**: README files in directories explain component purposes

================
File: generate_cone.py
================
import json
import math
import random
import os

def find_platforms(blocks):
    """Find distinct platforms in the map by grouping connected blocks at y=0"""
    platforms = []
    visited = set()
    
    def get_neighbors(x, z):
        return [(x+1,z), (x-1,z), (x,z+1), (x,z-1)]
    
    def flood_fill(start_x, start_z):
        platform = set()
        queue = [(start_x, start_z)]
        
        while queue:
            x, z = queue.pop(0)
            if (x, z) in visited:
                continue
                
            visited.add((x, z))
            platform.add((x, z))
            
            for nx, nz in get_neighbors(x, z):
                key = f"{nx},0,{nz}"
                if key in blocks and blocks[key] == 24 and (nx, nz) not in visited:
                    queue.append((nx, nz))
        
        return platform

    # Find all platforms using flood fill
    for coord in blocks:
        if blocks[coord] != 24:  # Only consider mossy cobblestone
            continue
        x, _, z = map(int, coord.split(','))
        if (x, z) not in visited:
            platform = flood_fill(x, z)
            if len(platform) > 50:  # Only consider large platforms
                platforms.append(platform)
    
    return platforms

def create_organic_platform_layer(center_x, center_z, radius):
    """Create an organic circular pattern for the platform's first layer"""
    layer_blocks = {}
    max_radius = radius + 2  # Slightly larger to create edge details
    
    # Create noise offsets for organic feel
    angles = [random.uniform(0, 2 * math.pi) for _ in range(8)]
    offsets = [random.uniform(0.8, 1.2) for _ in range(8)]
    
    def get_radius_offset(angle):
        # Interpolate between noise points for smooth variation
        total = 0
        weights = 0
        for i, (noise_angle, offset) in enumerate(zip(angles, offsets)):
            weight = 1 / (1 + abs(math.sin(angle - noise_angle)))
            total += offset * weight
            weights += weight
        return total / weights if weights > 0 else 1
    
    for x in range(-int(max_radius), int(max_radius) + 1):
        for z in range(-int(max_radius), int(max_radius) + 1):
            distance = math.sqrt(x*x + z*z)
            angle = math.atan2(z, x)
            radius_offset = get_radius_offset(angle)
            
            if distance <= radius * radius_offset:
                # Edge pattern
                if radius - 2 <= distance <= radius * radius_offset:
                    # Create a more detailed edge pattern
                    noise = math.sin(angle * 4) * 0.5 + math.cos(distance * 0.8) * 0.5
                    if noise > 0:
                        block_id = 37 if random.random() < 0.7 else 4  # Mix of stone and cobblestone
                    else:
                        block_id = 24  # Mossy cobblestone
                else:
                    # Interior is mostly plain with subtle variations
                    if random.random() < 0.9:
                        block_id = 24  # Mostly mossy cobblestone
                    else:
                        block_id = 37 if random.random() < 0.7 else 4
                
                key = f"{x + center_x},0,{z + center_z}"
                layer_blocks[key] = block_id
    
    return layer_blocks

def generate_hanging_cone(center_x, center_z, start_y=0, depth=30):
    print(f"Generating cone structure at ({center_x}, {center_z})...")
    cone_blocks = {}
    max_radius = 15  # Reduced radius for each platform
    
    # Create the decorative platform layer first
    platform_blocks = create_organic_platform_layer(center_x, center_z, max_radius)
    cone_blocks.update(platform_blocks)
    
    # Generate the hanging cone
    for y in range(1, depth):  # Start from 1 since we already did layer 0
        current_radius = max_radius * (1 - (y / depth) ** 0.7)
        
        # Show progress
        if y % 5 == 0:
            print(f"Processing layer {y}/{depth}...")
            
        for x in range(-int(current_radius), int(current_radius) + 1):
            for z in range(-int(current_radius), int(current_radius) + 1):
                distance = math.sqrt(x*x + z*z)
                if distance <= current_radius:
                    if distance > current_radius - 2 and random.random() < 0.4:
                        continue
                    
                    if random.random() < 0.6:
                        block_id = 37  # stone
                    elif random.random() < 0.3:
                        block_id = 24  # mossy cobblestone
                    else:
                        block_id = 4   # cobblestone
                    
                    key = f"{x + center_x},{-y},{z + center_z}"
                    cone_blocks[key] = block_id

    return cone_blocks

def main():
    try:
        # Check if map.json exists
        if not os.path.exists('map.json'):
            print("Error: map.json not found in current directory!")
            return

        print("Loading map.json...")
        with open('map.json', 'r') as f:
            map_data = json.load(f)

        # Find platforms
        print("Detecting platforms...")
        platforms = find_platforms(map_data['blocks'])
        print(f"Found {len(platforms)} platforms")

        all_cone_blocks = {}
        
        # Generate a cone for each platform
        for platform in platforms:
            # Calculate platform center
            xs = [x for x, _ in platform]
            zs = [z for _, z in platform]
            center_x = sum(xs) // len(xs)
            center_z = sum(zs) // len(zs)
            
            print(f"Platform center: ({center_x}, {center_z})")
            cone_blocks = generate_hanging_cone(center_x, center_z, start_y=0, depth=30)
            all_cone_blocks.update(cone_blocks)

        print("Adding new blocks to map...")
        blocks_added = 0
        for coord, block_id in all_cone_blocks.items():
            if coord not in map_data['blocks']:
                map_data['blocks'][coord] = block_id
                blocks_added += 1

        print(f"Saving updated map with {blocks_added} new blocks...")
        with open('map.json', 'w') as f:
            json.dump(map_data, f, indent=2)

        print("Done! Map has been updated successfully.")

    except Exception as e:
        print(f"An error occurred: {str(e)}")
        print("Please make sure map.json is in the same directory and is valid JSON.")

if __name__ == "__main__":
    main()

================
File: index.ts
================
import {
  startServer,
  Audio,
  PlayerEntity,
  RaycastOptions,
  PlayerCameraMode,
  PlayerUI,
  Vector3Like,
  PlayerEvent,
  BaseEntityControllerEvent,
  PlayerUIEvent
} from 'hytopia';

import worldMap from './assets/map.json';
import { RaycastHandler } from './src/raycast/raycast-handler';
import { PlayerProjectileManager } from './src/managers/player-projectile-manager';
import { MovingBlockManager, MOVING_BLOCK_CONFIG } from './src/moving_blocks/moving-block-entity';
import { ScoreManager } from './src/managers/score-manager';
import { RoundManager } from './src/managers/round-manager';
import { BlockParticleEffects } from './src/effects/block-particle-effects';
import { TestBlockSpawner } from './src/utils/test-spawner';
import { SceneUIManager } from './src/scene-ui/scene-ui-manager';
import { AudioManager } from './src/managers/audio-manager';
import { PlayerSettingsManager, UISettingsData } from './src/managers/player-settings-manager';

// Platform spawn configuration
const PLATFORM_SPAWNS = {
  LEFT: {
    BASE: { x: -43, y: 5, z: 1 },
    VARIATIONS: [
      { x: -43, y: 5, z: -1 },  // Back
      { x: -43, y: 5, z: 3 },   // Front
      { x: -41, y: 5, z: 1 },   // Closer to center
      { x: -45, y: 5, z: 1 },   // Further from center
    ]
  },
  RIGHT: {
    BASE: { x: 44, y: 5, z: 1 },
    VARIATIONS: [
      { x: 44, y: 5, z: -1 },   // Back
      { x: 44, y: 5, z: 3 },    // Front
      { x: 42, y: 5, z: 1 },    // Closer to center
      { x: 46, y: 5, z: 1 },    // Further from center
    ]
  }
};

// Game configuration
const GAME_CONFIG = {
  FALL_THRESHOLD: -50,  // Y position below which a player is considered fallen
  RESPAWN_HEIGHT_OFFSET: 1,  // How high above the spawn point to respawn
};

// Configuration flags
const IS_TEST_MODE = false;  // Set this to true to enable test mode, false for normal game
const DEBUG_ENABLED = false;  // Development debug flag

// Keep track of last used spawn points
let lastLeftSpawnIndex = -1;
let lastRightSpawnIndex = -1;

// Keep track of player spawn positions
const playerSpawnPositions = new Map<string, Vector3Like>();

// Helper function to get next spawn position
function getNextSpawnPosition(platform: 'LEFT' | 'RIGHT'): Vector3Like {
  const spawnConfig = PLATFORM_SPAWNS[platform];
  const variations = spawnConfig.VARIATIONS;
  
  // Get next index, avoiding the last used one
  let index;
  if (platform === 'LEFT') {
    lastLeftSpawnIndex = (lastLeftSpawnIndex + 1) % variations.length;
    index = lastLeftSpawnIndex;
  } else {
    lastRightSpawnIndex = (lastRightSpawnIndex + 1) % variations.length;
    index = lastRightSpawnIndex;
  }
  
  return variations[index];
}

startServer(world => {
  console.log('Starting server and initializing debug settings...');
  console.log(`Test mode: ${IS_TEST_MODE ? 'enabled' : 'disabled'}`);
  
  // Initialize managers
  const sceneUIManager = SceneUIManager.getInstance(world);
  const settingsManager = PlayerSettingsManager.getInstance(world);
  
  // Enable debug rendering for development
  world.simulation.enableDebugRendering(DEBUG_ENABLED);
  
  // Initialize raycast handler with debug enabled
  const raycastHandler = new RaycastHandler(world);
  raycastHandler.enableDebugRaycasting(DEBUG_ENABLED);
  console.log('RaycastHandler initialized with debug enabled');

  // Initialize the score manager
  const scoreManager = new ScoreManager();
  scoreManager.spawn(world, { x: 0, y: 0, z: 0 }); // Make it available as an entity

  // Initialize the moving block manager
  const movingBlockManager = new MovingBlockManager(world, scoreManager);
  
  // Initialize test spawner if in test mode
  const testSpawner = IS_TEST_MODE ? new TestBlockSpawner(world, movingBlockManager) : null;
  
  // Initialize the round manager (only used in normal mode)
  const roundManager = !IS_TEST_MODE ? new RoundManager(world, movingBlockManager, scoreManager) : null;

  // Development flag for trajectory preview - set to false to disable
  const SHOW_TRAJECTORY_PREVIEW = false;

  // Initialize the projectile manager with round manager if not in test mode
  const projectileManager = new PlayerProjectileManager(
    world,
    raycastHandler,
    SHOW_TRAJECTORY_PREVIEW,
    roundManager ?? undefined
  );

  // Register test mode commands if in test mode
  if (IS_TEST_MODE && testSpawner) {
    // Register commands without the '/' prefix
    world.chatManager.registerCommand('spawn1', (player) => {
      testSpawner.spawnStaticTarget();
      world.chatManager.sendPlayerMessage(player, 'Spawned a static target', 'FFFF00');
    });

    world.chatManager.registerCommand('spawn2', (player) => {
      testSpawner.spawnSineWaveBlock();
      world.chatManager.sendPlayerMessage(player, 'Spawned a sine wave block', 'FFFF00');
    });

    world.chatManager.registerCommand('spawn3', (player) => {
      testSpawner.spawnVerticalWaveBlock();
      world.chatManager.sendPlayerMessage(player, 'Spawned a vertical wave block', 'FFFF00');
    });

    world.chatManager.registerCommand('spawn4', (player) => {
      testSpawner.spawnRegularBlock();
      world.chatManager.sendPlayerMessage(player, 'Spawned a regular block', 'FFFF00');
    });

    world.chatManager.registerCommand('spawn5', (player) => {
      testSpawner.spawnPopUpTarget();
      world.chatManager.sendPlayerMessage(player, 'Spawned a pop-up target', 'FFFF00');
    });

    world.chatManager.registerCommand('spawn6', (player) => {
      testSpawner.spawnRisingTarget();
      world.chatManager.sendPlayerMessage(player, 'Spawned a rising target (stops at pop-up height, then shoots up)', 'FFFF00');
    });

    world.chatManager.registerCommand('spawn7', (player) => {
      testSpawner.spawnParabolicTarget();
      world.chatManager.sendPlayerMessage(player, 'Spawned a parabolic target (moves in a long, dramatic arc with physics-based motion)', 'FFFF00');
    });

    world.chatManager.registerCommand('spawn8', (player) => {
      testSpawner.spawnPendulumTarget();
      world.chatManager.sendPlayerMessage(player, 'Spawned a pendulum target (swings like a pendulum in either XZ or YZ plane)', 'FFFF00');
    });

    world.chatManager.registerCommand('spawnall', (player) => {
      testSpawner.spawnTestBlocks();
      world.chatManager.sendPlayerMessage(player, 'Spawned all block types', 'FFFF00');
    });

    world.chatManager.registerCommand('clearblocks', (player) => {
      world.entityManager.getAllEntities()
        .filter(entity => entity.name.toLowerCase().includes('block'))
        .forEach(entity => entity.despawn());
      world.chatManager.sendPlayerMessage(player, 'Cleared all blocks', 'FFFF00');
    });

    world.chatManager.registerCommand('testround', (player) => {
      testSpawner.startTestRound();
      world.chatManager.sendPlayerMessage(player, 'Test Round Started!', 'FFFF00');
      world.chatManager.sendPlayerMessage(player, 'Duration: 60 seconds', 'FFFF00');
      
      // End round notification
      setTimeout(() => {
        world.chatManager.sendPlayerMessage(player, 'Test Round Ended!', 'FFFF00');
      }, 60000);
    });

    world.chatManager.registerCommand('testhelp', (player) => {
      console.log('Executing testhelp command');
      world.chatManager.sendPlayerMessage(player, 'Test Mode Commands:', 'FFFF00');
      world.chatManager.sendPlayerMessage(player, 'spawn1 - Spawn static target', 'FFFF00');
      world.chatManager.sendPlayerMessage(player, 'spawn2 - Spawn sine wave block', 'FFFF00');
      world.chatManager.sendPlayerMessage(player, 'spawn3 - Spawn vertical wave block', 'FFFF00');
      world.chatManager.sendPlayerMessage(player, 'spawn4 - Spawn regular block', 'FFFF00');
      world.chatManager.sendPlayerMessage(player, 'spawn5 - Spawn pop-up target', 'FFFF00');
      world.chatManager.sendPlayerMessage(player, 'spawn6 - Spawn rising target (stops at pop-up height, then shoots up)', 'FFFF00');
      world.chatManager.sendPlayerMessage(player, 'spawn7 - Spawn parabolic target (long-range arc with physics-based motion)', 'FFFF00');
      world.chatManager.sendPlayerMessage(player, 'spawn8 - Spawn pendulum target (swings like a pendulum in either XZ or YZ plane)', 'FFFF00');
      world.chatManager.sendPlayerMessage(player, 'spawnall - Spawn all block types', 'FFFF00');
      world.chatManager.sendPlayerMessage(player, 'clearblocks - Remove all blocks', 'FFFF00');
      world.chatManager.sendPlayerMessage(player, 'testround - Start a 60-second test round with mixed blocks', 'FFFF00');
    });
  }

  world.loadMap(worldMap);

  // Initialize AudioManager and start background music
  const audioManager = AudioManager.getInstance(world);
  
  /**
   * Check if a player has fallen and needs to be respawned
   */
  function checkPlayerFall(entity: PlayerEntity) {
    if (entity.position.y < GAME_CONFIG.FALL_THRESHOLD) {
      const spawnPos = playerSpawnPositions.get(entity.player.id);
      if (spawnPos) {
        // Add a small height offset to prevent immediate falling
        const respawnPos = {
          x: spawnPos.x,
          y: spawnPos.y + GAME_CONFIG.RESPAWN_HEIGHT_OFFSET,
          z: spawnPos.z
        };
        entity.setPosition(respawnPos);
        console.log(`Player ${entity.player.id} fell and respawned at their initial position`);
      }
    }
  }

  // Set up fall detection interval
  setInterval(() => {
    world.entityManager.getAllPlayerEntities().forEach(entity => {
      checkPlayerFall(entity);
    });
  }, 100); // Check every 100ms

  // Replace direct assignment with proper event listener for player join
  world.on(PlayerEvent.JOINED_WORLD, ({ player }) => {
    console.log('New player joined the game');
    
    // Initialize player states
    scoreManager.initializePlayer(player.id);
    projectileManager.initializePlayer(player.id);
    settingsManager.initializePlayer(player.id);
    
    // Load the UI first
    player.ui.load('ui/index.html');
    
    // Initialize audio with player's settings
    const playerSettings = settingsManager.getPlayerSettings(player.id);
    if (playerSettings) {
      // Start background music with initial volume
      audioManager.setBgmVolume(playerSettings.bgmVolume);
      audioManager.playBackgroundMusic();
      
      // Send initial settings to UI
      player.ui.sendData({
        type: 'settingsUpdate',
        settings: playerSettings
      });
    }
    
    // Send initial projectile count to UI
    player.ui.sendData({
      type: 'updateProjectileCount',
      count: projectileManager.getProjectilesRemaining(player.id)
    });
    
    // Generate spawn position based on player count
    const playerCount = world.entityManager.getAllPlayerEntities().length;
    const isEvenPlayer = playerCount % 2 === 0;
    const spawnPos = isEvenPlayer ? 
      getNextSpawnPosition('LEFT') :
      getNextSpawnPosition('RIGHT');

    // Store the spawn position for this player
    playerSpawnPositions.set(player.id, spawnPos);

    const playerEntity = new PlayerEntity({
      player,
      name: 'Player',
      modelUri: 'models/players/player.gltf',
      modelLoopedAnimations: [ 'idle' ],
      modelScale: 0.5,
    });

    // Spawn the entity at random position
    playerEntity.spawn(world, spawnPos);
    console.log(`Player spawned at (${spawnPos.x.toFixed(2)}, ${spawnPos.y}, ${spawnPos.z.toFixed(2)})`);

    // Configure first-person camera after spawning
    playerEntity.player.camera.setMode(PlayerCameraMode.FIRST_PERSON);
    
    // Hide only the local player's model from their own view
    // This won't affect how other players see them
    player.camera.setModelHiddenNodes([
      'Armature',      // Main skeleton
      'Mesh',          // Main mesh
      'Body_mesh',     // Body mesh if separated
      'Character',     // Common root node name
      'Skeleton',      // Alternative skeleton name
      'Root'           // Root node
    ]);
    
    // Set camera to eye level and slightly forward
    playerEntity.player.camera.setOffset({
      x: 0,
      y: 1,  // Eye level height
      z: 0   // Slightly forward to avoid any model clipping
    });

    // Set a comfortable FOV for first-person gameplay (70 degrees is a common value)
    playerEntity.player.camera.setFov(70);
  
    // Wire up raycast handler and projectile system to the SDK's input system
    playerEntity.controller!.on(BaseEntityControllerEvent.TICK_WITH_PLAYER_INPUT, ({ entity, input, cameraOrientation, deltaTimeMs }) => {
      // Create a clean copy of the input state to avoid recursive references
      const cleanInput = {
        ml: input.ml || false,
        mr: input.mr || false,
      };

      // Right click for raycast
      if (cleanInput.mr) {
        const result = raycastHandler.raycast(
          entity.position,
          entity.player.camera.facingDirection,
          5
        );
        
        if (result) {
          console.log(`Raycast hit at distance: ${result.hitDistance}`);
          if (result.hitBlock) {
            const coord = result.hitBlock.globalCoordinate;
            console.log(`Hit block at (${coord.x}, ${coord.y}, ${coord.z})`);
          }
        } else {
          console.log('Raycast missed');
        }
        
        cleanInput.mr = false;
      }

      // Handle projectile input through the manager with left click
      if (cleanInput.ml) {
        cleanInput.mr = true;
        cleanInput.ml = false;
      }
      
      projectileManager.handleProjectileInput(
        player.id,
        entity.position,
        entity.player.camera.facingDirection,
        cleanInput,
        player
      );

      // Return the original orientation
      return cameraOrientation;
    });

    // Handle settings updates from UI
    player.ui.on(PlayerUIEvent.DATA, (payload) => {
      const data = payload.data;
      if (data && data.type === 'updateSettings') {
        settingsManager.updateSetting(player.id, data.setting, data.value);
        
        // Handle background music volume changes
        if (data.setting === 'bgmVolume') {
          const volume = data.value / 100; // Convert from percentage to decimal
          audioManager.setBgmVolume(volume);
        }
      }
    });

    // Start the round or spawn test blocks based on mode
    if (IS_TEST_MODE && testSpawner) {
      testSpawner.spawnTestBlocks();
      console.log('Test blocks spawned');
    } else if (roundManager && !roundManager.isActive()) {
      roundManager.startRound();
    }

    // Send appropriate welcome messages
    world.chatManager.sendPlayerMessage(player, 'Welcome to the game!', '00FF00');
    world.chatManager.sendPlayerMessage(player, 'Use WASD to move around.');
    world.chatManager.sendPlayerMessage(player, 'Press space to jump.');
    world.chatManager.sendPlayerMessage(player, 'Hold shift to sprint.');
    world.chatManager.sendPlayerMessage(player, 'Right click to raycast.');
    world.chatManager.sendPlayerMessage(player, 'Left click to throw projectiles.');
    world.chatManager.sendPlayerMessage(player, 'Press ESC, Tab, or P to open settings.', '00FF00');
    
    if (IS_TEST_MODE) {
      world.chatManager.sendPlayerMessage(player, 'TEST MODE: One of each block type has been spawned', 'FFFF00');
    } else {
      world.chatManager.sendPlayerMessage(player, `Round ${roundManager!.getCurrentRound()} - Hit as many blocks as you can before time runs out!`, 'FFFF00');
    }
    
    world.chatManager.sendPlayerMessage(player, 'Press \\ to enter or exit debug view.');

    // Send help message for test mode
    if (IS_TEST_MODE) {
      world.chatManager.sendPlayerMessage(player, 'Type /testhelp to see available test commands', 'FFFF00');
    }
  });

  /**
   * Handles the event when a player leaves the game.
   */
  // Replace direct assignment with proper event listener for player leave
  world.on(PlayerEvent.LEFT_WORLD, ({ player }) => {
    console.log('Player left the game');
    
    // Clean up player states
    scoreManager.removePlayer(player.id);
    projectileManager.removePlayer(player.id);
    settingsManager.removePlayer(player.id);
    
    // Handle round system when player leaves (only in normal mode)
    if (!IS_TEST_MODE && roundManager) {
      roundManager.handlePlayerLeave();
    }
    
    // Clean up stored spawn position
    playerSpawnPositions.delete(player.id);
    
    world.entityManager.getPlayerEntitiesByPlayer(player).forEach(entity => entity.despawn());
  });

  // Cleanup managers when the scene changes or the game shuts down
  BlockParticleEffects.getInstance(world).cleanup();
  sceneUIManager.cleanup();
  audioManager.cleanup();
  settingsManager.cleanup();
});

================
File: jest.config.js
================
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  transform: {
    '^.+\\.tsx?$': ['ts-jest', {
      useESM: true,
    }],
  },
  moduleNameMapper: {
    '^hytopia/server$': '<rootDir>/src/__tests__/mocks/hytopia.ts'
  },
  extensionsToTreatAsEsm: ['.ts'],
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
  testMatch: ['**/__tests__/**/*.test.ts'],
};

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Astro Breaker

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.json
================
{
  "name": "astro-breaker",
  "version": "1.0.0",
  "description": "A game where you throw things at blocks to break them",
  "license": "MIT",
  "scripts": {
    "test": "jest"
  },
  "devDependencies": {
    "@types/jest": "^29.5.14",
    "jest": "^29.7.0",
    "ts-jest": "^29.2.6",
    "typescript": "^5.8.2"
  },
  "dependencies": {
    "@hytopia.com/assets": "latest",
    "hytopia": "^0.3.6"
  },
  "jest": {
    "preset": "ts-jest",
    "testEnvironment": "node"
  }
}

================
File: README.md
================
# Jam


## Current Features
- **Raycast System** with block detection and distance calculation
  - Exact coordinate block detection
  - Direction vector normalization
  - Max length constraints
  - Debug visualization (line 90-122 in raycast.test.ts)
- **Block Interaction** through player input
  - Left/right click handling
  - Input flag management
  - Block breaking mechanics
  - Block placement
  - Sound effects on block destruction
- **Player Management**
  - Join/leave handling
  - Entity spawning/despawning
  - Basic movement and position tracking
- **Sound System**
  - Block breaking sound effects
  - Background music with volume control
  - Projectile launch sounds
  - Sound effect attribution
- **Moving Block System**
  - Multiple block movement patterns:
    - Static targets (tutorial blocks)
    - Normal blocks (basic movement)
    - Sine wave motion
    - Vertical wave motion
    - Pop-up targets
    - Rising targets
    - Parabolic motion
    - Pendulum swinging
  - Configurable movement behaviors:
    - Customizable speeds
    - Variable amplitudes
    - Adjustable frequencies
    - Configurable heights and distances
  - Dynamic spawn system:
    - Safe spawn positioning
    - Platform collision avoidance
    - Block spacing management
  - Round-based progression:
    - Tutorial round with static targets
    - Progressive difficulty increase
    - Mixed block types in later rounds
  - Player count scaling:
    - Increased block counts with more players
    - Adjusted spawn rates
    - Balanced difficulty scaling
- **Scoring System**
  - Dynamic score calculation based on:
    - Shot distance
    - Target size
    - Movement patterns
    - Time-based decay factor
    - Z-axis movement multiplier
  - Combo system:
    - Consecutive hits tracking
    - Multi-hit bonuses
    - Combo timeout window (4000ms)
    - Progressive combo multipliers
    - Visual combo notifications
  - Movement-based multipliers:
    - Static targets: 1.0x
    - Z-axis movement: 4.0x
    - Sine wave: 3.0x
    - Vertical wave: 3.0x
    - Pop-up targets: 4.0x
    - Rising targets: 5.5x
    - Parabolic motion: 6.0x
  - Real-time score tracking
- **UI Features**
  - Projectile counter with animations
  - Score display
    - Real-time score updates
    - Round scores
    - Total scores
    - Placement points
  - Dynamic leaderboard
    - Player rankings
    - Points tracking
    - Winner highlighting
  - Game status indicators
    - Round number
    - Round timer
    - Countdown overlays
  - Visual feedback
    - Hit notifications
    - Block destruction effects
    - Combo counters with animations
    - End-game overlays
  - Settings menu
    - Audio volume controls
    - Crosshair settings
      - Size
      - Color
      - Toggle component visibility
  - Visual feedback for actions
    - Block placement
    - Block destruction
    - Projectile launch
    - Score change
    - Combo counter
    
- **Projectile System**
  - Physics-based projectile motion
  - Trajectory preview
  - Collision detection
  - Bounce mechanics
  - Limited ammo system

## Code Structure


Run Automated Tests:
```bash
bun test
```


Start development server:
```bash
bun run index.ts
```

This implementation follows pragmatic TDD principles with:
- Focused tests on core gameplay loops
- Clear separation between game logic and SDK integration
- Gradual feature expansion through iterative test updates
- Real-world error handling patterns in debug systems

## TDD Approach
1. **Test First Development**:
   - Raycast specs (line 5-123) validate block detection logic before implementation
   - Input handling tests (line 5-151) drive block interaction requirements
   - 85% test coverage focused on core gameplay systems

2. **Iterative Implementation**:
   ```typescript:src/__tests__/raycast.test.ts
   startLine: 74
   endLine: 87
   ```
   - Marked incomplete features with `test.skip()` for future implementation
   - Used Jest's built-in mocking for gradual feature development

3. **Living Documentation**:
   - Test cases document edge cases (diagonal directions, max length constraints)
   - Mock implementations (hytopia.ts) serve as system documentation

## Development Commands

Install dependencies:
```bash
bun install
```

credits for blop1 sound effects: https://kronbits.itch.io/freesfx?download#google_vignette

## Credits
Sound Effects:
- Block breaking sounds: [Kronbits Free SFX Pack](https://kronbits.itch.io/freesfx)

## Licensing

This project uses a dual licensing approach:

- **Main Code**: Licensed under the MIT License - see the [LICENSE](./LICENSE) file
- **Assets Directory**: Assets in the `/assets` directory are licensed under the HYTOPIA LIMITED USE LICENSE - see [assets/LICENSE.md](./assets/LICENSE.md)

The MIT License allows you to freely use, modify, and distribute the original code, while the HYTOPIA assets have more restricted usage terms.

### Third-Party Assets

Astro Breaker © 2025

================
File: src/__tests__/block-movement.test.ts
================
import { describe, test, expect, jest } from '@jest/globals';
import { MovingBlockEntity } from '../moving_blocks/moving-block-entity';
import { DefaultBlockMovement } from '../moving_blocks/block-movement';
import { Vector3Like } from 'hytopia';

describe('Block Movement Behavior', () => {
  test('should normalize direction vector on initialization', () => {
    const block = new MovingBlockEntity({
      direction: { x: 2, y: 0, z: 0 }, // Non-normalized vector
      moveSpeed: 10
    });

    const direction = block.getDirection();
    expect(direction.x).toBe(1); // Should be normalized to 1
    expect(direction.y).toBe(0);
    expect(direction.z).toBe(0);
  });

  test('should handle zero movement speed', () => {
    const block = new MovingBlockEntity({
      direction: { x: 1, y: 0, z: 0 },
      moveSpeed: 0
    });

    const movement = new DefaultBlockMovement();
    const mockSetPosition = jest.fn();
    block.setPosition = mockSetPosition;

    // Initialize position through setPosition
    block.setPosition({ x: 0, y: 0, z: 0 });
    
    movement.update(block, 1000);
    
    expect(mockSetPosition).toHaveBeenCalledWith({
      x: 0,
      y: 0,
      z: 0
    });
  });

  test('should handle boundary checks', () => {
    const block = new MovingBlockEntity({
      direction: { x: 1, y: 0, z: 0 },
      moveSpeed: 10,
      movementBounds: {
        min: { x: 0, y: 0, z: 0 },
        max: { x: 5, y: 5, z: 5 }
      }
    });

    const movement = new DefaultBlockMovement();
    const mockSetPosition = jest.fn();
    block.setPosition = mockSetPosition;

    // Initialize position through setPosition
    block.setPosition({ x: 0, y: 0, z: 0 });
    
    movement.update(block, 1000); // Would move to x=10, beyond bounds
    
    // Should have triggered bounds check and reversal
    expect(block.getDirection().x).toBe(-1);
  });

});

================
File: src/__tests__/mocks/hytopia.ts
================
import { Vector3, RaycastOptions, RaycastHit, Block, Vector3Like } from 'hytopia';

// Minimal Block implementation for testing
class MockBlock implements Block {
    constructor(
        public readonly globalCoordinate: Vector3Like,
        public readonly blockType = {} as Block['blockType']
    ) {}

    getNeighborGlobalCoordinateFromHitPoint(hitPoint: Vector3Like): Vector3Like {
        return { x: Math.round(hitPoint.x), y: Math.round(hitPoint.y), z: Math.round(hitPoint.z) };
    }
}

export class World {
    simulation = new Simulation();
}

export class Simulation {
    private debugRaycastEnabled = false;
    private blocks = new Map<string, MockBlock>();

    enableDebugRaycasting(enabled: boolean): void {
        this.debugRaycastEnabled = enabled;
    }

    get isDebugRaycastingEnabled(): boolean {
        return this.debugRaycastEnabled;
    }

    addTestBlock(x: number, y: number, z: number): void {
        const coord = { x: Math.round(x), y: Math.round(y), z: Math.round(z) };
        this.blocks.set(`${coord.x},${coord.y},${coord.z}`, new MockBlock(coord));
    }

    raycast(origin: Vector3Like, direction: Vector3Like, length: number, options?: RaycastOptions): RaycastHit | null {
        if (!origin || !direction || length <= 0) return null;

        // Normalize direction vector
        const magnitude = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);
        if (magnitude === 0) return null;
        
        const normalizedDir = {
            x: direction.x / magnitude,
            y: direction.y / magnitude,
            z: direction.z / magnitude
        };

        // Check for blocks along the ray path
        for (let distance = 0.5; distance <= length; distance += 0.5) {
            const checkPoint = {
                x: Math.round(origin.x + normalizedDir.x * distance),
                y: Math.round(origin.y + normalizedDir.y * distance),
                z: Math.round(origin.z + normalizedDir.z * distance)
            };
            
            const key = `${checkPoint.x},${checkPoint.y},${checkPoint.z}`;
            const block = this.blocks.get(key);
            
            if (block) {
                return {
                    hitBlock: block,
                    hitPoint: {
                        x: origin.x + normalizedDir.x * distance,
                        y: origin.y + normalizedDir.y * distance,
                        z: origin.z + normalizedDir.z * distance
                    },
                    hitDistance: distance
                };
            }
        }
        
        return null;
    }
}

export class PlayerUI {
    onData?: (playerUI: PlayerUI, data: any) => void;

    sendData(data: any): void {
        if (this.onData) {
            this.onData(this, data);
        }
    }
}

export class Player {
    ui: PlayerUI = new PlayerUI();
    settings = {
        sensitivity: 50,
        crosshairColor: '#ffff00'
    };
}

================
File: src/__tests__/moving-block-entity.test.ts
================
import { MovingBlockEntity, MovingBlockOptions } from '../moving_blocks/moving-block-entity';
import { ScoreManager } from '../managers/score-manager';
import { mock, describe, test, expect, beforeEach } from 'bun:test';
import { ProjectileEntity } from '../entities/projectile-entity';

describe('MovingBlockEntity', () => {
  const player1Id = 'player1';
  const player2Id = 'player2';
  let scoreManager: ScoreManager;

  beforeEach(() => {
    scoreManager = new ScoreManager();
    scoreManager.initializePlayer(player1Id);
    scoreManager.initializePlayer(player2Id);
  });


  test('should not award points if projectile has no player ID', () => {
    // Create a projectile without a player ID
    const projectile = new ProjectileEntity({
      name: 'TestProjectile'
      // No playerId set
    });

    // Create block with scoring callback
    const block = new MovingBlockEntity({
      health: 1,
      isBreakable: true,
      onBlockBroken: () => {
        // Use the stored player ID from the block
        if ((block as any).playerId) {
          scoreManager.addScore((block as any).playerId, 5);
        }
      }
    });
    
    // Mock required methods
    block.setOpacity = mock(() => {});
    block.despawn = mock(() => {});
    projectile.despawn = mock(() => {});
    
    // Simulate collision with projectile
    (block as any).handleCollision(projectile);

    // Verify no score was awarded since there was no player ID
    expect(scoreManager.getScore(player1Id)).toBe(0);
  });
 
});

================
File: src/__tests__/raycast-handler.test.ts
================
import { World } from './mocks/hytopia';
import { RaycastHandler } from '../raycast/raycast-handler';
import { Vector3Like } from 'hytopia';

describe('RaycastHandler', () => {
    let world: World;
    let handler: RaycastHandler;
    let consoleSpy: jest.SpyInstance;
    let consoleWarnSpy: jest.SpyInstance;

    beforeEach(() => {
        world = new World();
        handler = new RaycastHandler(world);
        // Enable debug mode for testing
        handler.enableDebugRaycasting(true);
        consoleSpy = jest.spyOn(console, 'log').mockImplementation();
        consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation();
    });

    afterEach(() => {
        consoleSpy.mockRestore();
        consoleWarnSpy.mockRestore();
    });

    test('should handle raycast with no hits', () => {
        const origin = { x: 0, y: 0, z: 0 } as Vector3Like;
        const direction = { x: 1, y: 0, z: 0 } as Vector3Like;
        const length = 5;

        const result = handler.raycast(origin, direction, length);

        expect(result).toBeNull();
        expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('No hit detected'));
    });

    test('should detect block hits', () => {
        const origin = { x: 0, y: 0, z: 0 } as Vector3Like;
        const direction = { x: 1, y: 0, z: 0 } as Vector3Like;
        const length = 5;

        // Add a test block at x=3
        world.simulation.addTestBlock(3, 0, 0);

        const result = handler.raycast(origin, direction, length);

        expect(result).not.toBeNull();
        expect(result?.hitBlock).toBeDefined();
        expect(result?.hitBlock?.globalCoordinate.x).toBe(3);
        expect(result?.hitDistance).toBeLessThan(length);
        expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Hit detected'));
    });

    test('should handle debug visualization settings', () => {
        handler.enableDebugRaycasting(true);
        expect(handler.isDebugRaycastingEnabled()).toBe(true);
        expect(consoleSpy).toHaveBeenCalledWith('Enabling debug raycasting');

        handler.enableDebugRaycasting(false);
        expect(handler.isDebugRaycastingEnabled()).toBe(false);
        expect(consoleSpy).toHaveBeenCalledWith('Disabling debug raycasting');
    });

    test('should handle invalid inputs', () => {
        const result = handler.raycast(
            null as unknown as Vector3Like,
            { x: 1, y: 0, z: 0 } as Vector3Like,
            5
        );

        expect(result).toBeNull();
        expect(consoleWarnSpy).toHaveBeenCalledWith(expect.stringContaining('Invalid raycast parameters'));
    });

    test('should handle zero direction vector', () => {
        const origin = { x: 0, y: 0, z: 0 } as Vector3Like;
        const zeroDirection = { x: 0, y: 0, z: 0 } as Vector3Like;
        
        const result = handler.raycast(origin, zeroDirection, 5);
        
        expect(result).toBeNull();
        expect(consoleWarnSpy).toHaveBeenCalledWith(expect.stringContaining('Invalid raycast parameters: zero direction vector'));
    });

    test('should work with non-normalized direction vectors', () => {
        const origin = { x: 0, y: 0, z: 0 } as Vector3Like;
        const nonNormalizedDir = { x: 2, y: 0, z: 0 } as Vector3Like;
        const length = 5;

        world.simulation.addTestBlock(3, 0, 0);
        const result = handler.raycast(origin, nonNormalizedDir, length);

        expect(result).not.toBeNull();
        expect(result?.hitBlock).toBeDefined();
        expect(result?.hitBlock?.globalCoordinate.x).toBe(3);
        expect(result?.hitDistance).toBeLessThan(length);
    });
});

================
File: src/__tests__/round-manager.test.ts
================
import { RoundManager } from '../managers/round-manager';
import { ScoreManager } from '../managers/score-manager';
import { MovingBlockManager } from '../moving_blocks/moving-block-entity';
import { World } from 'hytopia';
import { describe, test, expect, beforeEach, jest } from '@jest/globals';

// Mock implementations
const mockWorld = {
    entityManager: {
        getAllPlayerEntities: jest.fn(),
        getAllEntities: jest.fn()
    }
} as unknown as World;

const mockBlockManager = {
    getBlockCount: jest.fn(),
    createZAxisBlock: jest.fn(),
    createSineWaveBlock: jest.fn(),
    createStaticTarget: jest.fn(),
    createVerticalWaveBlock: jest.fn()
} as unknown as MovingBlockManager;

// Mock round config for faster tests
const TEST_ROUND_DURATION = 100; // 100ms for tests
const TEST_TRANSITION_DURATION = 50; // 50ms for transition (faster for tests)

// Override getRoundConfig for tests
const createTestRoundManager = (world: World, blockManager: MovingBlockManager, scoreManager: ScoreManager) => {
    const manager = new RoundManager(world, blockManager, scoreManager, TEST_TRANSITION_DURATION);
    
    // Override countdown for faster tests
    (manager as any).startCountdown = function() {
        if (this.roundTransitionPending) return;
        // Immediate start for tests
        setTimeout(() => this.actuallyStartRound(), 10);
    };
    
    (manager as any).getRoundConfig = () => ({
        duration: TEST_ROUND_DURATION,
        minBlockCount: 8,
        maxBlockCount: 12,
        blockSpawnInterval: 50,
        speedMultiplier: 0.5,
        blockTypes: {
            normal: 0,
            sineWave: 0,
            static: 1,
            verticalWave: 0,
            popup: 0,
            rising: 0,
            parabolic: 0,
            pendulum: 0
        }
    });
    return manager;
};

describe('RoundManager - Game Lifecycle', () => {
    let roundManager: RoundManager;
    let scoreManager: ScoreManager;
    let mockPlayers: any[];

    // Helper function to add mock players
    const addMockPlayer = (playerId: string) => {
        const mockPlayer = { 
            player: { 
                id: playerId,
                ui: { sendData: jest.fn() }
            }
        };
        mockPlayers.push(mockPlayer);
        (mockWorld.entityManager.getAllPlayerEntities as jest.Mock).mockReturnValue(mockPlayers);
    };

    beforeEach(() => {
        // Reset mocks
        jest.clearAllMocks();
        
        // Create fresh instances
        scoreManager = new ScoreManager();
        roundManager = createTestRoundManager(mockWorld, mockBlockManager, scoreManager);
        
        // Setup default mock players
        mockPlayers = [
            { 
                player: { 
                    id: 'player1',
                    ui: { sendData: jest.fn() }
                }
            },
            { 
                player: { 
                    id: 'player2',
                    ui: { sendData: jest.fn() }
                }
            }
        ];
        
        // Default mock implementation
        (mockWorld.entityManager.getAllPlayerEntities as jest.Mock).mockReturnValue(mockPlayers);
        (mockWorld.entityManager.getAllEntities as jest.Mock).mockReturnValue([]);
    });

    describe('Game Start Conditions', () => {
        test('should not start game with insufficient players', () => {
            // Mock no players
            (mockWorld.entityManager.getAllPlayerEntities as jest.Mock).mockReturnValue([]);
            
            roundManager.startRound();
            
            // Should be in waiting state
            expect(roundManager.isWaitingForPlayers()).toBe(true);
            expect(roundManager.isActive()).toBe(false);
        });

        test('should start game when minimum players join', () => {
            // Mock minimum required players
            (mockWorld.entityManager.getAllPlayerEntities as jest.Mock).mockReturnValue(mockPlayers);
            
            roundManager.startRound();
            
            // Should start countdown and not be in waiting state
            expect(roundManager.isWaitingForPlayers()).toBe(false);
            // Note: Round won't be active immediately due to countdown
            expect(roundManager.getCurrentRound()).toBe(0);
        });

        test('should broadcast waiting for players message', () => {
            // Setup a mock player first, then remove them
            (mockWorld.entityManager.getAllPlayerEntities as jest.Mock).mockReturnValue(mockPlayers);
            
            // Then mock no players for the actual check
            (mockWorld.entityManager.getAllPlayerEntities as jest.Mock)
                .mockReturnValueOnce([])  // First call returns empty
                .mockReturnValue(mockPlayers);  // Subsequent calls return players
            
            roundManager.startRound();
            
            expect(roundManager.isWaitingForPlayers()).toBe(true);
            // Verify waiting message was broadcast to the mock player
            expect(mockPlayers[0].player.ui.sendData).toHaveBeenCalledWith(
                expect.objectContaining({
                    type: 'waitingForPlayers',
                    data: expect.objectContaining({
                        current: 0,
                        required: 2
                    })
                })
            );
        });
    });

    describe('Round Progression', () => {
        test('should increment round counter when round starts', async () => {
            // Mock private method to bypass countdown
            (roundManager as any).actuallyStartRound();
            
            // Round should be incremented immediately
            expect(roundManager.getCurrentRound()).toBe(1);
            expect(roundManager.isActive()).toBe(true);
        });

        test('should end round after duration', async () => {
            (roundManager as any).actuallyStartRound();
            
            // Fast forward round duration
            await new Promise(resolve => setTimeout(resolve, TEST_ROUND_DURATION + 50));
            roundManager.endRound();
            
            expect(roundManager.isActive()).toBe(false);
        });

        test('should broadcast round updates', async () => {
            (roundManager as any).actuallyStartRound();
            
            // Wait for round to start
            await new Promise(resolve => setTimeout(resolve, TEST_TRANSITION_DURATION));
            
            // Verify round info was broadcast
            expect(mockPlayers[0].player.ui.sendData).toHaveBeenCalledWith(
                expect.objectContaining({
                    type: 'roundUpdate'
                })
            );
        });
    });

    describe('Game End and Restart', () => {
        test('should end game after max rounds', async () => {
            // Get max rounds from the manager's config
            const maxRounds = (roundManager as any).GAME_CONFIG.maxRounds;
            
            // Run through all rounds
            for (let i = 0; i < maxRounds; i++) {
                (roundManager as any).actuallyStartRound();
                await new Promise(resolve => setTimeout(resolve, TEST_ROUND_DURATION / 2));
                roundManager.endRound();
                if (i < maxRounds - 1) {
                    await new Promise(resolve => setTimeout(resolve, TEST_TRANSITION_DURATION + 20));
                }
            }

            // Short wait for final events to process
            await new Promise(resolve => setTimeout(resolve, 50));

            // Verify game end broadcast
            const calls = mockPlayers[0].player.ui.sendData.mock.calls;
            const gameEndCall = calls.find((call: any) => call[0]?.type === 'gameEnd');
            expect(gameEndCall).toBeTruthy();
        });

        test('should reset game state for new game', async () => {
            // Start and end a game
            (roundManager as any).actuallyStartRound();
            await new Promise(resolve => setTimeout(resolve, TEST_ROUND_DURATION / 2));
            roundManager.endRound();
            await new Promise(resolve => setTimeout(resolve, TEST_TRANSITION_DURATION + 20));
            (roundManager as any).resetGame();
            
            expect(roundManager.getCurrentRound()).toBe(0);
            expect(roundManager.isActive()).toBe(false);
        });

        test('should handle player leaving mid-game', async () => {
            (roundManager as any).actuallyStartRound();
            await new Promise(resolve => setTimeout(resolve, TEST_TRANSITION_DURATION + 50));
            
            // Mock player leaving
            (mockWorld.entityManager.getAllPlayerEntities as jest.Mock).mockReturnValue([]);
            roundManager.handlePlayerLeave();
            
            // Game should continue with fewer players
            expect(roundManager.isActive()).toBe(true);
        });
    });

    describe('Leaderboard and Scoring', () => {
        test('should track round winners', () => {
            (roundManager as any).actuallyStartRound();
            
            // Simulate some scoring
            scoreManager.addScore('player1', 100);
            
            roundManager.endRound();
            
            // Verify winner announcement
            expect(mockPlayers[0].player.ui.sendData).toHaveBeenCalledWith(
                expect.objectContaining({
                    type: 'roundEnd'
                })
            );
        });

        test('should calculate final standings at game end', async () => {
            const maxRounds = (roundManager as any).GAME_CONFIG.maxRounds;
            
            // Run through all rounds with scoring
            for (let i = 0; i < maxRounds; i++) {
                (roundManager as any).actuallyStartRound();
                scoreManager.addScore('player1', 100);
                roundManager.endRound();
                
                // Wait for round transition
                await new Promise(resolve => setTimeout(resolve, TEST_TRANSITION_DURATION + 50));
                
                // Wait for any pending round start
                while ((roundManager as any).roundTransitionPending) {
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
            }

            // Wait for final game end calculations
            await new Promise(resolve => setTimeout(resolve, TEST_TRANSITION_DURATION + 100));

            // Get the last call arguments to sendData
            const calls = mockPlayers[0].player.ui.sendData.mock.calls;
            const gameEndCall = calls.find((call: any) => call[0]?.type === 'gameEnd');

            // Verify game end data was sent
            expect(gameEndCall).toBeTruthy();
            expect(gameEndCall[0]).toEqual({
                type: 'gameEnd',
                data: expect.objectContaining({
                    nextGameIn: expect.any(Number),
                    standings: expect.arrayContaining([
                        expect.objectContaining({
                            playerId: expect.any(String),
                            totalScore: expect.any(Number),
                            placementPoints: expect.any(Number),
                            wins: expect.any(Number)
                        })
                    ]),
                    stats: expect.objectContaining({
                        completedRounds: expect.any(Number),
                        totalRounds: expect.any(Number)
                    }),
                    winner: expect.objectContaining({
                        playerId: expect.any(String),
                        totalScore: expect.any(Number),
                        placementPoints: expect.any(Number),
                        wins: expect.any(Number)
                    })
                })
            });
        });
    });

    describe('Cleanup', () => {
        test('should properly cleanup resources', () => {
            (roundManager as any).actuallyStartRound();
            
            // Force round to be active
            expect(roundManager.isActive()).toBe(true);
            
            // Cleanup should clear all timers and state
            roundManager.cleanup();
            roundManager.endRound(); // Ensure round is properly ended
            
            expect(roundManager.isActive()).toBe(false);
            expect((roundManager as any).roundTimer).toBeNull();
            expect((roundManager as any).blockSpawnTimer).toBeNull();
            expect((roundManager as any).checkPlayersInterval).toBeNull();
        });
    });
});

describe('RoundManager - Round Continuity', () => {
    let roundManager: RoundManager;
    let scoreManager: ScoreManager;
    let mockPlayers: any[];
    let mockWorld: jest.Mocked<World>;
    let mockBlockManager: jest.Mocked<MovingBlockManager>;

    beforeEach(() => {
        // Reset mocks
        jest.clearAllMocks();
        
        // Setup mock players
        mockPlayers = [];
        
        // Setup mock world
        mockWorld = {
            entityManager: {
                getAllPlayerEntities: jest.fn(() => mockPlayers),
                getAllEntities: jest.fn(() => [])
            }
        } as unknown as jest.Mocked<World>;

        // Setup mock block manager
        mockBlockManager = {
            getBlockCount: jest.fn(),
            createZAxisBlock: jest.fn(),
            createSineWaveBlock: jest.fn(),
            createStaticTarget: jest.fn(),
            createVerticalWaveBlock: jest.fn()
        } as unknown as jest.Mocked<MovingBlockManager>;

        // Create fresh instances with test config
        scoreManager = new ScoreManager();
        roundManager = createTestRoundManager(mockWorld, mockBlockManager, scoreManager);
    });

    const addMockPlayer = (id: string) => {
        const player = {
            id,
            ui: { sendData: jest.fn() }
        };
        const playerEntity = { player };
        mockPlayers.push(playerEntity);
        return playerEntity;
    };

    test('should maintain round count when player leaves and new player joins mid-game', async () => {
        // Add initial players and start game
        addMockPlayer('player1');
        addMockPlayer('player2');
        
        // Start first round
        roundManager.startRound();
        (roundManager as any).actuallyStartRound();
        expect(roundManager.getCurrentRound()).toBe(1);
        expect((roundManager as any).gameInProgress).toBe(true);

        // End round 1
        roundManager.endRound();
        expect(roundManager.getCurrentRound()).toBe(1);

        // Remove player1, add player2
        mockPlayers = [];
        addMockPlayer('player2');

        // Start round 2 - should continue from previous round
        (roundManager as any).actuallyStartRound();
        expect(roundManager.getCurrentRound()).toBe(2);
        expect((roundManager as any).gameInProgress).toBe(true);

        // Add back player1
        addMockPlayer('player1');
        expect(roundManager.getCurrentRound()).toBe(2);

        // Verify game is still in progress
        expect((roundManager as any).gameInProgress).toBe(true);
    });

    test('should only reset game when waiting for initial players', () => {
        // Start with no players
        expect(mockPlayers.length).toBe(0);
        roundManager.startRound();
        expect(roundManager.isWaitingForPlayers()).toBe(true);
        expect((roundManager as any).gameInProgress).toBe(false);

        // Add first player
        addMockPlayer('player1');
        roundManager.startRound();
        expect(roundManager.isWaitingForPlayers()).toBe(true);
        
        // Add second player and start game
        addMockPlayer('player2');
        roundManager.startRound();
        (roundManager as any).actuallyStartRound();
        expect(roundManager.getCurrentRound()).toBe(1);
        expect((roundManager as any).gameInProgress).toBe(true);
    });

    test('should complete full game cycle with player changes', async () => {
        // Start with two players
        addMockPlayer('player1');
        addMockPlayer('player2');
        
        // Play through all rounds with player changes
        for (let i = 0; i < (roundManager as any).GAME_CONFIG.maxRounds; i++) {
            roundManager.startRound();
            (roundManager as any).actuallyStartRound();
            
            // Simulate player switch in middle rounds
            if (i === 1) {
                mockPlayers = [];
                addMockPlayer('player2');
            }
            if (i === 2) {
                addMockPlayer('player1');
            }
            
            expect(roundManager.getCurrentRound()).toBe(i + 1);
            expect((roundManager as any).gameInProgress).toBe(true);
            
            roundManager.endRound();
        }
        
        // Verify game ended properly
        expect(roundManager.getCurrentRound()).toBe((roundManager as any).GAME_CONFIG.maxRounds);
        expect((roundManager as any).gameInProgress).toBe(false);
    });

    test('should not start new round if one is pending', async () => {
        // Add initial players and start game
        addMockPlayer('player1');
        addMockPlayer('player2');
        
        // Start and end round 1
        roundManager.startRound();
        await new Promise(resolve => setTimeout(resolve, 20));
        (roundManager as any).actuallyStartRound();
        roundManager.endRound();
        
        // Verify transition state
        expect((roundManager as any).roundTransitionPending).toBe(true);
        
        // Simulate new player joining during the wait
        addMockPlayer('player3');
        roundManager.startRound(); // Should not trigger new round
        
        expect(roundManager.getCurrentRound()).toBe(1);
        
        // Wait for transition to complete
        await new Promise(resolve => setTimeout(resolve, TEST_TRANSITION_DURATION + 20));
        (roundManager as any).actuallyStartRound();
        
        // Now round should have incremented
        expect(roundManager.getCurrentRound()).toBe(2);
    });

    test('should handle player reload during round transition', async () => {
        // Start with two players
        addMockPlayer('player1');
        addMockPlayer('player2');
        
        // Start and end round 1
        roundManager.startRound();
        (roundManager as any).actuallyStartRound();
        roundManager.endRound();
        
        // Simulate player "reload" - same player rejoining
        mockPlayers = [];
        const player1Rejoined = addMockPlayer('player1');
        
        // Try to start round (as would happen on player join)
        roundManager.startRound();
        
        // Should still be in round 1, waiting for scheduled next round
        expect(roundManager.getCurrentRound()).toBe(1);
        
        // Let the scheduled round start happen
        (roundManager as any).actuallyStartRound();
        expect(roundManager.getCurrentRound()).toBe(2);
    });

    test('should prevent double round starts during transition period', async () => {
        // Add initial players and start game
        addMockPlayer('player1');
        addMockPlayer('player2');
        
        // Start first round
        roundManager.startRound();
        (roundManager as any).actuallyStartRound();
        expect(roundManager.getCurrentRound()).toBe(1);
        
        // End round which schedules next round start
        roundManager.endRound();
        
        // Verify we're in transition state
        expect((roundManager as any).isRoundActive).toBe(false);
        expect((roundManager as any).roundTransitionPending).toBe(true);
        
        // Simulate player reload/rejoin during transition
        mockPlayers = [];
        addMockPlayer('player1');
        roundManager.startRound(); // This should not trigger a new round
        
        // Wait for the transition time
        await new Promise(resolve => setTimeout(resolve, TEST_TRANSITION_DURATION + 50));
        
        // Add another player during transition
        addMockPlayer('player2');
        
        // Let the scheduled round start happen
        (roundManager as any).actuallyStartRound();
        
        // Verify round incremented
        expect(roundManager.getCurrentRound()).toBe(2);
    });

    test('should properly handle rapid player joins/leaves', async () => {
        // Reset game state first
        (roundManager as any).resetGame();
        expect(roundManager.getCurrentRound()).toBe(0);

        // Add initial players and start first round
        addMockPlayer('player1');
        addMockPlayer('player2');
        roundManager.startRound();
        await new Promise(resolve => setTimeout(resolve, 20));
        (roundManager as any).actuallyStartRound();
        expect(roundManager.getCurrentRound()).toBe(1);

        // End round which triggers transition
        roundManager.endRound();
        expect((roundManager as any).roundTransitionPending).toBe(true);

        // Simulate rapid player changes during transition
        for(let i = 0; i < 5; i++) {
            mockPlayers = [];
            addMockPlayer(`player${i}`);
            await new Promise(resolve => setTimeout(resolve, 5));
        }
        
        // Wait for the transition time
        await new Promise(resolve => setTimeout(resolve, TEST_TRANSITION_DURATION + 20));
        
        // Let the scheduled round start happen
        (roundManager as any).actuallyStartRound();
        
        // Verify round incremented
        expect(roundManager.getCurrentRound()).toBe(2);
    });

    test('should maintain roundTransitionPending state during player changes', async () => {
        // Start game with two players
        addMockPlayer('player1');
        addMockPlayer('player2');
        roundManager.startRound();
        (roundManager as any).actuallyStartRound();
        
        // End round 1 which sets roundTransitionPending
        roundManager.endRound();
        expect((roundManager as any).roundTransitionPending).toBe(true);
        
        // Simulate player leaving during transition
        mockPlayers = [];
        roundManager.handlePlayerLeave();
        expect((roundManager as any).roundTransitionPending).toBe(true);
        
        // Simulate new player joining during transition
        addMockPlayer('player3');
        roundManager.startRound();
        expect((roundManager as any).roundTransitionPending).toBe(true);
        
        // Wait for transition
        await new Promise(resolve => setTimeout(resolve, TEST_TRANSITION_DURATION + 50));
        
        // Let scheduled round start happen
        (roundManager as any).actuallyStartRound();
        
        // Verify transition completed
        expect((roundManager as any).roundTransitionPending).toBe(false);
        expect(roundManager.getCurrentRound()).toBe(2);
    });

    test('should properly transition game states from active to end', async () => {
        // Reset game state first
        (roundManager as any).resetGame();
        expect(roundManager.getCurrentRound()).toBe(0);

        // Add players and start game
        addMockPlayer('player1');
        addMockPlayer('player2');
        roundManager.startRound();
        
        // Wait for initial round to start
        await new Promise(resolve => setTimeout(resolve, 20));
        (roundManager as any).actuallyStartRound();
        expect(roundManager.getCurrentRound()).toBe(1);

        // Configure a shorter game for test speed
        (roundManager as any).GAME_CONFIG.maxRounds = 3;

        // Simulate rounds until game end
        for (let i = 0; i < (roundManager as any).GAME_CONFIG.maxRounds - 1; i++) {
            // Update player score
            scoreManager.addScore('player1', 100);
            
            // End current round
            roundManager.endRound();
            
            if (i < (roundManager as any).GAME_CONFIG.maxRounds - 2) {
                // Wait for transition
                await new Promise(resolve => setTimeout(resolve, TEST_TRANSITION_DURATION + 20));
                
                // Start next round
                (roundManager as any).actuallyStartRound();
                
                // Verify game is still in progress and round incremented
                expect((roundManager as any).gameInProgress).toBe(true);
                expect(roundManager.getCurrentRound()).toBe(i + 2);
            }
        }
        
        // Wait for final game end processing
        await new Promise(resolve => setTimeout(resolve, 50));
        
        // Verify final game state
        expect((roundManager as any).gameInProgress).toBe(false);
        
        // Verify game end message was sent
        const calls = mockPlayers[0].player.ui.sendData.mock.calls;
        const gameEndCall = calls.find((call: any) => call[0]?.type === 'gameEnd');
        expect(gameEndCall).toBeTruthy();
    });
});

describe('RoundManager - Round Timing', () => {
    let roundManager: RoundManager;
    let scoreManager: ScoreManager;
    let mockPlayers: any[];

    // Helper function to add mock players
    const addMockPlayer = (playerId: string) => {
        const mockPlayer = { 
            player: { 
                id: playerId,
                ui: { sendData: jest.fn() }
            }
        };
        mockPlayers.push(mockPlayer);
        (mockWorld.entityManager.getAllPlayerEntities as jest.Mock).mockReturnValue(mockPlayers);
    };

    beforeEach(() => {
        jest.clearAllMocks();
        scoreManager = new ScoreManager();
        mockPlayers = [{ 
            player: { 
                id: 'player1',
                ui: { sendData: jest.fn() }
            }
        }];
        
        (mockWorld.entityManager.getAllPlayerEntities as jest.Mock).mockReturnValue(mockPlayers);
        (mockWorld.entityManager.getAllEntities as jest.Mock).mockReturnValue([]);
        
        roundManager = createTestRoundManager(mockWorld, mockBlockManager, scoreManager);
    });

    test('should respect round duration and transition timing', async () => {
        // Add required players
        addMockPlayer('player1');
        addMockPlayer('player2');
        
        // Start first round
        roundManager.startRound();
        await new Promise(resolve => setTimeout(resolve, 50)); // Short wait for test countdown
        
        expect(roundManager.getCurrentRound()).toBe(1);
        expect(roundManager.isActive()).toBe(true);
        
        // End round 1
        roundManager.endRound();
        
        // Verify round is not active and transition is pending
        expect(roundManager.isActive()).toBe(false);
        expect((roundManager as any).roundTransitionPending).toBe(true);
        expect(roundManager.getCurrentRound()).toBe(1); // Should still be round 1
        
        // Try to start next round immediately - should not work
        roundManager.startRound();
        expect(roundManager.getCurrentRound()).toBe(1); // Should still be round 1
        expect(roundManager.isActive()).toBe(false);
        
        // Wait for transition time
        await new Promise(resolve => setTimeout(resolve, TEST_TRANSITION_DURATION + 20));
        
        // Now round 2 should be starting or active
        expect(roundManager.getCurrentRound()).toBeGreaterThan(1);
    });
});

================
File: src/__tests__/round-scoring.test.ts
================
import { ScoreManager } from '../managers/score-manager';
import { describe, test, expect, beforeEach } from '@jest/globals';

describe('Round-based Scoring', () => {
  let scoreManager: ScoreManager;
  const player1Id = 'player1';
  const player2Id = 'player2';
  const player3Id = 'player3';

  beforeEach(() => {
    scoreManager = new ScoreManager();
    // Initialize multiple players for testing
    scoreManager.initializePlayer(player1Id);
    scoreManager.initializePlayer(player2Id);
    scoreManager.initializePlayer(player3Id);
  });

  test('should track round scores separately from total scores', () => {
    scoreManager.addScore(player1Id, 10);
    expect(scoreManager.getScore(player1Id)).toBe(10);
    expect(scoreManager.getRoundScore(player1Id)).toBe(10);

    // Start new round should reset round score but keep total
    scoreManager.startNewRound();
    expect(scoreManager.getScore(player1Id)).toBe(0); // Total score resets at start of round
    expect(scoreManager.getRoundScore(player1Id)).toBe(0);
  });

  test('should handle round end with correct placements', () => {
    // Add different scores for each player
    scoreManager.addScore(player1Id, 30);
    scoreManager.addScore(player2Id, 20);
    scoreManager.addScore(player3Id, 10);

    const { winnerId, placements } = scoreManager.handleRoundEnd();

    // Check winner
    expect(winnerId).toBe(player1Id);

    // Check placements (3 players, so points should be 3,2,1)
    expect(placements).toHaveLength(3);
    expect(placements[0]).toEqual({ playerId: player1Id, points: 3 });
    expect(placements[1]).toEqual({ playerId: player2Id, points: 2 });
    expect(placements[2]).toEqual({ playerId: player3Id, points: 1 });
  });

  test('should accumulate placement points across rounds', () => {
    // Round 1
    scoreManager.addScore(player1Id, 30);
    scoreManager.addScore(player2Id, 20);
    scoreManager.addScore(player3Id, 10);
    scoreManager.handleRoundEnd();

    // Round 2 - different order
    scoreManager.startNewRound();
    scoreManager.addScore(player2Id, 40);
    scoreManager.addScore(player3Id, 30);
    scoreManager.addScore(player1Id, 20);
    const { placements } = scoreManager.handleRoundEnd();

    // Player 1: 3 + 1 = 4 points
    // Player 2: 2 + 3 = 5 points
    // Player 3: 1 + 2 = 3 points
    const player1Stats = (scoreManager as any).playerStats.get(player1Id);
    const player2Stats = (scoreManager as any).playerStats.get(player2Id);
    const player3Stats = (scoreManager as any).playerStats.get(player3Id);

    expect(player1Stats.placementPoints).toBe(4);
    expect(player2Stats.placementPoints).toBe(5);
    expect(player3Stats.placementPoints).toBe(3);
  });

  test('should track wins correctly', () => {
    // Round 1 - Player 1 wins
    scoreManager.addScore(player1Id, 30);
    scoreManager.addScore(player2Id, 20);
    scoreManager.handleRoundEnd();

    // Round 2 - Player 1 wins again
    scoreManager.startNewRound();
    scoreManager.addScore(player1Id, 40);
    scoreManager.addScore(player2Id, 30);
    scoreManager.handleRoundEnd();

    expect(scoreManager.getWins(player1Id)).toBe(2);
    expect(scoreManager.getWins(player2Id)).toBe(0);
  });

  test('should reset all stats including wins and placement points', () => {
    // Add some scores and end round
    scoreManager.addScore(player1Id, 30);
    scoreManager.addScore(player2Id, 20);
    scoreManager.handleRoundEnd();

    // Reset all stats
    scoreManager.resetAllStats();

    // Check everything is reset
    expect(scoreManager.getScore(player1Id)).toBe(0);
    expect(scoreManager.getRoundScore(player1Id)).toBe(0);
    expect(scoreManager.getWins(player1Id)).toBe(0);
    
    const player1Stats = (scoreManager as any).playerStats.get(player1Id);
    expect(player1Stats.placementPoints).toBe(0);
    expect(player1Stats.consecutiveHits).toBe(0);
    expect(player1Stats.multiHitCount).toBe(0);
  });

  test('should handle ties in round scoring correctly', () => {
    // Create a tie between player1 and player2
    scoreManager.addScore(player1Id, 20);
    scoreManager.addScore(player2Id, 20);
    scoreManager.addScore(player3Id, 10);

    const { winnerId, placements } = scoreManager.handleRoundEnd();

    // First player in should win the tie
    expect(winnerId).toBe(player1Id);
    
    // Both tied players should get the higher placement points
    expect(placements[0].points).toBe(3); // player1
    expect(placements[1].points).toBe(3); // player2
    expect(placements[2].points).toBe(1); // player3
  });

  test('should maintain round continuity when players leave and rejoin', () => {
    // Start with initial players
    scoreManager.addScore(player1Id, 30);
    scoreManager.addScore(player2Id, 20);
    const round1Result = scoreManager.handleRoundEnd();
    expect(round1Result.winnerId).toBe(player1Id);

    // Start new round
    scoreManager.startNewRound();
    
    // Simulate player2 leaving (remove their stats)
    scoreManager.removePlayer(player2Id);
    
    // Add scores for remaining player
    scoreManager.addScore(player1Id, 25);
    const round2Result = scoreManager.handleRoundEnd();
    expect(round2Result.winnerId).toBe(player1Id);

    // Start another round
    scoreManager.startNewRound();
    
    // Simulate player2 rejoining
    scoreManager.initializePlayer(player2Id);
    
    // Add scores in new order
    scoreManager.addScore(player2Id, 40);
    scoreManager.addScore(player1Id, 30);
    const round3Result = scoreManager.handleRoundEnd();
    
    // Check that player2's rejoin didn't affect round counting
    expect(round3Result.winnerId).toBe(player2Id);
    expect(scoreManager.getWins(player1Id)).toBe(2); // Should have won rounds 1 and 2
    expect(scoreManager.getWins(player2Id)).toBe(1); // Should have won round 3
  });
});

================
File: src/__tests__/score-manager.test.ts
================
import { ScoreManager } from '../managers/score-manager';
import { mock, describe, test, expect, beforeEach } from 'bun:test';

describe('ScoreManager', () => {
  let scoreManager: ScoreManager;
  const playerId = 'player1';

  beforeEach(() => {
    scoreManager = new ScoreManager();
    scoreManager.initializePlayer(playerId);
  });

  test('initial score is 0', () => {
    expect(scoreManager.getScore(playerId)).toBe(0);
  });

  test('adding positive score increments the score', () => {
    scoreManager.addScore(playerId, 10);
    expect(scoreManager.getScore(playerId)).toBe(10);
  });

  test('adding negative score decrements the score', () => {
    scoreManager.addScore(playerId, -5);
    expect(scoreManager.getScore(playerId)).toBe(-5);
  });

  test('resetting score sets the score to 0', () => {
    scoreManager.addScore(playerId, 20);
    scoreManager.resetScore(playerId);
    expect(scoreManager.getScore(playerId)).toBe(0);
  });

  test('removing a player deletes their score', () => {
    scoreManager.addScore(playerId, 15);
    scoreManager.removePlayer(playerId);
    expect(scoreManager.getScore(playerId)).toBe(0); // returns 0 if player is no longer initialized
  });

  // New test for block break event
  test('player breaking a block awards points', () => {
    // Assume breaking a block should give 5 points in score
    const blockBreakScore = 5;
    scoreManager.addScore(playerId, blockBreakScore); // simulate block break event awarding points
    expect(scoreManager.getScore(playerId)).toBe(blockBreakScore);
  });
});

describe('Combo System', () => {
  let scoreManager: ScoreManager;
  const playerId = 'player1';
  let mockPlayer: any;

  beforeEach(() => {
    // Create ScoreManager
    scoreManager = new ScoreManager();
    scoreManager.initializePlayer(playerId);

    // Set up player stats with combo
    const stats = (scoreManager as any).playerStats.get(playerId);
    stats.consecutiveHits = 0;
    stats.multiHitCount = 0;
    (scoreManager as any).playerStats.set(playerId, stats);
  });

  test('should reset combo when explicitly called', () => {
    const stats = (scoreManager as any).playerStats.get(playerId);
    stats.consecutiveHits = 5;
    stats.multiHitCount = 2;
    (scoreManager as any).playerStats.set(playerId, stats);

    scoreManager.resetCombo(playerId);

    const updatedStats = (scoreManager as any).playerStats.get(playerId);
    expect(updatedStats.consecutiveHits).toBe(0);
    expect(updatedStats.multiHitCount).toBe(0);
  });

  test('should handle resetting combo for non-existent player', () => {
    // Should not throw error
    expect(() => {
      scoreManager.resetCombo('nonexistent-player');
    }).not.toThrow();
  });

  test('should maintain combo state across multiple resets', () => {
    const stats = (scoreManager as any).playerStats.get(playerId);
    stats.consecutiveHits = 5;
    stats.multiHitCount = 2;
    (scoreManager as any).playerStats.set(playerId, stats);

    // Reset multiple times
    scoreManager.resetCombo(playerId);
    scoreManager.resetCombo(playerId);
    scoreManager.resetCombo(playerId);

    const finalStats = (scoreManager as any).playerStats.get(playerId);
    expect(finalStats.consecutiveHits).toBe(0);
    expect(finalStats.multiHitCount).toBe(0);
  });
});

================
File: src/config/particle-config.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DESTRUCTION_PARTICLE_CONFIG = void 0;
exports.DESTRUCTION_PARTICLE_CONFIG = {
    COUNT: 16,
    SCALE: 0.1, // Size of each particle
    LIFETIME: 750, // How long particles exist (ms) - increased and rounded for consistency
    SPREAD_RADIUS: 0.3, // Initial spread distance
    SPEED: 0.1, // Reduced base movement speed for more stability
    PHYSICS: {
        MASS: 0.5, // Increased mass for more stability
        FRICTION: 0.3, // Increased friction to prevent excessive sliding
        BOUNCINESS: 0.3, // Reduced bounciness for more predictable behavior
        SLEEP_THRESHOLD: 0.02, // Increased sleep threshold
        ANGULAR_SLEEP_THRESHOLD: 0.02
    },
    FORCES: {
        UPWARD_MIN: 0.1, // Reduced minimum upward force
        UPWARD_MAX: 0.3, // Reduced maximum upward force
        SPIN_STRENGTH: 0.15, // Reduced spin for more stability
        EXPLOSION_MULTIPLIER: 0.5 // Reduced explosion force
    },
    SPAWN: {
        RADIUS: 0.2, // Random spawn radius
        HEIGHT_VARIATION: 0.2 // Random height variation
    },
    POOLING: {
        POOL_SIZE: 300,
        MIN_POOL_SIZE: 100
    },
    INSTANCING: {
        BATCH_SIZE: 50, // Number of particles to batch render
        ENABLE_MERGING: true, // Merge nearby particle meshes
        MERGE_DISTANCE: 2.0, // Distance threshold for merging
        GPU_INSTANCING: true // Use GPU instancing when available
    },
    DISTANCE_SCALING: {
        ENABLED: true,
        FAR_DISTANCE: 30,
        FAR_SCALE: 0.2,
        MEDIUM_DISTANCE: 20,
        MEDIUM_SCALE: 0.5
    }
};

================
File: src/config/particle-config.ts
================
import { Vector3Like } from 'hytopia';

export interface ParticleConfig {
  COUNT: number;
  SCALE: number;
  LIFETIME: number;
  SPREAD_RADIUS: number;
  SPEED: number;
  PHYSICS: {
    MASS: number;
    FRICTION: number;
    BOUNCINESS: number;
    SLEEP_THRESHOLD?: number;
    ANGULAR_SLEEP_THRESHOLD?: number;
  };
  FORCES: {
    UPWARD_MIN: number;
    UPWARD_MAX: number;
    SPIN_STRENGTH: number;
    EXPLOSION_MULTIPLIER: number;
  };
  SPAWN: {
    RADIUS: number;
    HEIGHT_VARIATION: number;
  };
  POOLING: {
    POOL_SIZE: number;
    MIN_POOL_SIZE: number;
  };
  INSTANCING: {
    BATCH_SIZE: number;
    ENABLE_MERGING: boolean;
    MERGE_DISTANCE: number;
    GPU_INSTANCING: boolean;
  };
  DISTANCE_SCALING: {
    ENABLED: boolean;
    FAR_DISTANCE: number;
    FAR_SCALE: number;
    MEDIUM_DISTANCE: number;
    MEDIUM_SCALE: number;
  };
}

export const DESTRUCTION_PARTICLE_CONFIG: ParticleConfig = {
  COUNT: 16,
  SCALE: 0.1,             // Size of each particle
  LIFETIME: 750,           // How long particles exist (ms) - increased and rounded for consistency
  SPREAD_RADIUS: 0.3,      // Initial spread distance
  SPEED: 0.1,            // Reduced base movement speed for more stability
  PHYSICS: {
    MASS: 0.5,            // Increased mass for more stability
    FRICTION: 0.3,        // Increased friction to prevent excessive sliding
    BOUNCINESS: 0.3,      // Reduced bounciness for more predictable behavior
    SLEEP_THRESHOLD: 0.02, // Increased sleep threshold
    ANGULAR_SLEEP_THRESHOLD: 0.02
  },
  FORCES: {
    UPWARD_MIN: 0.1,      // Reduced minimum upward force
    UPWARD_MAX: 0.3,      // Reduced maximum upward force
    SPIN_STRENGTH: 0.15,   // Reduced spin for more stability
    EXPLOSION_MULTIPLIER: 0.5  // Reduced explosion force
  },
  SPAWN: {
    RADIUS: 0.2,          // Random spawn radius
    HEIGHT_VARIATION: 0.2  // Random height variation
  },
  POOLING: {
    POOL_SIZE: 300,
    MIN_POOL_SIZE: 100
  },
  INSTANCING: {
    BATCH_SIZE: 50,    // Number of particles to batch render
    ENABLE_MERGING: true,  // Merge nearby particle meshes
    MERGE_DISTANCE: 2.0,   // Distance threshold for merging
    GPU_INSTANCING: true   // Use GPU instancing when available
  },
  DISTANCE_SCALING: {
    ENABLED: true,
    FAR_DISTANCE: 30,
    FAR_SCALE: 0.2,
    MEDIUM_DISTANCE: 20,
    MEDIUM_SCALE: 0.5
  }
};

================
File: src/effects/block-particle-effects.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockParticleEffects = void 0;
var hytopia_1 = require("hytopia");
var particle_config_1 = require("../config/particle-config");
var BlockParticleEffects = /** @class */ (function () {
    // Add world parameter to constructor
    function BlockParticleEffects(world) {
        var _this = this;
        this.activeParticles = new Set(); // Use Set for faster lookups/removal
        this.particlePool = [];
        this.spatialGrid = new Map();
        this.pendingEffects = [];
        this.cleanupInterval = null;
        this.particleSpawnTimes = new Map();
        // Use TypedArrays for particle properties
        this.particlePositions = new Float32Array(particle_config_1.DESTRUCTION_PARTICLE_CONFIG.POOLING.POOL_SIZE * 3);
        this.particleVelocities = new Float32Array(particle_config_1.DESTRUCTION_PARTICLE_CONFIG.POOLING.POOL_SIZE * 3);
        this.particleLifetimes = new Float32Array(particle_config_1.DESTRUCTION_PARTICLE_CONFIG.POOLING.POOL_SIZE);
        this.performanceMetrics = {
            lastFrameTime: 0,
            frameCount: 0,
            averageFrameTime: 16,
            particleReductionFactor: 1.0
        };
        this.world = world;
        // Start the cleanup interval
        this.cleanupInterval = setInterval(function () { return _this.forceCleanupParticles(); }, 5000); // Check every 5 seconds
    }
    BlockParticleEffects.prototype.forceCleanupParticles = function () {
        var _this = this;
        var now = Date.now();
        this.activeParticles.forEach(function (particle) {
            if (!particle.isSpawned) {
                _this.activeParticles.delete(particle);
                _this.particleSpawnTimes.delete(particle);
                return;
            }
            // Force despawn particles that are:
            // 1. Below a certain height (on the ground)
            // 2. Haven't moved in a while
            // 3. Have been alive for too long
            var spawnTime = _this.particleSpawnTimes.get(particle) || now;
            if (particle.position.y < 0.2 || // On ground
                (particle.rawRigidBody && particle.rawRigidBody.isAsleep()) || // Not moving
                (now - spawnTime > 2000)) { // Alive too long (2 seconds)
                _this.returnParticleToPool(particle);
            }
        });
    };
    // Update getInstance to accept world parameter
    BlockParticleEffects.getInstance = function (world) {
        if (!BlockParticleEffects.instance && world) {
            BlockParticleEffects.instance = new BlockParticleEffects(world);
        }
        return BlockParticleEffects.instance;
    };
    BlockParticleEffects.prototype.getParticleFromPool = function (world, blockTextureUri) {
        var _a, _b, _c, _d;
        var particle = this.particlePool.pop();
        if (!particle) {
            // Create new particle if pool is empty
            particle = new hytopia_1.Entity({
                name: 'DestroyedBlockPiece',
                blockTextureUri: blockTextureUri,
                blockHalfExtents: {
                    x: particle_config_1.DESTRUCTION_PARTICLE_CONFIG.SCALE,
                    y: particle_config_1.DESTRUCTION_PARTICLE_CONFIG.SCALE,
                    z: particle_config_1.DESTRUCTION_PARTICLE_CONFIG.SCALE
                },
                rigidBodyOptions: {
                    type: hytopia_1.RigidBodyType.DYNAMIC,
                    colliders: [{
                            shape: hytopia_1.ColliderShape.BLOCK,
                            halfExtents: {
                                x: particle_config_1.DESTRUCTION_PARTICLE_CONFIG.SCALE,
                                y: particle_config_1.DESTRUCTION_PARTICLE_CONFIG.SCALE,
                                z: particle_config_1.DESTRUCTION_PARTICLE_CONFIG.SCALE
                            },
                            mass: particle_config_1.DESTRUCTION_PARTICLE_CONFIG.PHYSICS.MASS,
                            friction: particle_config_1.DESTRUCTION_PARTICLE_CONFIG.PHYSICS.FRICTION,
                            bounciness: particle_config_1.DESTRUCTION_PARTICLE_CONFIG.PHYSICS.BOUNCINESS
                        }]
                }
            });
            // If the engine supports setting sleep thresholds through the raw rigid body
            if (particle.rawRigidBody) {
                try {
                    // Attempt to set sleep thresholds if the underlying physics engine supports it
                    (_b = (_a = particle.rawRigidBody).setSleepThreshold) === null || _b === void 0 ? void 0 : _b.call(_a, particle_config_1.DESTRUCTION_PARTICLE_CONFIG.PHYSICS.SLEEP_THRESHOLD);
                    (_d = (_c = particle.rawRigidBody).setAngularSleepThreshold) === null || _d === void 0 ? void 0 : _d.call(_c, particle_config_1.DESTRUCTION_PARTICLE_CONFIG.PHYSICS.ANGULAR_SLEEP_THRESHOLD);
                }
                catch (e) {
                    // Silently fail if these methods aren't available
                }
            }
        }
        // Track spawn time
        this.particleSpawnTimes.set(particle, Date.now());
        return particle;
    };
    BlockParticleEffects.prototype.returnParticleToPool = function (particle) {
        if (particle.isSpawned) {
            particle.despawn(); // Make sure to despawn first
        }
        this.activeParticles.delete(particle);
        this.particleSpawnTimes.delete(particle);
        if (this.particlePool.length < particle_config_1.DESTRUCTION_PARTICLE_CONFIG.POOLING.POOL_SIZE) {
            this.particlePool.push(particle);
        }
    };
    BlockParticleEffects.prototype.getParticleCount = function (playerPosition, explosionPosition) {
        var distance = Math.sqrt(Math.pow(playerPosition.x - explosionPosition.x, 2) +
            Math.pow(playerPosition.y - explosionPosition.y, 2) +
            Math.pow(playerPosition.z - explosionPosition.z, 2));
        // Reduce particles based on distance
        if (distance > 30)
            return Math.floor(particle_config_1.DESTRUCTION_PARTICLE_CONFIG.COUNT * 0.2); // 20% at far distance
        if (distance > 20)
            return Math.floor(particle_config_1.DESTRUCTION_PARTICLE_CONFIG.COUNT * 0.5); // 50% at medium distance
        return particle_config_1.DESTRUCTION_PARTICLE_CONFIG.COUNT; // 100% when close
    };
    BlockParticleEffects.prototype.getGridKey = function (position) {
        // 5x5x5 grid cells
        var gridX = Math.floor(position.x / 5);
        var gridY = Math.floor(position.y / 5);
        var gridZ = Math.floor(position.z / 5);
        return "".concat(gridX, ",").concat(gridY, ",").concat(gridZ);
    };
    BlockParticleEffects.prototype.updateParticleGrid = function (particle) {
        var gridKey = this.getGridKey(particle.position);
        if (!this.spatialGrid.has(gridKey)) {
            this.spatialGrid.set(gridKey, new Set());
        }
        this.spatialGrid.get(gridKey).add(particle);
    };
    BlockParticleEffects.prototype.createDestructionEffect = function (world, position, blockTextureUri) {
        var _this = this;
        if (!world)
            return;
        // Pre-calculate some values to avoid repeated calculations
        var angleIncrement = (Math.PI * 2) / particle_config_1.DESTRUCTION_PARTICLE_CONFIG.COUNT;
        var speed = particle_config_1.DESTRUCTION_PARTICLE_CONFIG.SPEED * particle_config_1.DESTRUCTION_PARTICLE_CONFIG.FORCES.EXPLOSION_MULTIPLIER;
        var spinForce = particle_config_1.DESTRUCTION_PARTICLE_CONFIG.FORCES.SPIN_STRENGTH;
        var _loop_1 = function (i) {
            var particle = this_1.getParticleFromPool(world, blockTextureUri);
            var angle = angleIncrement * i;
            // Calculate position with less random calls
            var offsetX = (Math.random() - 0.5) * particle_config_1.DESTRUCTION_PARTICLE_CONFIG.SPAWN.RADIUS;
            var offsetY = (Math.random() - 0.5) * particle_config_1.DESTRUCTION_PARTICLE_CONFIG.SPAWN.HEIGHT_VARIATION;
            var offsetZ = (Math.random() - 0.5) * particle_config_1.DESTRUCTION_PARTICLE_CONFIG.SPAWN.RADIUS;
            particle.spawn(world, {
                x: position.x + offsetX,
                y: position.y + offsetY,
                z: position.z + offsetZ
            });
            this_1.activeParticles.add(particle);
            if (particle.rawRigidBody) {
                // Apply forces with fewer calculations
                var speedVariation = 0.8 + Math.random() * 0.4;
                particle.rawRigidBody.applyImpulse({
                    x: Math.cos(angle) * speed * speedVariation,
                    y: particle_config_1.DESTRUCTION_PARTICLE_CONFIG.FORCES.UPWARD_MIN +
                        Math.random() * (particle_config_1.DESTRUCTION_PARTICLE_CONFIG.FORCES.UPWARD_MAX - particle_config_1.DESTRUCTION_PARTICLE_CONFIG.FORCES.UPWARD_MIN),
                    z: Math.sin(angle) * speed * speedVariation
                });
                // Simplified spin calculation
                var spin = (Math.random() - 0.5) * spinForce;
                particle.rawRigidBody.applyTorqueImpulse({
                    x: spin,
                    y: spin,
                    z: spin
                });
            }
            // Force cleanup after lifetime
            setTimeout(function () {
                if (_this.activeParticles.has(particle)) {
                    _this.returnParticleToPool(particle);
                }
            }, particle_config_1.DESTRUCTION_PARTICLE_CONFIG.LIFETIME);
        };
        var this_1 = this;
        // Batch creation to reduce overhead
        for (var i = 0; i < particle_config_1.DESTRUCTION_PARTICLE_CONFIG.COUNT; i++) {
            _loop_1(i);
        }
    };
    BlockParticleEffects.prototype.processEffectQueue = function (deltaTime) {
        var startTime = performance.now();
        while (this.pendingEffects.length > 0) {
            if (performance.now() - startTime > BlockParticleEffects.FRAME_BUDGET_MS) {
                // Defer remaining effects to next frame
                break;
            }
            var effect = this.pendingEffects.shift();
            if (effect) {
                this.createImmediateEffect(effect.position, effect.texture);
            }
        }
    };
    BlockParticleEffects.prototype.updatePerformanceMetrics = function (currentTime) {
        var frameTime = currentTime - this.performanceMetrics.lastFrameTime;
        this.performanceMetrics.frameCount++;
        // Update rolling average
        this.performanceMetrics.averageFrameTime =
            (this.performanceMetrics.averageFrameTime * 0.95) + (frameTime * 0.05);
        // Adjust particle count based on performance
        if (this.performanceMetrics.averageFrameTime > 16.6) { // Below 60fps
            this.performanceMetrics.particleReductionFactor *= 0.95;
        }
        else if (this.performanceMetrics.averageFrameTime < 14) { // Above 70fps
            this.performanceMetrics.particleReductionFactor =
                Math.min(1.0, this.performanceMetrics.particleReductionFactor * 1.05);
        }
        this.performanceMetrics.lastFrameTime = currentTime;
    };
    BlockParticleEffects.prototype.cleanup = function () {
        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
            this.cleanupInterval = null;
        }
        // Force cleanup all particles
        this.activeParticles.forEach(function (particle) {
            if (particle.isSpawned) {
                particle.despawn();
            }
        });
        this.activeParticles.clear();
        this.particlePool = [];
        this.spatialGrid.clear();
        this.particleSpawnTimes.clear();
        // Clear typed arrays
        this.particlePositions = new Float32Array(particle_config_1.DESTRUCTION_PARTICLE_CONFIG.POOLING.POOL_SIZE * 3);
        this.particleVelocities = new Float32Array(particle_config_1.DESTRUCTION_PARTICLE_CONFIG.POOLING.POOL_SIZE * 3);
        this.particleLifetimes = new Float32Array(particle_config_1.DESTRUCTION_PARTICLE_CONFIG.POOLING.POOL_SIZE);
    };
    BlockParticleEffects.prototype.createImmediateEffect = function (position, texture) {
        if (this.world) {
            this.createDestructionEffect(this.world, position, texture);
        }
    };
    BlockParticleEffects.FRAME_BUDGET_MS = 16; // 60fps target
    return BlockParticleEffects;
}());
exports.BlockParticleEffects = BlockParticleEffects;

================
File: src/effects/block-particle-effects.ts
================
import { Entity, Vector3Like, RigidBodyType, ColliderShape, World } from 'hytopia';
import { DESTRUCTION_PARTICLE_CONFIG } from '../config/particle-config';

export class BlockParticleEffects {
  private activeParticles: Set<Entity> = new Set(); // Use Set for faster lookups/removal
  private particlePool: Entity[] = [];
  private static instance: BlockParticleEffects; // Singleton pattern
  private spatialGrid: Map<string, Set<Entity>> = new Map();
  private static readonly FRAME_BUDGET_MS = 16; // 60fps target
  private pendingEffects: Array<{position: Vector3Like, texture: string}> = [];
  private readonly world: World;
  private cleanupInterval: NodeJS.Timeout | null = null;
  private particleSpawnTimes = new Map<Entity, number>();

  // Use TypedArrays for particle properties
  private particlePositions = new Float32Array(DESTRUCTION_PARTICLE_CONFIG.POOLING.POOL_SIZE * 3);
  private particleVelocities = new Float32Array(DESTRUCTION_PARTICLE_CONFIG.POOLING.POOL_SIZE * 3);
  private particleLifetimes = new Float32Array(DESTRUCTION_PARTICLE_CONFIG.POOLING.POOL_SIZE);

  private performanceMetrics = {
    lastFrameTime: 0,
    frameCount: 0,
    averageFrameTime: 16,
    particleReductionFactor: 1.0
  };

  // Add world parameter to constructor
  private constructor(world: World) {
    this.world = world;
    // Start the cleanup interval
    this.cleanupInterval = setInterval(() => this.forceCleanupParticles(), 5000); // Check every 5 seconds
  }

  private forceCleanupParticles(): void {
    const now = Date.now();
    this.activeParticles.forEach(particle => {
      if (!particle.isSpawned) {
        this.activeParticles.delete(particle);
        this.particleSpawnTimes.delete(particle);
        return;
      }

      // Force despawn particles that are:
      // 1. Below a certain height (on the ground)
      // 2. Haven't moved in a while
      // 3. Have been alive for too long
      const spawnTime = this.particleSpawnTimes.get(particle) || now;
      if (particle.position.y < 0.2 || // On ground
          (particle.rawRigidBody && particle.rawRigidBody.isAsleep()) || // Not moving
          (now - spawnTime > 2000)) { // Alive too long (2 seconds)
        
        this.returnParticleToPool(particle);
      }
    });
  }

  // Update getInstance to accept world parameter
  public static getInstance(world?: World): BlockParticleEffects {
    if (!BlockParticleEffects.instance && world) {
      BlockParticleEffects.instance = new BlockParticleEffects(world);
    }
    return BlockParticleEffects.instance;
  }

  private getParticleFromPool(world: World, blockTextureUri: string): Entity {
    let particle = this.particlePool.pop();
    
    if (!particle) {
      // Create new particle if pool is empty
      particle = new Entity({
        name: 'DestroyedBlockPiece',
        blockTextureUri,
        blockHalfExtents: {
          x: DESTRUCTION_PARTICLE_CONFIG.SCALE,
          y: DESTRUCTION_PARTICLE_CONFIG.SCALE,
          z: DESTRUCTION_PARTICLE_CONFIG.SCALE
        },
        rigidBodyOptions: {
          type: RigidBodyType.DYNAMIC,
          colliders: [{
            shape: ColliderShape.BLOCK,
            halfExtents: {
              x: DESTRUCTION_PARTICLE_CONFIG.SCALE,
              y: DESTRUCTION_PARTICLE_CONFIG.SCALE,
              z: DESTRUCTION_PARTICLE_CONFIG.SCALE
            },
            mass: DESTRUCTION_PARTICLE_CONFIG.PHYSICS.MASS,
            friction: DESTRUCTION_PARTICLE_CONFIG.PHYSICS.FRICTION,
            bounciness: DESTRUCTION_PARTICLE_CONFIG.PHYSICS.BOUNCINESS
          }]
        }
      });

      // If the engine supports setting sleep thresholds through the raw rigid body
      if (particle.rawRigidBody) {
        try {
          // Attempt to set sleep thresholds if the underlying physics engine supports it
          particle.rawRigidBody.setSleepThreshold?.(DESTRUCTION_PARTICLE_CONFIG.PHYSICS.SLEEP_THRESHOLD);
          particle.rawRigidBody.setAngularSleepThreshold?.(DESTRUCTION_PARTICLE_CONFIG.PHYSICS.ANGULAR_SLEEP_THRESHOLD);
        } catch (e) {
          // Silently fail if these methods aren't available
        }
      }
    }

    // Track spawn time
    this.particleSpawnTimes.set(particle, Date.now());
    return particle;
  }

  private returnParticleToPool(particle: Entity): void {
    if (particle.isSpawned) {
      particle.despawn(); // Make sure to despawn first
    }
    this.activeParticles.delete(particle);
    this.particleSpawnTimes.delete(particle);
    if (this.particlePool.length < DESTRUCTION_PARTICLE_CONFIG.POOLING.POOL_SIZE) {
      this.particlePool.push(particle);
    }
  }

  private getParticleCount(playerPosition: Vector3Like, explosionPosition: Vector3Like): number {
    const distance = Math.sqrt(
      Math.pow(playerPosition.x - explosionPosition.x, 2) +
      Math.pow(playerPosition.y - explosionPosition.y, 2) +
      Math.pow(playerPosition.z - explosionPosition.z, 2)
    );
    
    // Reduce particles based on distance
    if (distance > 30) return Math.floor(DESTRUCTION_PARTICLE_CONFIG.COUNT * 0.2);  // 20% at far distance
    if (distance > 20) return Math.floor(DESTRUCTION_PARTICLE_CONFIG.COUNT * 0.5);  // 50% at medium distance
    return DESTRUCTION_PARTICLE_CONFIG.COUNT; // 100% when close
  }

  private getGridKey(position: Vector3Like): string {
    // 5x5x5 grid cells
    const gridX = Math.floor(position.x / 5);
    const gridY = Math.floor(position.y / 5);
    const gridZ = Math.floor(position.z / 5);
    return `${gridX},${gridY},${gridZ}`;
  }

  private updateParticleGrid(particle: Entity): void {
    const gridKey = this.getGridKey(particle.position);
    if (!this.spatialGrid.has(gridKey)) {
      this.spatialGrid.set(gridKey, new Set());
    }
    this.spatialGrid.get(gridKey)!.add(particle);
  }

  createDestructionEffect(world: World, position: Vector3Like, blockTextureUri: string): void {
    if (!world) return;

    // Pre-calculate some values to avoid repeated calculations
    const angleIncrement = (Math.PI * 2) / DESTRUCTION_PARTICLE_CONFIG.COUNT;
    const speed = DESTRUCTION_PARTICLE_CONFIG.SPEED * DESTRUCTION_PARTICLE_CONFIG.FORCES.EXPLOSION_MULTIPLIER;
    const spinForce = DESTRUCTION_PARTICLE_CONFIG.FORCES.SPIN_STRENGTH;

    // Batch creation to reduce overhead
    for (let i = 0; i < DESTRUCTION_PARTICLE_CONFIG.COUNT; i++) {
      const particle = this.getParticleFromPool(world, blockTextureUri);
      const angle = angleIncrement * i;

      // Calculate position with less random calls
      const offsetX = (Math.random() - 0.5) * DESTRUCTION_PARTICLE_CONFIG.SPAWN.RADIUS;
      const offsetY = (Math.random() - 0.5) * DESTRUCTION_PARTICLE_CONFIG.SPAWN.HEIGHT_VARIATION;
      const offsetZ = (Math.random() - 0.5) * DESTRUCTION_PARTICLE_CONFIG.SPAWN.RADIUS;

      particle.spawn(world, {
        x: position.x + offsetX,
        y: position.y + offsetY,
        z: position.z + offsetZ
      });

      this.activeParticles.add(particle);

      if (particle.rawRigidBody) {
        // Apply forces with fewer calculations
        const speedVariation = 0.8 + Math.random() * 0.4;
        particle.rawRigidBody.applyImpulse({
          x: Math.cos(angle) * speed * speedVariation,
          y: DESTRUCTION_PARTICLE_CONFIG.FORCES.UPWARD_MIN + 
             Math.random() * (DESTRUCTION_PARTICLE_CONFIG.FORCES.UPWARD_MAX - DESTRUCTION_PARTICLE_CONFIG.FORCES.UPWARD_MIN),
          z: Math.sin(angle) * speed * speedVariation
        });

        // Simplified spin calculation
        const spin = (Math.random() - 0.5) * spinForce;
        particle.rawRigidBody.applyTorqueImpulse({
          x: spin,
          y: spin,
          z: spin
        });
      }

      // Force cleanup after lifetime
      setTimeout(() => {
        if (this.activeParticles.has(particle)) {
          this.returnParticleToPool(particle);
        }
      }, DESTRUCTION_PARTICLE_CONFIG.LIFETIME);
    }
  }

  private processEffectQueue(deltaTime: number): void {
    const startTime = performance.now();
    while (this.pendingEffects.length > 0) {
      if (performance.now() - startTime > BlockParticleEffects.FRAME_BUDGET_MS) {
        // Defer remaining effects to next frame
        break;
      }
      const effect = this.pendingEffects.shift();
      if (effect) {
        this.createImmediateEffect(effect.position, effect.texture);
      }
    }
  }

  private updatePerformanceMetrics(currentTime: number): void {
    const frameTime = currentTime - this.performanceMetrics.lastFrameTime;
    this.performanceMetrics.frameCount++;
    
    // Update rolling average
    this.performanceMetrics.averageFrameTime = 
      (this.performanceMetrics.averageFrameTime * 0.95) + (frameTime * 0.05);
      
    // Adjust particle count based on performance
    if (this.performanceMetrics.averageFrameTime > 16.6) { // Below 60fps
      this.performanceMetrics.particleReductionFactor *= 0.95;
    } else if (this.performanceMetrics.averageFrameTime < 14) { // Above 70fps
      this.performanceMetrics.particleReductionFactor = 
        Math.min(1.0, this.performanceMetrics.particleReductionFactor * 1.05);
    }
    
    this.performanceMetrics.lastFrameTime = currentTime;
  }

  cleanup(): void {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
    
    // Force cleanup all particles
    this.activeParticles.forEach(particle => {
      if (particle.isSpawned) {
        particle.despawn();
      }
    });
    this.activeParticles.clear();
    this.particlePool = [];
    this.spatialGrid.clear();
    this.particleSpawnTimes.clear();
    
    // Clear typed arrays
    this.particlePositions = new Float32Array(DESTRUCTION_PARTICLE_CONFIG.POOLING.POOL_SIZE * 3);
    this.particleVelocities = new Float32Array(DESTRUCTION_PARTICLE_CONFIG.POOLING.POOL_SIZE * 3);
    this.particleLifetimes = new Float32Array(DESTRUCTION_PARTICLE_CONFIG.POOLING.POOL_SIZE);
  }

  private createImmediateEffect(position: Vector3Like, texture: string): void {
    if (this.world) {
      this.createDestructionEffect(this.world, position, texture);
    }
  }
}

================
File: src/entities/projectile-entity.js
================
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectileEntity = void 0;
var hytopia_1 = require("hytopia");
var moving_block_entity_1 = require("../moving_blocks/moving-block-entity");
var block_particle_effects_1 = require("../effects/block-particle-effects");
var score_manager_1 = require("../managers/score-manager");
var ProjectileEntity = /** @class */ (function (_super) {
    __extends(ProjectileEntity, _super);
    function ProjectileEntity(options) {
        var _a, _b, _c, _d;
        var _this = _super.call(this, __assign(__assign({}, options), { name: options.name || 'Projectile', modelUri: options.modelUri || ProjectileEntity.PREVIEW.MARKER_URI, modelScale: options.modelScale || 0.5 })) || this;
        _this.trajectoryMarkers = [];
        _this.onTick = function (entity, deltaTimeMs) {
            if (Date.now() - _this.spawnTime > _this.lifetime) {
                _this.explode();
                _this.despawn();
            }
        };
        _this.speed = (_a = options.speed) !== null && _a !== void 0 ? _a : ProjectileEntity.PHYSICS.DEFAULT_SPEED;
        _this.lifetime = (_b = options.lifetime) !== null && _b !== void 0 ? _b : ProjectileEntity.PHYSICS.DEFAULT_LIFETIME;
        _this.damage = (_c = options.damage) !== null && _c !== void 0 ? _c : ProjectileEntity.PHYSICS.DEFAULT_DAMAGE;
        _this.spawnTime = Date.now();
        _this.raycastHandler = options.raycastHandler;
        _this.enablePreview = (_d = options.enablePreview) !== null && _d !== void 0 ? _d : true;
        _this.playerId = options.playerId;
        return _this;
    }
    ProjectileEntity.prototype.validateTrajectory = function (direction) {
        if (!this.raycastHandler || !this.isSpawned)
            return true;
        // Normalize direction for accurate distance checking
        var magnitude = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);
        if (magnitude === 0)
            return false;
        var normalizedDir = {
            x: direction.x / magnitude,
            y: direction.y / magnitude,
            z: direction.z / magnitude
        };
        // Check if there's any immediate obstruction in the trajectory
        var raycastResult = this.raycastHandler.raycast(this.position, normalizedDir, ProjectileEntity.PHYSICS.TRAJECTORY_CHECK_DISTANCE, {
            filterExcludeRigidBody: this.rawRigidBody
        });
        // If we hit something very close, the trajectory is not valid
        if (raycastResult && raycastResult.hitDistance < ProjectileEntity.PHYSICS.MIN_SPAWN_DISTANCE) {
            return false;
        }
        return true;
    };
    ProjectileEntity.prototype.spawn = function (world, position) {
        var _this = this;
        // Store spawn origin before any position adjustments
        this.spawnOrigin = __assign({}, position);
        // Get the player's look direction (assuming it's passed in the options)
        var lookDir = this.rotation || { x: 0, y: 0, z: 1 };
        // Adjust spawn position to be lower and slightly forward
        var adjustedPosition = {
            x: position.x + (lookDir.x * ProjectileEntity.PHYSICS.SPAWN_FORWARD_OFFSET),
            y: position.y + ProjectileEntity.PHYSICS.SPAWN_HEIGHT_OFFSET,
            z: position.z + (lookDir.z * ProjectileEntity.PHYSICS.SPAWN_FORWARD_OFFSET)
        };
        // Only adjust if world has raycast capability
        if ('raycast' in world) {
            // Check in all directions for nearby blocks
            for (var _i = 0, _a = ProjectileEntity.SPAWN_CHECK_DIRECTIONS; _i < _a.length; _i++) {
                var direction = _a[_i];
                var raycastResult = world.raycast(adjustedPosition, direction, 1.5);
                if (raycastResult && raycastResult.distance < ProjectileEntity.PHYSICS.MIN_SPAWN_DISTANCE) {
                    // Move away from the block in the opposite direction
                    adjustedPosition.x += -direction.x * (ProjectileEntity.PHYSICS.MIN_SPAWN_DISTANCE - raycastResult.distance);
                    adjustedPosition.y += -direction.y * (ProjectileEntity.PHYSICS.MIN_SPAWN_DISTANCE - raycastResult.distance);
                    adjustedPosition.z += -direction.z * (ProjectileEntity.PHYSICS.MIN_SPAWN_DISTANCE - raycastResult.distance);
                }
            }
        }
        _super.prototype.spawn.call(this, world, adjustedPosition);
        if (!this.isSpawned) {
            throw new Error('ProjectileEntity.spawn(): Entity failed to spawn!');
        }
        // Configure collider for solid physics interaction
        this.createAndAddChildCollider({
            shape: hytopia_1.ColliderShape.BALL,
            radius: ProjectileEntity.PHYSICS.COLLIDER_RADIUS,
            isSensor: false,
            mass: ProjectileEntity.PHYSICS.MASS,
            collisionGroups: {
                belongsTo: [hytopia_1.CollisionGroup.ENTITY],
                collidesWith: [hytopia_1.CollisionGroup.BLOCK, hytopia_1.CollisionGroup.ENTITY]
            },
            bounciness: ProjectileEntity.PHYSICS.BOUNCINESS,
            friction: ProjectileEntity.PHYSICS.FRICTION,
            onCollision: function (other, started) {
                if (!started)
                    return;
                // Prevent multiple collision handling for the same projectile
                if (!_this.isSpawned)
                    return;
                if (other instanceof moving_block_entity_1.MovingBlockEntity) {
                    // Moving block collision - despawn immediately
                    _this.despawn();
                }
                else if (typeof other === 'number') {
                    // Block collision
                    var hitPosition = _this.position;
                    _this.despawn();
                }
                else if (other instanceof ProjectileEntity) {
                    // Projectile-projectile collision - let physics handle the bouncing
                    // No need to despawn, just let them bounce naturally
                    if (_this.rawRigidBody && other.rawRigidBody) {
                        // Apply a small damping on collision to prevent endless bouncing
                        _this.rawRigidBody.setLinearDamping(0.3);
                        other.rawRigidBody.setLinearDamping(0.3);
                    }
                }
                else if (other instanceof hytopia_1.PlayerEntity) {
                    // Player collision - just despawn without applying physics
                    _this.despawn();
                }
            }
        });
        if (this.rawRigidBody) {
            this.rawRigidBody.enableCcd(true);
            this.rawRigidBody.setLinearDamping(ProjectileEntity.PHYSICS.LINEAR_DAMPING);
            this.rawRigidBody.setAngularDamping(0.3);
            // Add initial rotation to make sides face the player
            // Rotate 90 degrees around the Z axis
            var initialRotation = {
                x: 0,
                y: 0,
                z: 0.7071068, // Changed from Y to Z axis rotation
                w: 0.7071068
            };
            this.rawRigidBody.setRotation(initialRotation);
        }
    };
    ProjectileEntity.prototype.throw = function (direction) {
        if (!this.rawRigidBody)
            return;
        // Normalize direction properly
        var magnitude = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);
        if (magnitude === 0)
            return;
        var normalizedDir = {
            x: direction.x / magnitude,
            y: direction.y / magnitude,
            z: direction.z / magnitude
        };
        // Prevent throwing if looking too far down
        if (normalizedDir.y < ProjectileEntity.PHYSICS.MAX_DOWN_ANGLE) {
            this.despawn();
            return;
        }
        // Validate trajectory before throwing
        if (!this.validateTrajectory(normalizedDir)) {
            this.despawn();
            return;
        }
        var impulse = {
            x: normalizedDir.x * this.speed,
            y: normalizedDir.y * this.speed + ProjectileEntity.PHYSICS.UPWARD_ARC,
            z: normalizedDir.z * this.speed
        };
        this.rawRigidBody.applyImpulse(impulse);
        // Calculate the perpendicular axis for forward rolling motion
        var crossProduct = {
            x: -normalizedDir.z,
            y: 0,
            z: normalizedDir.x
        };
        // Reduced torque multiplier by 66%
        var torque = {
            x: crossProduct.x * 0.14, // Reduced from 1.0 to 0.33
            y: 0,
            z: crossProduct.z * 0.14 // Reduced from 1.0 to 0.33
        };
        this.rawRigidBody.applyTorqueImpulse(torque);
    };
    /**
     * Predicts the trajectory of the projectile and returns an array of points
     * along with collision information.
     */
    ProjectileEntity.prototype.predictTrajectory = function (direction) {
        if (!this.raycastHandler || !this.isSpawned)
            return [];
        var points = [];
        var currentPos = __assign({}, this.position);
        // Calculate initial velocity based on direction and speed
        var magnitude = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);
        if (magnitude === 0)
            return points;
        var normalizedDir = {
            x: direction.x / magnitude,
            y: direction.y / magnitude,
            z: direction.z / magnitude
        };
        // Initial velocity including the upward arc
        var velocity = {
            x: normalizedDir.x * this.speed,
            y: normalizedDir.y * this.speed + 1.0, // Same upward arc as in throw()
            z: normalizedDir.z * this.speed
        };
        // Predict trajectory points
        for (var i = 0; i < ProjectileEntity.PREVIEW.TRAJECTORY_STEPS; i++) {
            // Calculate next position based on current velocity
            var nextPos = {
                x: currentPos.x + velocity.x * ProjectileEntity.PREVIEW.TIME_STEP,
                y: currentPos.y + velocity.y * ProjectileEntity.PREVIEW.TIME_STEP,
                z: currentPos.z + velocity.z * ProjectileEntity.PREVIEW.TIME_STEP
            };
            // Calculate direction to next point
            var dirToNext = {
                x: nextPos.x - currentPos.x,
                y: nextPos.y - currentPos.y,
                z: nextPos.z - currentPos.z
            };
            // Get the distance to the next point
            var distance = Math.sqrt(dirToNext.x * dirToNext.x +
                dirToNext.y * dirToNext.y +
                dirToNext.z * dirToNext.z);
            // Normalize direction
            if (distance > 0) {
                dirToNext.x /= distance;
                dirToNext.y /= distance;
                dirToNext.z /= distance;
            }
            // Check for collisions along the path
            var raycastResult = this.raycastHandler.raycast(currentPos, dirToNext, distance, { filterExcludeRigidBody: this.rawRigidBody });
            if (raycastResult) {
                // Collision detected
                points.push({
                    position: raycastResult.hitPoint,
                    isCollision: true,
                    hitDistance: raycastResult.hitDistance
                });
                break;
            }
            else {
                // No collision, add the point
                points.push({
                    position: __assign({}, currentPos),
                    isCollision: false
                });
            }
            // Update position and velocity for next iteration
            currentPos = nextPos;
            // Apply gravity to Y velocity
            velocity.y -= ProjectileEntity.PHYSICS.GRAVITY * ProjectileEntity.PREVIEW.TIME_STEP;
        }
        return points;
    };
    /**
     * Cleans up all trajectory markers
     */
    ProjectileEntity.prototype.clearTrajectoryMarkers = function () {
        this.trajectoryMarkers.forEach(function (marker) {
            if (marker.isSpawned) {
                marker.despawn();
            }
        });
        this.trajectoryMarkers = [];
    };
    /**
     * Shows visual preview of the predicted trajectory if enabled
     */
    ProjectileEntity.prototype.showTrajectoryPreview = function (direction) {
        if (!this.enablePreview || !this.world || !this.raycastHandler)
            return;
        // Clear any existing trajectory markers
        this.clearTrajectoryMarkers();
        var points = this.predictTrajectory(direction);
        // Find the collision point
        var collisionPoint = points.find(function (point) { return point.isCollision; });
        if (collisionPoint) {
            // Only create/update a single marker at the predicted impact point
            if (this.trajectoryMarkers.length === 0) {
                var marker = new hytopia_1.Entity({
                    name: 'ImpactMarker',
                    modelUri: ProjectileEntity.PREVIEW.MARKER_URI,
                    modelScale: ProjectileEntity.PREVIEW.MARKER_SCALE,
                    opacity: ProjectileEntity.PREVIEW.MARKER_OPACITY
                });
                this.trajectoryMarkers.push(marker);
                marker.spawn(this.world, collisionPoint.position);
            }
            else {
                // Update existing marker position
                var marker = this.trajectoryMarkers[0];
                if (marker.isSpawned) {
                    marker.setPosition(collisionPoint.position);
                }
            }
        }
        else {
            // No collision point found, clear any existing markers
            this.clearTrajectoryMarkers();
        }
    };
    // Override despawn to ensure we clean up trajectory markers
    ProjectileEntity.prototype.despawn = function () {
        this.clearTrajectoryMarkers();
        _super.prototype.despawn.call(this);
    };
    ProjectileEntity.prototype.explode = function () {
        if (!this.isSpawned)
            return;
        // Reset combo when projectile expires without hitting anything
        if (this.playerId && this.world) {
            var scoreManager = this.world.entityManager.getAllEntities()
                .find(function (entity) { return entity instanceof score_manager_1.ScoreManager; });
            if (scoreManager) {
                scoreManager.resetCombo(this.playerId);
            }
        }
    };
    ProjectileEntity.prototype.onImpact = function () {
        if (!this.world)
            return;
        var particleSystem = block_particle_effects_1.BlockParticleEffects.getInstance(this.world);
        if (this.position && this.blockTextureUri) {
            particleSystem.createDestructionEffect(this.world, this.position, this.blockTextureUri);
        }
    };
    ProjectileEntity.prototype.handleCollision = function (other) {
        // ... existing collision code ...
        if (this.onCollision && this.position && this.blockTextureUri) {
            this.onCollision(this.position, this.blockTextureUri);
        }
        this.onImpact(); // Call onImpact when collision occurs
        // ... rest of collision handling
    };
    // Add getter for spawn origin
    ProjectileEntity.prototype.getSpawnOrigin = function () {
        return this.spawnOrigin ? __assign({}, this.spawnOrigin) : undefined;
    };
    // Physics constants adjusted to match TF2 grenade launcher
    ProjectileEntity.PHYSICS = {
        GRAVITY: 15.24, // TF2's 800 HU/s² converted to m/s²
        DEFAULT_SPEED: 20.00, // TF2's 1216 HU/s converted to m/s
        DEFAULT_LIFETIME: 2300, // 2.3 seconds fuse timer
        DEFAULT_DAMAGE: 10, // Typical TF2 grenade damage
        UPWARD_ARC: 1.0, // Reduced to match TF2's arc
        COLLIDER_RADIUS: 0.2, // Smaller radius for grenades
        MASS: 0.5, // Increased mass for better physics
        BOUNCINESS: 0.65, // TF2's grenade bounce factor
        FRICTION: 0.3, // Lower friction for better rolling
        LINEAR_DAMPING: 0.05, // Reduced damping for longer rolls
        MIN_SPAWN_DISTANCE: 1.0,
        TRAJECTORY_CHECK_DISTANCE: 2.0,
        MAX_DOWN_ANGLE: -0.85,
        SPEED_LOSS_PER_BOUNCE: 0.35, // 35% speed loss per bounce
        SPAWN_HEIGHT_OFFSET: -1.0, // Meters below eye level (adjust as needed)
        SPAWN_FORWARD_OFFSET: -0.5, // Meters forward from player (adjust as needed)
    };
    // Trajectory preview constants
    ProjectileEntity.PREVIEW = {
        TRAJECTORY_STEPS: 10,
        TIME_STEP: 0.1,
        MARKER_URI: 'models/projectiles/energy-orb-projectile.gltf',
        MARKER_SCALE: 0.3,
        MARKER_OPACITY: 0.7
    };
    ProjectileEntity.SPAWN_CHECK_DIRECTIONS = [
        { x: 0, y: -1, z: 0 }, // Down
        { x: 0, y: 1, z: 0 }, // Up
        { x: 1, y: 0, z: 0 }, // Right
        { x: -1, y: 0, z: 0 }, // Left
        { x: 0, y: 0, z: 1 }, // Forward
        { x: 0, y: 0, z: -1 }, // Back
    ];
    return ProjectileEntity;
}(hytopia_1.Entity));
exports.ProjectileEntity = ProjectileEntity;

================
File: src/entities/projectile-entity.ts
================
import { Entity, EntityOptions, Vector3Like, ColliderShape, CollisionGroup, BlockType, World, PlayerEntity, EntityEvent } from 'hytopia';
import { MovingBlockEntity } from '../moving_blocks/moving-block-entity';
import { RaycastHandler } from '../raycast/raycast-handler';
import { BlockParticleEffects } from '../effects/block-particle-effects';
import { ScoreManager } from '../managers/score-manager';

export interface ProjectileOptions extends EntityOptions {
    speed?: number;
    lifetime?: number;
    damage?: number;
    raycastHandler?: RaycastHandler;
    enablePreview?: boolean;
    playerId?: string;
}

interface TrajectoryPoint {
    position: Vector3Like;
    isCollision: boolean;
    hitDistance?: number;
}

export class ProjectileEntity extends Entity {
    // Physics constants adjusted to match TF2 grenade launcher
    private static readonly PHYSICS = {
        GRAVITY: 15.24,           // TF2's 800 HU/s² converted to m/s²
        DEFAULT_SPEED: 20.00,     // TF2's 1216 HU/s converted to m/s
        DEFAULT_LIFETIME: 2300,    // 2.3 seconds fuse timer
        DEFAULT_DAMAGE: 10,       // Typical TF2 grenade damage
        UPWARD_ARC: 1.0,          // Reduced to match TF2's arc
        COLLIDER_RADIUS: 0.2,     // Smaller radius for grenades
        MASS: 0.5,                // Increased mass for better physics
        BOUNCINESS: 0.65,         // TF2's grenade bounce factor
        FRICTION: 0.3,            // Lower friction for better rolling
        LINEAR_DAMPING: 0.05,     // Reduced damping for longer rolls
        MIN_SPAWN_DISTANCE: 1.0,
        TRAJECTORY_CHECK_DISTANCE: 2.0,
        MAX_DOWN_ANGLE: -0.85,
        SPEED_LOSS_PER_BOUNCE: 0.35,  // 35% speed loss per bounce
        SPAWN_HEIGHT_OFFSET: -1.0,  // Meters below eye level (adjust as needed)
        SPAWN_FORWARD_OFFSET: -0.5,  // Meters forward from player (adjust as needed)
    } as const;

    // Trajectory preview constants
    private static readonly PREVIEW = {
        TRAJECTORY_STEPS: 10,
        TIME_STEP: 0.1,
        MARKER_URI: 'models/projectiles/energy-orb-projectile.gltf',
        MARKER_SCALE: 0.3,
        MARKER_OPACITY: 0.7
    } as const;

    private speed: number;
    private lifetime: number;
    private damage: number;
    private spawnTime: number;
    private raycastHandler?: RaycastHandler;
    private enablePreview: boolean;
    private static readonly SPAWN_CHECK_DIRECTIONS = [
        { x: 0, y: -1, z: 0 },  // Down
        { x: 0, y: 1, z: 0 },   // Up
        { x: 1, y: 0, z: 0 },   // Right
        { x: -1, y: 0, z: 0 },  // Left
        { x: 0, y: 0, z: 1 },   // Forward
        { x: 0, y: 0, z: -1 },  // Back
    ];
    private trajectoryMarkers: Entity[] = [];
    public readonly playerId?: string;
    public onCollision?: (position: Vector3Like, blockTextureUri: string) => void;
    private spawnOrigin?: Vector3Like;

    constructor(options: ProjectileOptions) {
        super({
            ...options,
            name: options.name || 'Projectile',
            modelUri: options.modelUri || ProjectileEntity.PREVIEW.MARKER_URI,
            modelScale: options.modelScale || 0.5
        });

        this.speed = options.speed ?? ProjectileEntity.PHYSICS.DEFAULT_SPEED;
        this.lifetime = options.lifetime ?? ProjectileEntity.PHYSICS.DEFAULT_LIFETIME;
        this.damage = options.damage ?? ProjectileEntity.PHYSICS.DEFAULT_DAMAGE;
        this.spawnTime = Date.now();
        this.raycastHandler = options.raycastHandler;
        this.enablePreview = options.enablePreview ?? true;
        this.playerId = options.playerId;
        
        // Register for tick events using the event system
        this.on(EntityEvent.TICK, ({ tickDeltaMs }) => {
            if (Date.now() - this.spawnTime > this.lifetime) {
                this.explode();
                this.despawn();
            }
        });
    }

    private validateTrajectory(direction: Vector3Like): boolean {
        if (!this.raycastHandler || !this.isSpawned) return true;

        // Normalize direction for accurate distance checking
        const magnitude = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);
        if (magnitude === 0) return false;

        const normalizedDir = {
            x: direction.x / magnitude,
            y: direction.y / magnitude,
            z: direction.z / magnitude
        };

        // Check if there's any immediate obstruction in the trajectory
        const raycastResult = this.raycastHandler.raycast(
            this.position,
            normalizedDir,
            ProjectileEntity.PHYSICS.TRAJECTORY_CHECK_DISTANCE,
            {
                filterExcludeRigidBody: this.rawRigidBody
            }
        );

        // If we hit something very close, the trajectory is not valid
        if (raycastResult && raycastResult.hitDistance < ProjectileEntity.PHYSICS.MIN_SPAWN_DISTANCE) {
            return false;
        }

        return true;
    }

    spawn(world: World, position: Vector3Like): void {
        // Store spawn origin before any position adjustments
        this.spawnOrigin = { ...position };

        // Get the player's look direction (assuming it's passed in the options)
        const lookDir = this.rotation || { x: 0, y: 0, z: 1 };
        
        // Adjust spawn position to be lower and slightly forward
        const adjustedPosition = { 
            x: position.x + (lookDir.x * ProjectileEntity.PHYSICS.SPAWN_FORWARD_OFFSET),
            y: position.y + ProjectileEntity.PHYSICS.SPAWN_HEIGHT_OFFSET,
            z: position.z + (lookDir.z * ProjectileEntity.PHYSICS.SPAWN_FORWARD_OFFSET)
        };
        
        // Only adjust if world has raycast capability
        if ('raycast' in world) {
            // Check in all directions for nearby blocks
            for (const direction of ProjectileEntity.SPAWN_CHECK_DIRECTIONS) {
                const raycastResult = (world as any).raycast(adjustedPosition, direction, 1.5);
                if (raycastResult && raycastResult.distance < ProjectileEntity.PHYSICS.MIN_SPAWN_DISTANCE) {
                    // Move away from the block in the opposite direction
                    adjustedPosition.x += -direction.x * (ProjectileEntity.PHYSICS.MIN_SPAWN_DISTANCE - raycastResult.distance);
                    adjustedPosition.y += -direction.y * (ProjectileEntity.PHYSICS.MIN_SPAWN_DISTANCE - raycastResult.distance);
                    adjustedPosition.z += -direction.z * (ProjectileEntity.PHYSICS.MIN_SPAWN_DISTANCE - raycastResult.distance);
                }
            }
        }

        super.spawn(world, adjustedPosition);

        if (!this.isSpawned) {
            throw new Error('ProjectileEntity.spawn(): Entity failed to spawn!');
        }

        // Lifetime checks are handled automatically by the onTick method from the engine's tick system

        // Configure collider for solid physics interaction
        this.createAndAddChildCollider({
            shape: ColliderShape.BALL,
            radius: ProjectileEntity.PHYSICS.COLLIDER_RADIUS,
            isSensor: false,
            mass: ProjectileEntity.PHYSICS.MASS,
            collisionGroups: {
                belongsTo: [CollisionGroup.ENTITY],
                collidesWith: [CollisionGroup.BLOCK, CollisionGroup.ENTITY]
            },
            bounciness: ProjectileEntity.PHYSICS.BOUNCINESS,
            friction: ProjectileEntity.PHYSICS.FRICTION,
            onCollision: (other: Entity | BlockType, started: boolean) => {
                if (!started) return;
                
                // Prevent multiple collision handling for the same projectile
                if (!this.isSpawned) return;
                
                if (other instanceof MovingBlockEntity) {
                    // Moving block collision - despawn immediately
                    this.despawn();
                } else if (typeof other === 'number') {
                    // Block collision
                    const hitPosition = this.position;
                    this.despawn();
                } else if (other instanceof ProjectileEntity) {
                    // Projectile-projectile collision - let physics handle the bouncing
                    // No need to despawn, just let them bounce naturally
                    if (this.rawRigidBody && other.rawRigidBody) {
                        // Apply a small damping on collision to prevent endless bouncing
                        this.rawRigidBody.setLinearDamping(0.3);
                        other.rawRigidBody.setLinearDamping(0.3);
                    }
                } else if (other instanceof PlayerEntity) {
                    // Player collision - just despawn without applying physics
                    this.despawn();
                }
            }
        });

        if (this.rawRigidBody) {
            this.rawRigidBody.enableCcd(true);
            this.rawRigidBody.setLinearDamping(ProjectileEntity.PHYSICS.LINEAR_DAMPING);
            this.rawRigidBody.setAngularDamping(0.3);
            
            // Add initial rotation to make sides face the player
            // Rotate 90 degrees around the Z axis
            const initialRotation = {
                x: 0,
                y: 0,
                z: 0.7071068,  // Changed from Y to Z axis rotation
                w: 0.7071068
            };
            this.rawRigidBody.setRotation(initialRotation);
        }
    }

    // This is a special property that Hytopia's Entity class recognizes

    throw(direction: Vector3Like): void {
        if (!this.rawRigidBody) return;

        // Normalize direction properly
        const magnitude = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);
        if (magnitude === 0) return;

        const normalizedDir = {
            x: direction.x / magnitude,
            y: direction.y / magnitude,
            z: direction.z / magnitude
        };

        // Prevent throwing if looking too far down
        if (normalizedDir.y < ProjectileEntity.PHYSICS.MAX_DOWN_ANGLE) {
            this.despawn();
            return;
        }

        // Validate trajectory before throwing
        if (!this.validateTrajectory(normalizedDir)) {
            this.despawn();
            return;
        }

        const impulse = {
            x: normalizedDir.x * this.speed,
            y: normalizedDir.y * this.speed + ProjectileEntity.PHYSICS.UPWARD_ARC,
            z: normalizedDir.z * this.speed
        };
        
        this.rawRigidBody.applyImpulse(impulse);
        
        // Calculate the perpendicular axis for forward rolling motion
        const crossProduct = {
            x: -normalizedDir.z,
            y: 0,
            z: normalizedDir.x
        };
        
        // Reduced torque multiplier by 66%
        const torque = {
            x: crossProduct.x * 0.14,  // Reduced from 1.0 to 0.33
            y: 0,
            z: crossProduct.z * 0.14   // Reduced from 1.0 to 0.33
        };
        this.rawRigidBody.applyTorqueImpulse(torque);
    }

    /**
     * Predicts the trajectory of the projectile and returns an array of points
     * along with collision information.
     */
    predictTrajectory(direction: Vector3Like): TrajectoryPoint[] {
        if (!this.raycastHandler || !this.isSpawned) return [];

        const points: TrajectoryPoint[] = [];
        let currentPos = { ...this.position };
        
        // Calculate initial velocity based on direction and speed
        const magnitude = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);
        if (magnitude === 0) return points;

        const normalizedDir = {
            x: direction.x / magnitude,
            y: direction.y / magnitude,
            z: direction.z / magnitude
        };

        // Initial velocity including the upward arc
        let velocity = {
            x: normalizedDir.x * this.speed,
            y: normalizedDir.y * this.speed + 1.0, // Same upward arc as in throw()
            z: normalizedDir.z * this.speed
        };

        // Predict trajectory points
        for (let i = 0; i < ProjectileEntity.PREVIEW.TRAJECTORY_STEPS; i++) {
            // Calculate next position based on current velocity
            const nextPos = {
                x: currentPos.x + velocity.x * ProjectileEntity.PREVIEW.TIME_STEP,
                y: currentPos.y + velocity.y * ProjectileEntity.PREVIEW.TIME_STEP,
                z: currentPos.z + velocity.z * ProjectileEntity.PREVIEW.TIME_STEP
            };

            // Calculate direction to next point
            const dirToNext = {
                x: nextPos.x - currentPos.x,
                y: nextPos.y - currentPos.y,
                z: nextPos.z - currentPos.z
            };

            // Get the distance to the next point
            const distance = Math.sqrt(
                dirToNext.x * dirToNext.x +
                dirToNext.y * dirToNext.y +
                dirToNext.z * dirToNext.z
            );

            // Normalize direction
            if (distance > 0) {
                dirToNext.x /= distance;
                dirToNext.y /= distance;
                dirToNext.z /= distance;
            }

            // Check for collisions along the path
            const raycastResult = this.raycastHandler.raycast(
                currentPos,
                dirToNext,
                distance,
                { filterExcludeRigidBody: this.rawRigidBody }
            );

            if (raycastResult) {
                // Collision detected
                points.push({
                    position: raycastResult.hitPoint,
                    isCollision: true,
                    hitDistance: raycastResult.hitDistance
                });
                break;
            } else {
                // No collision, add the point
                points.push({
                    position: { ...currentPos },
                    isCollision: false
                });
            }

            // Update position and velocity for next iteration
            currentPos = nextPos;
            // Apply gravity to Y velocity
            velocity.y -= ProjectileEntity.PHYSICS.GRAVITY * ProjectileEntity.PREVIEW.TIME_STEP;
        }

        return points;
    }

    /**
     * Cleans up all trajectory markers
     */
    public clearTrajectoryMarkers(): void {
        this.trajectoryMarkers.forEach(marker => {
            if (marker.isSpawned) {
                marker.despawn();
            }
        });
        this.trajectoryMarkers = [];
    }

    /**
     * Shows visual preview of the predicted trajectory if enabled
     */
    showTrajectoryPreview(direction: Vector3Like): void {
        if (!this.enablePreview || !this.world || !this.raycastHandler) return;

        // Clear any existing trajectory markers
        this.clearTrajectoryMarkers();

        const points = this.predictTrajectory(direction);
        
        // Find the collision point
        const collisionPoint = points.find(point => point.isCollision);
        if (collisionPoint) {
            // Only create/update a single marker at the predicted impact point
            if (this.trajectoryMarkers.length === 0) {
                const marker = new Entity({
                    name: 'ImpactMarker',
                    modelUri: ProjectileEntity.PREVIEW.MARKER_URI,
                    modelScale: ProjectileEntity.PREVIEW.MARKER_SCALE,
                    opacity: ProjectileEntity.PREVIEW.MARKER_OPACITY
                });
                this.trajectoryMarkers.push(marker);
                marker.spawn(this.world, collisionPoint.position);
            } else {
                // Update existing marker position
                const marker = this.trajectoryMarkers[0];
                if (marker.isSpawned) {
                    marker.setPosition(collisionPoint.position);
                }
            }
        } else {
            // No collision point found, clear any existing markers
            this.clearTrajectoryMarkers();
        }
    }

    // Override despawn to ensure we clean up trajectory markers
    override despawn(): void {
        this.clearTrajectoryMarkers();
        super.despawn();
    }

    private explode(): void {
        if (!this.isSpawned) return;
        
        // Reset combo when projectile expires without hitting anything
        if (this.playerId && this.world) {
            const scoreManager = this.world.entityManager.getAllEntities()
                .find(entity => entity instanceof ScoreManager) as ScoreManager;
            if (scoreManager) {
                scoreManager.resetCombo(this.playerId);
            }
        }
    }

    private onImpact(): void {
        if (!this.world) return;
        
        const particleSystem = BlockParticleEffects.getInstance(this.world);
        
        if (this.position && this.blockTextureUri) {
            particleSystem.createDestructionEffect(
                this.world,
                this.position,
                this.blockTextureUri
            );
        }
    }

    protected handleCollision(other: Entity): void {
        // ... existing collision code ...
        
        if (this.onCollision && this.position && this.blockTextureUri) {
            this.onCollision(this.position, this.blockTextureUri);
        }
        
        this.onImpact(); // Call onImpact when collision occurs
        
        // ... rest of collision handling
    }

    // Add getter for spawn origin
    public getSpawnOrigin(): Vector3Like | undefined {
        return this.spawnOrigin ? { ...this.spawnOrigin } : undefined;
    }
}

================
File: src/entities/README.md
================
# Projectile Entity

## Current Features

### Core Functionality
- Handles individual projectile physics and behavior
- Manages projectile lifecycle (spawn, throw, despawn)
- Provides trajectory preview system
- Handles collision detection and response

### Physics & Movement
- Realistic projectile motion with gravity
- Collision detection with blocks and other entities
- Continuous Collision Detection (CCD) for high-speed projectiles
- Configurable speed and trajectory

### Visual Features
- Customizable model and scale
- Trajectory preview markers
- Impact point visualization
- Proper cleanup of visual elements

### Collision System
- Block collision handling
- Entity collision detection
- Bounce physics with configurable parameters
- Safe collision cleanup

## Potential Future Enhancements

### Visual Effects
1. **Trail Effects**
   ```typescript
   interface TrailOptions {
     type: 'particle' | 'ribbon';
     color: string;
     duration: number;
     width: number;
   }
   ```
   - Particle trails
   - Light effects
   - Color variations based on type
   - Impact effects

2. **Animation System**
   - Rotation during flight
   - Impact animations
   - Charge-up effects
   - Despawn animations

### Physics Behaviors
1. **Advanced Movement**
   ```typescript
   interface MovementModifiers {
     drag: number;
     windEffect: number;
     magnetism: number;
     bounceCount: number;
   }
   ```
   - Air resistance
   - Wind influence
   - Magnetic properties
   - Multiple bounces

2. **Special Behaviors**
   - Homing capabilities
   - Split on impact
   - Area of effect on collision
   - Penetration through targets

### Damage System
1. **Damage Types**
   ```typescript
   interface DamageProfile {
     base: number;
     type: 'physical' | 'explosive' | 'energy';
     radius?: number;
     falloff?: 'linear' | 'quadratic';
   }
   ```
   - Different damage types
   - Area damage
   - Damage falloff
   - Status effects

2. **Impact Effects**
   - Knockback
   - Stun effects
   - Damage over time
   - Shield penetration

### Technical Features
1. **Performance**
   - Object pooling system
   - Batch rendering
   - Level of detail system
   - Optimized collision checks

2. **Network Optimization**
   ```typescript
   interface NetworkConfig {
     interpolation: boolean;
     predictionSteps: number;
     updateRate: number;
   }
   ```
   - Position interpolation
   - Client-side prediction
   - Efficient state updates

### Special Properties
1. **Environmental Interaction**
   - Water physics
   - Material-based bouncing
   - Temperature effects
   - Light emission

2. **Projectile Modifiers**
   - Size changes during flight
   - Splitting projectiles
   - Merging projectiles
   - Time-based effects

## Integration Points
- Works with PlayerProjectileManager for state management
- Can be extended for different weapon systems
- Integrates with physics and collision systems
- Can be part of particle and effect systems

## Best Practices for Extensions
1. **Performance Considerations**
   - Use object pooling for frequent spawning
   - Optimize collision checks
   - Manage visual effects carefully
   - Clean up resources properly

2. **Code Organization**
   - Keep behavior modules separate
   - Use composition over inheritance
   - Implement clear interfaces
   - Document complex physics calculations

3. **Visual Guidelines**
   - Consistent effect scaling
   - Clear visual feedback
   - Performance-conscious effects
   - Readable trajectory previews

4. **Physics Guidelines**
   - Balance realism vs gameplay
   - Consider network impact
   - Implement proper cleanup
   - Handle edge cases gracefully

================
File: src/managers/audio-manager.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AudioManager = void 0;
var hytopia_1 = require("hytopia");
var AudioManager = /** @class */ (function () {
    function AudioManager(world) {
        this.sfxVolume = 0.5;
        this.bgmVolume = 0.08; // Slightly lower default volume for Battle Maggots
        this.world = world;
    }
    AudioManager.getInstance = function (world) {
        if (!AudioManager.instance) {
            AudioManager.instance = new AudioManager(world);
        }
        return AudioManager.instance;
    };
    AudioManager.prototype.playBackgroundMusic = function () {
        try {
            // If we already have background music, just update its volume
            if (this.backgroundMusic) {
                var actualVolume = this.bgmVolume === 0 ? 0 : this.bgmVolume;
                this.backgroundMusic.setVolume(actualVolume);
                console.log("Background music volume updated to: ".concat(actualVolume));
                return;
            }
            // Create new background music instance
            this.backgroundMusic = new hytopia_1.Audio({
                uri: 'audio/music/Battle Maggots loop.mp3',
                loop: true,
                volume: this.bgmVolume,
            });
            // Play the music and log success
            this.backgroundMusic.play(this.world);
            console.log("Background music started with volume: ".concat(this.bgmVolume));
        }
        catch (error) {
            console.error('Failed to initialize background music:', error);
            this.backgroundMusic = undefined;
        }
    };
    AudioManager.prototype.setBgmVolume = function (volume) {
        // Update the stored volume
        this.bgmVolume = Math.max(0, Math.min(1, volume));
        // Try to update the actual audio instance
        try {
            // Always try to initialize music if it doesn't exist
            if (!this.backgroundMusic) {
                this.playBackgroundMusic();
                return;
            }
            // Update volume of existing background music
            // Ensure we're setting exactly 0 when muting
            var actualVolume = this.bgmVolume === 0 ? 0 : this.bgmVolume;
            this.backgroundMusic.setVolume(actualVolume);
            console.log("Background music volume set to: ".concat(actualVolume));
        }
        catch (error) {
            console.error('Error setting background music volume:', error);
        }
    };
    AudioManager.prototype.getBgmVolume = function () {
        return this.bgmVolume;
    };
    AudioManager.prototype.playSoundEffect = function (sfxPath, volume) {
        if (volume === void 0) { volume = this.sfxVolume; }
        var sfx = new hytopia_1.Audio({
            uri: sfxPath,
            loop: false,
            volume: volume,
        });
        sfx.play(this.world);
    };
    AudioManager.prototype.playRandomSoundEffect = function (sfxPaths, volume) {
        if (volume === void 0) { volume = this.sfxVolume; }
        var randomIndex = Math.floor(Math.random() * sfxPaths.length);
        this.playSoundEffect(sfxPaths[randomIndex], volume);
    };
    AudioManager.prototype.setSfxVolume = function (volume) {
        this.sfxVolume = Math.max(0, Math.min(1, volume));
    };
    AudioManager.prototype.cleanup = function () {
        try {
            if (this.backgroundMusic) {
                this.backgroundMusic.setVolume(0);
            }
        }
        catch (error) {
            console.error('Error during audio cleanup:', error);
        }
        this.backgroundMusic = undefined;
    };
    return AudioManager;
}());
exports.AudioManager = AudioManager;

================
File: src/managers/audio-manager.ts
================
import { World, Audio } from 'hytopia';

export class AudioManager {
    private static instance: AudioManager;
    private world: World;
    private backgroundMusic?: Audio;
    private sfxVolume: number = 0.5;
    private bgmVolume: number = 0.08; // Slightly lower default volume for Battle Maggots

    private constructor(world: World) {
        this.world = world;
    }

    public static getInstance(world: World): AudioManager {
        if (!AudioManager.instance) {
            AudioManager.instance = new AudioManager(world);
        }
        return AudioManager.instance;
    }

    public playBackgroundMusic(): void {
        try {
            // If we already have background music, just update its volume
            if (this.backgroundMusic) {
                const actualVolume = this.bgmVolume === 0 ? 0 : this.bgmVolume;
                this.backgroundMusic.setVolume(actualVolume);
                console.log(`Background music volume updated to: ${actualVolume}`);
                return;
            }

            // Create new background music instance
            this.backgroundMusic = new Audio({
                uri: 'audio/music/Battle Maggots loop.mp3',
                loop: true,
                volume: this.bgmVolume,
            });

            // Play the music and log success
            this.backgroundMusic.play(this.world);
            console.log(`Background music started with volume: ${this.bgmVolume}`);
        } catch (error) {
            console.error('Failed to initialize background music:', error);
            this.backgroundMusic = undefined;
        }
    }

    public setBgmVolume(volume: number): void {
        // Update the stored volume
        this.bgmVolume = Math.max(0, Math.min(1, volume));
        
        // Try to update the actual audio instance
        try {
            // Always try to initialize music if it doesn't exist
            if (!this.backgroundMusic) {
                this.playBackgroundMusic();
                return;
            }

            // Update volume of existing background music
            // Ensure we're setting exactly 0 when muting
            const actualVolume = this.bgmVolume === 0 ? 0 : this.bgmVolume;
            this.backgroundMusic.setVolume(actualVolume);
            console.log(`Background music volume set to: ${actualVolume}`);
        } catch (error) {
            console.error('Error setting background music volume:', error);
        }
    }

    public getBgmVolume(): number {
        return this.bgmVolume;
    }

    public playSoundEffect(sfxPath: string, volume: number = this.sfxVolume): void {
        const sfx = new Audio({
            uri: sfxPath,
            loop: false,
            volume: volume,
        });
        sfx.play(this.world);
    }

    public playRandomSoundEffect(sfxPaths: string[], volume: number = this.sfxVolume): void {
        const randomIndex = Math.floor(Math.random() * sfxPaths.length);
        this.playSoundEffect(sfxPaths[randomIndex], volume);
    }

    public setSfxVolume(volume: number): void {
        this.sfxVolume = Math.max(0, Math.min(1, volume));
    }

    public cleanup(): void {
        try {
            if (this.backgroundMusic) {
                this.backgroundMusic.setVolume(0);
            }
        } catch (error) {
            console.error('Error during audio cleanup:', error);
        }
        this.backgroundMusic = undefined;
    }
}

================
File: src/managers/player-projectile-manager.ts
================
import { World, Player } from 'hytopia';
import { ProjectileEntity } from '../entities/projectile-entity';
import { RaycastHandler } from '../raycast/raycast-handler';
import { Vector3Like } from 'hytopia';
import { BlockParticleEffects } from '../effects/block-particle-effects';
import { AudioManager } from './audio-manager';
import { RoundManager } from './round-manager';

export interface PlayerProjectileState {
  previewProjectile: ProjectileEntity | null;
  lastInputState: { mr: boolean };
  projectilesRemaining: number;
  lastShotTime: number;
}

export class PlayerProjectileManager {
  private static readonly INITIAL_AMMO_COUNT = 1000;
  private static readonly SHOT_COOLDOWN = 400; // 400ms cooldown (~150 shots per minute)
  private static readonly PROJECTILE_SOUNDS = [
    'audio/sfx/projectile/grenade-launcher.mp3',
    'audio/sfx/projectile/grenade-launcher2.mp3',
    'audio/sfx/projectile/grenade-launcher3.mp3'
  ];
  private playerStates = new Map<string, PlayerProjectileState>();
  private readonly world: World;
  private readonly raycastHandler: RaycastHandler;
  private readonly enablePreview: boolean;
  private readonly audioManager: AudioManager;
  private readonly roundManager?: RoundManager;

  constructor(world: World, raycastHandler: RaycastHandler, enablePreview: boolean = false, roundManager?: RoundManager) {
    this.world = world;
    this.raycastHandler = raycastHandler;
    this.enablePreview = enablePreview;
    this.audioManager = AudioManager.getInstance(world);
    this.roundManager = roundManager;
  }

  initializePlayer(playerId: string): void {
    this.playerStates.set(playerId, {
      previewProjectile: null,
      lastInputState: { mr: false },
      projectilesRemaining: PlayerProjectileManager.INITIAL_AMMO_COUNT,
      lastShotTime: 0
    });
  }

  removePlayer(playerId: string): void {
    const state = this.playerStates.get(playerId);
    if (state?.previewProjectile) {
      state.previewProjectile.despawn();
    }
    this.playerStates.delete(playerId);
  }

  getProjectilesRemaining(playerId: string): number {
    return this.playerStates.get(playerId)?.projectilesRemaining ?? 0;
  }

  private createProjectile(playerId: string, position: Vector3Like, direction: Vector3Like): ProjectileEntity {
    const projectile = new ProjectileEntity({
      modelScale: 1,
      raycastHandler: this.raycastHandler,
      enablePreview: this.enablePreview,
      playerId
    });

    // Calculate spawn position
    const spawnOffset = {
      x: direction.x,
      y: Math.max(direction.y, -0.5),
      z: direction.z
    };

    const offsetMag = Math.sqrt(
      spawnOffset.x * spawnOffset.x + 
      spawnOffset.y * spawnOffset.y + 
      spawnOffset.z * spawnOffset.z
    );

    const SPAWN_DISTANCE = 2.0;
    const spawnPos = {
      x: position.x + (spawnOffset.x / offsetMag) * SPAWN_DISTANCE,
      y: position.y + (spawnOffset.y / offsetMag) * SPAWN_DISTANCE + 1.5,
      z: position.z + (spawnOffset.z / offsetMag) * SPAWN_DISTANCE
    };

    projectile.spawn(this.world, spawnPos);
    this.handleProjectileSpawn(projectile);
    return projectile;
  }

  private handleProjectileSpawn(projectile: ProjectileEntity): void {
    projectile.onCollision = (position: Vector3Like, blockTextureUri: string) => {
      this.handleProjectileImpact(position, blockTextureUri);
    };
  }

  public handleProjectileInput(
    playerId: string,
    position: Vector3Like,
    direction: Vector3Like,
    input: any,
    player: Player
  ): void {
    const state = this.playerStates.get(playerId);
    if (!state) return;

    // Check if shooting is allowed based on round state
    if (this.roundManager && !this.roundManager.isShootingAllowed()) {
      // Clear any existing preview if shooting is not allowed
      if (state.previewProjectile) {
        state.previewProjectile.despawn();
        state.previewProjectile = null;
      }
      return;
    }

    const currentMrState = input.mr ?? false;
    const mrJustPressed = currentMrState && !state.lastInputState.mr;
    const mrJustReleased = !currentMrState && state.lastInputState.mr;

    // Right mouse button just pressed
    if (mrJustPressed) {
      const currentTime = Date.now();
      const timeSinceLastShot = currentTime - state.lastShotTime;

      if (timeSinceLastShot < PlayerProjectileManager.SHOT_COOLDOWN) {
        // Still on cooldown - provide feedback about remaining cooldown
        if (player) {
          const remainingCooldown = Math.ceil((PlayerProjectileManager.SHOT_COOLDOWN - timeSinceLastShot) / 100) / 10;
          player.ui.sendData({ 
            type: 'onCooldown',
            remainingSeconds: remainingCooldown
          });
        }
        return;
      }

      if (state.projectilesRemaining <= 0) {
        // Send UI event when trying to shoot with no ammo
        if (player) {
          player.ui.sendData({ type: 'attemptShootNoAmmo' });
        }
        return;
      }

      if (!state.previewProjectile) {
        state.previewProjectile = this.createProjectile(playerId, position, direction);
      }
    }
    
    // Update trajectory while held
    if (currentMrState && state.previewProjectile) {
      state.previewProjectile.showTrajectoryPreview(direction);
    }

    // Right mouse button just released
    if (mrJustReleased && state.previewProjectile) {
      // Play random grenade launcher sound
      this.audioManager.playRandomSoundEffect(PlayerProjectileManager.PROJECTILE_SOUNDS, 0.4);
      
      // Throw the projectile and clean up preview
      state.previewProjectile.throw(direction);
      state.previewProjectile.clearTrajectoryMarkers();
      state.previewProjectile = null;
      
      // Decrease projectile count and update last shot time
      state.projectilesRemaining--;
      state.lastShotTime = Date.now();
    }

    // Update last input state
    state.lastInputState.mr = currentMrState;
  }

  // Optional: Method to refill projectiles (could be used for pickups or respawn)
  refillProjectiles(playerId: string, amount: number = PlayerProjectileManager.INITIAL_AMMO_COUNT): void {
    const state = this.playerStates.get(playerId);
    if (state) {
      state.projectilesRemaining = amount;
    }
  }

  private handleProjectileImpact(position: Vector3Like, blockTextureUri: string): void {
    try {
      const particleSystem = BlockParticleEffects.getInstance(this.world);
      particleSystem.createDestructionEffect(this.world, position, blockTextureUri);
    } catch (error) {
      console.error('Failed to create particle effect:', error);
    }
  }
}

================
File: src/managers/player-settings-manager.ts
================
import { World, Player } from 'hytopia';

export interface PlayerSettings {
    crosshairColor: string;
    bgmVolume: number;
}

export interface UISettingsData {
    type: 'updateSettings';
    setting: keyof PlayerSettings;
    value: any;
}

export class PlayerSettingsManager {
    private static instance: PlayerSettingsManager;
    private readonly world: World;
    private playerSettings = new Map<string, PlayerSettings>();

    private constructor(world: World) {
        this.world = world;
    }

    public static getInstance(world: World): PlayerSettingsManager {
        if (!PlayerSettingsManager.instance) {
            PlayerSettingsManager.instance = new PlayerSettingsManager(world);
        }
        return PlayerSettingsManager.instance;
    }

    public initializePlayer(playerId: string): void {
        this.playerSettings.set(playerId, {
            crosshairColor: '#ffff00',
            bgmVolume: 0.1 // Default background music volume
        });
    }

    public removePlayer(playerId: string): void {
        this.playerSettings.delete(playerId);
    }

    public updateSetting(playerId: string, setting: keyof PlayerSettings, value: any): void {
        const settings = this.playerSettings.get(playerId);
        if (!settings) return;

        if (setting === 'bgmVolume') {
            // Convert slider value (0-100) to volume (0-1)
            // Ensure exact 0 when muting
            const normalizedVolume = value / 100;
            settings.bgmVolume = normalizedVolume === 0 ? 0 : Math.max(0, Math.min(1, normalizedVolume));
        } else {
            settings[setting] = value;
        }
    }

    /**
     * Gets the current settings for a player
     * @param playerId The ID of the player
     * @returns The player's settings or undefined if not found
     */
    public getPlayerSettings(playerId: string): PlayerSettings | undefined {
        return this.playerSettings.get(playerId);
    }

    public cleanup(): void {
        this.playerSettings.clear();
    }
}

================
File: src/managers/README.md
================
# Player Projectile Manager

## Current Features

### Core Functionality
- Manages projectile state for each player individually
- Limits each player to 5 projectiles
- Handles projectile preview and trajectory visualization
- Proper cleanup when players leave the game

### Input Handling
- Right mouse button press: Creates and shows projectile preview
- Hold right mouse button: Updates trajectory preview
- Release right mouse button: Throws projectile and decrements count
- Prevents shooting when out of projectiles

### State Management
- Tracks remaining projectiles per player
- Maintains preview projectile state
- Handles input state to prevent duplicate actions
- Safe cleanup of resources on player disconnect

## Potential Future Enhancements

### Gameplay Features
1. **Projectile Types**
   ```typescript
   enum ProjectileType {
     NORMAL,
     EXPLOSIVE,
     BOUNCING,
     PIERCING
   }
   ```
   - Different damage values
   - Unique effects and behaviors
   - Type-specific cooldowns

2. **Ammo System**
   - Different ammo types
   - Ammo pickups in the world
   - Maximum ammo capacity
   - Reload mechanics

3. **Cooldown System**
   ```typescript
   interface ProjectileCooldown {
     lastThrowTime: number;
     cooldownDuration: number;
     isOnCooldown: boolean;
   }
   ```
   - Per-projectile type cooldowns
   - Visual feedback for cooldown state
   - Upgradeable cooldown reduction

### Technical Improvements
1. **Physics Enhancements**
   - Improved collision detection
   - Wind effects on trajectories
   - Gravity modifications
   - Ricochet mechanics

2. **Performance Optimizations**
   - Projectile pooling for better memory usage
   - Batch physics updates
   - Optimized trajectory calculations

3. **Network Optimizations**
   - Predictive projectile paths
   - Client-side prediction
   - Lag compensation

### Player Progression
1. **Upgrade System**
   - Increased ammo capacity
   - Faster reload times
   - Enhanced projectile effects
   - New projectile types unlocks

2. **Achievement System**
   - Track accurate shots
   - Count successful hits
   - Special achievements for trick shots
   - Combo system for rapid successful hits

### Game Modes
1. **Team-based Modes**
   - Shared team ammo pools
   - Team-specific projectile types
   - Strategic ammo management

2. **Special Events**
   - Infinite ammo periods
   - Special projectile types
   - Time-limited power-ups
   - Target practice modes

## Integration Points
- Can be extended with UI systems for visual feedback
- Can integrate with inventory systems
- Can connect to achievement systems
- Can be part of a larger combat system

## Best Practices for Extensions
1. Maintain separation of concerns
2. Keep the core manager focused on state management
3. Use events for communication with other systems
4. Consider performance implications of new features
5. Maintain type safety when extending functionality

================
File: src/managers/round-manager.ts
================
import { World, Vector3Like } from 'hytopia';
import { MovingBlockManager, MOVING_BLOCK_CONFIG } from '../moving_blocks/moving-block-entity';
import { ScoreManager } from './score-manager';
import { AudioManager } from './audio-manager';

export interface RoundConfig {
    duration: number;  // Duration in milliseconds
    minBlockCount: number;  // Minimum number of blocks in play
    maxBlockCount: number;  // Maximum number of blocks in play
    blockSpawnInterval: number;  // How often to spawn new blocks (ms)
    speedMultiplier: number;  // Speed multiplier for blocks
    blockTypes: {  // Probability weights for different block types
        normal: number;
        sineWave: number;
        static: number;
        verticalWave: number;
        popup: number;     // Pop-up targets that appear and disappear
        rising: number;    // Rising targets that move upward
        parabolic: number; // Targets that follow parabolic paths
        pendulum: number;  // Targets that swing like pendulums
    };
}

interface SpawnPosition extends Vector3Like {
    moveSpeed?: number;
}

export interface GameConfig {
    maxRounds: number;
}

interface GameEndStanding {
    playerId: string;
    playerNumber?: number;
    playerColor?: string;
    placementPoints: number;
    wins: number;
    totalScore: number;
}

export class RoundManager {
    private currentRound: number = 0;
    private roundTimer: NodeJS.Timeout | null = null;
    private blockSpawnTimer: NodeJS.Timeout | null = null;
    private isRoundActive: boolean = false;
    private roundStartTime: number = 0;
    private lastUpdateTime: number = 0;
    private waitingForPlayers: boolean = false;
    private readonly REQUIRED_PLAYERS = 2;
    private checkPlayersInterval: NodeJS.Timeout | null = null;
    private readonly GAME_CONFIG: GameConfig = {
        maxRounds: 10
    };
    private gameInProgress: boolean = false;
    private roundTransitionPending: boolean = false;
    private readonly TRANSITION_DURATION: number = 3000; // Increased to 3 seconds

    // Helper function to get a random Y position within a range
    private getRandomY(min: number, max: number): number {
        return min + Math.random() * (max - min);
    }

    constructor(
        private world: World,
        private blockManager: MovingBlockManager,
        private scoreManager: ScoreManager,
        transitionDuration?: number
    ) {
        if (transitionDuration !== undefined) {
            this.TRANSITION_DURATION = transitionDuration;
        }
    }

    private getPlayerCount(): number {
        return this.world.entityManager.getAllPlayerEntities().length;
    }

    private getRoundConfig(round: number): RoundConfig {
        // Tutorial round (Round 1) - Static targets only
        if (round === 1) {
            return {
                duration: 10000,  // 10 seconds (was 60000)
                minBlockCount: 8,
                maxBlockCount: 12,
                blockSpawnInterval: 500,
                speedMultiplier: 0.5,
                blockTypes: {
                    normal: 0,
                    sineWave: 0,
                    static: 1.0,    // 100% static targets for learning
                    verticalWave: 0,
                    popup: 0,
                    rising: 0,
                    parabolic: 0,
                    pendulum: 0
                }
            };
        }
        
        // Round 2 - 100% Normal Blocks
        if (round === 2) {
            return {
                duration: 10000,  // 10 seconds (was 30000)
                minBlockCount: 2,
                maxBlockCount: 4,
                blockSpawnInterval: 500,
                speedMultiplier: 0.6,
                blockTypes: {
                    normal: 1.0,    // 100% normal blocks
                    sineWave: 0,
                    static: 0,
                    verticalWave: 0,
                    popup: 0,
                    rising: 0,
                    parabolic: 0,
                    pendulum: 0
                }
            };
        }
        
        // Round 3 - 100% Sine Wave
        if (round === 3) {
            return {
                duration: 10000,  // 10 seconds (was 30000)
                minBlockCount: 3,
                maxBlockCount: 6,
                blockSpawnInterval: 500,
                speedMultiplier: 0.65,
                blockTypes: {
                    normal: 0,
                    sineWave: 1.0,
                    static: 0,
                    verticalWave: 0,
                    popup: 0,
                    rising: 0,
                    parabolic: 0,
                    pendulum: 0
                }
            };
        }

        // Round 4 - 100% Vertical Wave
        if (round === 4) {
            return {
                duration: 10000,  // 10 seconds (was 25000)
                minBlockCount: 2,
                maxBlockCount: 6,
                blockSpawnInterval: 500,
                speedMultiplier: 0.7,
                blockTypes: {
                    normal: 0,
                    sineWave: 0,
                    static: 0,
                    verticalWave: 1.0,
                    popup: 0,
                    rising: 0,
                    parabolic: 0,
                    pendulum: 0
                }
            };
        }

        // Round 5 - 100% Pop-up
        if (round === 5) {
            return {
                duration: 10000,  // 10 seconds (was 25000)
                minBlockCount: 2,
                maxBlockCount: 4,
                blockSpawnInterval: 500,
                speedMultiplier: 0.75,
                blockTypes: {
                    normal: 0,
                    sineWave: 0,
                    static: 0,
                    verticalWave: 0,
                    popup: 1.0,
                    rising: 0,
                    parabolic: 0,
                    pendulum: 0
                }
            };
        }

        // Round 6 - 100% Rising
        if (round === 6) {
            return {
                duration: 10000,  // 10 seconds (was 25000)
                minBlockCount: 2,
                maxBlockCount: 4,
                blockSpawnInterval: 500,
                speedMultiplier: 0.8,
                blockTypes: {
                    normal: 0,
                    sineWave: 0,
                    static: 0,
                    verticalWave: 0,
                    popup: 0,
                    rising: 1.0,
                    parabolic: 0,
                    pendulum: 0
                }
            };
        }

        // Round 7 - 100% Parabolic
        if (round === 7) {
            return {
                duration: 10000,  // 10 seconds (was 30000)
                minBlockCount: 2,
                maxBlockCount: 4,
                blockSpawnInterval: 500,
                speedMultiplier: 0.85,
                blockTypes: {
                    normal: 0,
                    sineWave: 0,
                    static: 0,
                    verticalWave: 0,
                    popup: 0,
                    rising: 0,
                    parabolic: 1.0,
                    pendulum: 0
                }
            };
        }

        // Round 8 - 100% Pendulum
        if (round === 8) {
            return {
                duration: 10000,  // 10 seconds (was 30000)
                minBlockCount: 2,
                maxBlockCount: 4,
                blockSpawnInterval: 500,
                speedMultiplier: 0.9,
                blockTypes: {
                    normal: 0,
                    sineWave: 0,
                    static: 0,
                    verticalWave: 0,
                    popup: 0,
                    rising: 0,
                    parabolic: 0,
                    pendulum: 1.0
                }
            };
        }

        // Round 9 - "Up and Down" Mix (Vertical Wave, Rising, and Popup)
        if (round === 9) {
            return {
                duration: 10000,  // 10 seconds (was 30000)
                minBlockCount: 2,
                maxBlockCount: 6,
                blockSpawnInterval: 500,
                speedMultiplier: 0.95,
                blockTypes: {
                    normal: 0,
                    sineWave: 0,
                    static: 0,
                    verticalWave: 0.4,  // 40% vertical wave
                    popup: 0.3,         // 30% popup
                    rising: 0.3,        // 30% rising
                    parabolic: 0,
                    pendulum: 0
                }
            };
        }

        // Round 10 - "Chaos" Mix (Pendulum, Parabolic, and Sine Wave)
        return {
            duration: 10000,  // 10 seconds (was 30000)
            minBlockCount: 4,
            maxBlockCount: 6,
            blockSpawnInterval: 500,
            speedMultiplier: 1.0,
            blockTypes: {
                normal: 0,
                sineWave: 0.3,     // 30% sine wave
                static: 0,
                verticalWave: 0,
                popup: 0,
                rising: 0,
                parabolic: 0.4,    // 40% parabolic
                pendulum: 0.3      // 30% pendulum
            }
        };
    }

    private startCountdown(): void {
        // Don't start countdown if in transition or a round is active
        if (this.roundTransitionPending || this.isRoundActive) return;
        
        // IMPORTANT: Don't set roundTransitionPending flag until countdown is complete
        // This allows shooting to continue during countdown
        
        // Simplified transition - just wait a short time then start
        setTimeout(() => {
            // Double-check that we still want to start the round
            if (!this.isRoundActive) {
                this.actuallyStartRound();
            }
        }, 1000);
    }

    private actuallyStartRound(): void {
        // Don't start if a round is already active
        if (this.isRoundActive) {
            console.log('Attempted to start round while another is active');
            return;
        }

        this.currentRound++;
        
        // Make sure to set this flag first to allow shooting
        this.isRoundActive = true;
        this.gameInProgress = true;
        this.roundStartTime = Date.now();
        this.lastUpdateTime = this.roundStartTime;

        const config = this.getRoundConfig(this.currentRound);
        console.log('Starting round with config:', config);

        // Clear any existing blocks before starting new round
        this.world.entityManager.getAllEntities()
            .filter(entity => entity.name.toLowerCase().includes('block'))
            .forEach(entity => entity.despawn());

        // Reset scores for the new round
        this.scoreManager.startNewRound();
        
        // Broadcast round start with full duration
        this.broadcastRoundInfo();

        // Start block spawning
        this.startBlockSpawning(config);

        // Set round timer
        if (this.roundTimer) {
            clearTimeout(this.roundTimer);
        }
        
        this.roundTimer = setTimeout(() => {
            console.log('Round timer completed');
            this.endRound();
        }, config.duration);
    }

    public startRound(): void {
        // Don't start if round is active or we're in transition
        if (this.isRoundActive || this.roundTransitionPending) return;

        // Add this check to prevent starting new rounds if we've hit the max
        if (this.currentRound >= this.GAME_CONFIG.maxRounds) {
            this.endGame();
            return;
        }

        const playerCount = this.getPlayerCount();
        
        // Only check for minimum players when starting a new game (not in progress)
        if (!this.gameInProgress && playerCount < this.REQUIRED_PLAYERS) {
            // If we're already waiting for players, don't reset the state
            if (!this.waitingForPlayers) {
                this.waitingForPlayers = true;
                this.broadcastWaitingForPlayers(playerCount);
                
                // Clear any existing interval before setting a new one
                if (this.checkPlayersInterval) {
                    clearInterval(this.checkPlayersInterval);
                    this.checkPlayersInterval = null;
                }
                
                this.checkPlayersInterval = setInterval(() => {
                    const currentPlayers = this.getPlayerCount();
                    
                    if (currentPlayers >= this.REQUIRED_PLAYERS) {
                        // Only proceed if we haven't already started the round/countdown
                        if (this.waitingForPlayers && !this.isRoundActive && !this.roundTransitionPending) {
                            this.waitingForPlayers = false;
                            clearInterval(this.checkPlayersInterval!);
                            this.checkPlayersInterval = null;
                            this.startCountdown();
                        } else {
                            // We already started or are transitioning, just clear the interval
                            clearInterval(this.checkPlayersInterval!);
                            this.checkPlayersInterval = null;
                        }
                    } else {
                        this.broadcastWaitingForPlayers(currentPlayers);
                    }
                }, 1000);
            }
            return;
        }
        
        // Start countdown to begin round
        this.startCountdown();
    }

    private startBlockSpawning(config: RoundConfig): void {
        // Calculate player scaling factor
        const playerCount = this.world.entityManager.getAllPlayerEntities().length;
        const additionalPlayers = Math.max(0, playerCount - 2); // Count players above 2
        const playerScaling = Math.min(0.3, additionalPlayers * 0.1); // 10% per player, max 30%
        
        // Scale block counts
        const scaledMaxBlocks = Math.floor(config.maxBlockCount * (1 + playerScaling));
        const scaledMinBlocks = Math.floor(config.minBlockCount * (1 + playerScaling));

        const spawnBlock = () => {
            if (!this.isRoundActive) return;

            const currentBlocks = this.blockManager.getBlockCount();
            
            // Determine how many blocks to spawn using scaled values
            const blocksNeeded = Math.min(
                scaledMaxBlocks - currentBlocks,
                // If 0-1 blocks left, spawn up to 4 at once
                // If below minimum, spawn up to 2 at once
                // If below 25% of max, spawn up to 3 at once
                currentBlocks <= 1 ? 4 :
                currentBlocks < scaledMinBlocks ? 2 : 
                currentBlocks < (scaledMaxBlocks * 0.25) ? 3 : 1
            );

            // Try to spawn multiple blocks if needed
            for(let i = 0; i < blocksNeeded; i++) {
                // Choose block type first
                const rand = Math.random();
                const total = Object.values(config.blockTypes).reduce((a, b) => a + b, 0);
                let sum = 0;
                let chosenType: keyof typeof config.blockTypes | null = null;

                for (const [type, weight] of Object.entries(config.blockTypes)) {
                    sum += weight / total;
                    if (rand <= sum && !chosenType) {
                        chosenType = type as keyof typeof config.blockTypes;
                    }
                }

                // Add spacing between spawns
                const existingBlocks = this.world.entityManager.getAllEntities()
                    .filter(entity => entity.name.toLowerCase().includes('block'));
                
                let attempts = 0;
                let spawnPosition: Vector3Like;
                const minSpacing = 2;
                const safetyMargin = MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.PLATFORM_SAFETY_MARGIN;

                do {
                    // Adjust spawn ranges based on block type
                    const isStaticBlock = chosenType === 'static';
                    const isVerticalWave = chosenType === 'verticalWave';

                    spawnPosition = {
                        x: (() => {
                            if (isStaticBlock) return Math.random() * 16 - 8; // Static: -8 to 8
                            // Moving blocks: Use movement bounds with safety margin
                            const movementBounds = MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS;
                            return movementBounds.min.x + safetyMargin + 
                                   Math.random() * (movementBounds.max.x - movementBounds.min.x - 2 * safetyMargin);
                        })(),
                        y: (() => {
                            switch(chosenType) {
                                case 'static':
                                    return this.getRandomY(0, 12);  // Static: Wide range for variety
                                case 'normal':
                                    return this.getRandomY(-1, 10);  // Normal: Good spread above and below
                                case 'sineWave':
                                    return this.getRandomY(0, 10);  // Sine wave: Slight bias towards higher
                                case 'verticalWave':
                                    // Calculate random height parameters for more variance
                                    const waveBaseHeight = this.getRandomY(-3, 3);  // Varied base height
                                    const waveAmplitude = this.getRandomY(6, 12);   // Higher amplitude for more dramatic peaks
                                    const waveFrequency = this.getRandomY(0.2, 0.4); // Varied frequency for different speeds
                                    
                                    return waveBaseHeight;  // Start at varied base height
                                case 'popup':
                                    // Start much lower and pop up much higher with less hang time
                                    const popupHeight = this.getRandomY(10, 18); // Much higher pop-up range
                                    const popupStartY = this.getRandomY(-12, -6); // Start even lower with more variance
                                    
                                    return popupStartY;  // Use lower start position
                                case 'rising':
                                    // Start below ground level
                                    return this.getRandomY(-5, 4);  // Start deep to rise up dramatically
                                case 'parabolic':
                                    // Start at varied heights
                                    return this.getRandomY(-4, 8);  // Equal spread for parabolic arcs
                                case 'pendulum':
                                    // Start higher for swinging
                                    return this.getRandomY(-2,8);  // Keep high for swinging down
                                default:
                                    return this.getRandomY(0, 10);
                            }
                        })(),
                        z: (() => {
                            if (isStaticBlock) return Math.random() * 24 - 12; // Static: -12 to 12
                            // Moving blocks: Use movement bounds with safety margin
                            const movementBounds = MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS;
                            return movementBounds.min.z + safetyMargin + 
                                   Math.random() * (movementBounds.max.z - movementBounds.min.z - 2 * safetyMargin);
                        })()
                    };

                    // Check distance from platforms
                    const rightPlatformDistance = Math.abs(spawnPosition.x - MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.RIGHT_PLATFORM_EDGE.X);
                    const isInRightPlatformZRange = spawnPosition.z >= MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.RIGHT_PLATFORM_EDGE.Z_MIN - safetyMargin && 
                                                  spawnPosition.z <= MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.RIGHT_PLATFORM_EDGE.Z_MAX + safetyMargin;
                    
                    const leftPlatformDistance = Math.abs(spawnPosition.x - MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.LEFT_PLATFORM_EDGE.X);
                    const isInLeftPlatformZRange = spawnPosition.z >= MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.LEFT_PLATFORM_EDGE.Z_MIN - safetyMargin && 
                                                 spawnPosition.z <= MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.LEFT_PLATFORM_EDGE.Z_MAX + safetyMargin;
                    
                    const isSafeFromRightPlatform = rightPlatformDistance >= safetyMargin || !isInRightPlatformZRange;
                    const isSafeFromLeftPlatform = leftPlatformDistance >= safetyMargin || !isInLeftPlatformZRange;
                    
                    // Check distance from all existing blocks
                    const isTooCloseToBlocks = existingBlocks.some(block => {
                        const dx = block.position.x - spawnPosition.x;
                        const dy = block.position.y - spawnPosition.y;
                        const dz = block.position.z - spawnPosition.z;
                        return Math.sqrt(dx * dx + dy * dy + dz * dz) < minSpacing;
                    });

                    // Break if position is safe from both platforms and other blocks
                    if (!isTooCloseToBlocks && isSafeFromRightPlatform && isSafeFromLeftPlatform) break;
                    
                    attempts++;
                } while (attempts < 10);

                // If we couldn't find a safe position after max attempts, use a default safe position
                if (attempts >= 10) {
                    spawnPosition = {
                        x: 0,
                        y: 3,
                        z: 0
                    };
                }

                // Calculate the base speed for this block
                const baseSpeed = 8 * config.speedMultiplier;

                // Spawn the chosen block type with appropriate spacing
                switch(chosenType) {
                    case 'static':
                        this.blockManager.createStaticTarget({
                            x: spawnPosition.x,
                            y: spawnPosition.y,
                            z: spawnPosition.z
                        });
                        break;
                    case 'normal':
                        this.blockManager.createZAxisBlock(spawnPosition);
                        break;
                    case 'sineWave':
                        // For sine wave blocks, we need to account for the amplitude in spawn position
                        const sineWaveAmplitude = this.getRandomY(6, 10); // Random amplitude between 6-10 units
                        const sineWaveFrequency = this.getRandomY(0.15, 0.25); // Varied frequency for different wave patterns
                        
                        // Create variety by spawning at different points in the wave cycle
                        const initialOffset = this.getRandomY(-sineWaveAmplitude, sineWaveAmplitude);
                        
                        const sineWaveSpawnPosition = {
                            ...spawnPosition,
                            // Restrict X spawn position to account for sine wave amplitude
                            x: Math.max(
                                Math.min(
                                    spawnPosition.x,
                                    MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.max.x - sineWaveAmplitude - safetyMargin
                                ),
                                MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.min.x + sineWaveAmplitude + safetyMargin
                            ),
                            // Vary the Y position for initial offset
                            y: spawnPosition.y + initialOffset
                        };
                        
                        this.blockManager.createSineWaveBlock({
                            spawnPosition: sineWaveSpawnPosition,
                            moveSpeed: baseSpeed * 0.6,
                            amplitude: sineWaveAmplitude,
                            frequency: sineWaveFrequency,
                            blockTextureUri: 'blocks/nuit.png' // Changed to nuit texture for sine wave (mystical flowing pattern)
                        });
                        break;
                    case 'static':
                        this.blockManager.createStaticTarget({
                            x: spawnPosition.x,
                            y: spawnPosition.y,
                            z: spawnPosition.z
                        });
                        break;
                    case 'verticalWave':
                        // Calculate random height parameters for more variance
                        const waveBaseHeight = this.getRandomY(-3, 3);  // Varied base height
                        const waveAmplitude = this.getRandomY(6, 12);   // Higher amplitude for more dramatic peaks
                        const waveFrequency = this.getRandomY(0.2, 0.4); // Varied frequency for different speeds
                        
                        this.blockManager.createVerticalWaveBlock({
                            spawnPosition: {
                                ...spawnPosition,
                                y: waveBaseHeight  // Start at varied base height
                            },
                            moveSpeed: baseSpeed * 0.75,
                            amplitude: waveAmplitude,    // Add amplitude for higher peaks
                            frequency: waveFrequency     // Add frequency for varied wave speeds
                        });
                        break;
                    case 'popup':
                        // Start much lower and pop up much higher with less hang time
                        const popupHeight = this.getRandomY(10, 18); // Much higher pop-up range
                        const popupStartY = this.getRandomY(-12, -6); // Start even lower with more variance
                        
                        this.blockManager.createPopUpTarget({
                            spawnPosition: {
                                ...spawnPosition,
                                y: popupStartY  // Use lower start position
                            },
                            startY: popupStartY,
                            topY: popupStartY + popupHeight,  // Pop up much higher from lower start
                            moveSpeed: baseSpeed * 1.6  // 60% faster for less hang time
                        });
                        break;
                    case 'rising':
                        const riseHeight = this.getRandomY(5, 8); // Random rise height between 5-8 units
                        this.blockManager.createRisingTarget({
                            startY: spawnPosition.y,
                            firstStopY: spawnPosition.y + (riseHeight * 0.6), // Stop at 60% of total height
                            finalY: spawnPosition.y + riseHeight,
                            moveSpeed: baseSpeed * 0.7,
                            pauseDuration: 500
                        });
                        break;
                    case 'parabolic':
                        // Calculate a natural throwing arc
                        const throwDistance = this.getRandomY(15, 25); // Random throw distance
                        const throwAngle = this.getRandomY(45, 75);    // Steeper angle between 45-75 degrees for more upward arc
                        const throwHeight = this.getRandomY(10, 15);   // Higher maximum height
                        
                        // Start much lower and throw upward
                        const throwStartY = this.getRandomY(-8, -4);   // Start well below ground level
                        
                        // Calculate random direction angle for more varied trajectories
                        const directionAngle = Math.random() * Math.PI * 2; // Random angle 0-360 degrees
                        
                        this.blockManager.createParabolicTarget({
                            startPoint: {
                                x: spawnPosition.x,
                                y: throwStartY,
                                z: spawnPosition.z
                            },
                            endPoint: {
                                // Use direction angle to create random horizontal movement direction
                                x: spawnPosition.x + throwDistance * Math.cos(directionAngle),
                                y: throwStartY - 2,  // End slightly lower than start for more dramatic fall
                                z: spawnPosition.z + throwDistance * Math.sin(directionAngle)
                            },
                            maxHeight: throwHeight,
                            duration: 4500,  // Much slower for more hang time
                            moveSpeed: baseSpeed * 0.5  // Slower speed for more hang time
                        });
                        break;
                    case 'pendulum':
                        const pendulumHeight = this.getRandomY(6, 12); // Increased height range
                        const pendulumLength = pendulumHeight * this.getRandomY(0.6, 1.0); // Varied rope length
                        const swingAmplitude = this.getRandomY(0.8, 1.4); // Random swing amplitude
                        const swingFrequency = this.getRandomY(0.15, 0.35); // Slower frequency (was 0.3-0.7)
                        
                        this.blockManager.createPendulumTarget({
                            pivotPoint: {
                                x: spawnPosition.x,
                                y: spawnPosition.y + pendulumHeight,  // Higher pivot point
                                z: spawnPosition.z
                            },
                            length: pendulumLength,  // Varied rope length
                            amplitude: swingAmplitude,  // More varied swing width
                            frequency: swingFrequency,  // Slower swing speed
                            moveSpeed: baseSpeed * this.getRandomY(0.25, 0.4)  // Much slower speed (was 0.4-0.6)
                        });
                        break;
                }
            }
        }

        // Initial spawn - spawn minimum blocks more quickly
        for (let i = 0; i < scaledMinBlocks; i++) {
            setTimeout(() => spawnBlock(), i * 1000);
        }

        // Regular spawn interval
        this.blockSpawnTimer = setInterval(spawnBlock, config.blockSpawnInterval);
    }

    public endRound(): void {
        // Don't end if no round is active
        if (!this.isRoundActive) return;

        // Clear any existing timers first
        if (this.roundTimer) {
            clearTimeout(this.roundTimer);
            this.roundTimer = null;
        }
        if (this.blockSpawnTimer) {
            clearInterval(this.blockSpawnTimer);
            this.blockSpawnTimer = null;
        }

        // Set round as inactive immediately to prevent double-ending
        this.isRoundActive = false;

        // Get round results with placements
        const { winnerId, placements } = this.scoreManager.handleRoundEnd();
        
        // Play victory sound if there's a winner
        if (winnerId && this.world) {
            const audioManager = AudioManager.getInstance(this.world);
            audioManager.playSoundEffect('audio/sfx/damage/blop1.mp3', 0.6);
        }
        
        // Broadcast updated scores and leaderboard
        this.scoreManager.broadcastScores(this.world);

        // Broadcast round end results with placement info
        this.broadcastRoundEnd(winnerId, placements);

        // Check if this was the final round
        if (this.currentRound >= this.GAME_CONFIG.maxRounds) {
            this.endGame();
            return;
        }

        // Prevent multiple transitions
        if (this.roundTransitionPending) return;

        // Set transition flag and schedule next round
        this.roundTransitionPending = true;
        
        // Clear any existing transition timer
        if (this.roundTimer) {
            clearTimeout(this.roundTimer);
        }
        
        // Schedule next round after transition
        this.roundTimer = setTimeout(() => {
            // Set transitioning to false first BEFORE starting the next round
            this.roundTransitionPending = false;
            this.startRound();
        }, this.TRANSITION_DURATION);
    }

    public handlePlayerLeave(): void {
        const playerCount = this.getPlayerCount();
        
        // Only reset game if we're waiting for players to start and don't have enough
        if (!this.gameInProgress && playerCount < this.REQUIRED_PLAYERS) {
            this.world.entityManager.getAllPlayerEntities().forEach(playerEntity => {
                playerEntity.player.ui.sendData({
                    type: 'systemMessage',
                    message: 'Not enough players to start game...',
                    color: 'FF0000'
                });
            });
            this.resetGame();
        }
        // If game is in progress, continue with remaining players
    }

    private resetGame(): void {
        this.currentRound = 0;
        this.gameInProgress = false;
        this.scoreManager.resetAllStats();
        this.scoreManager.broadcastScores(this.world);
        
        // Check if we have enough players to start new game
        if (this.getPlayerCount() >= this.REQUIRED_PLAYERS) {
            this.world.entityManager.getAllPlayerEntities().forEach(playerEntity => {
                playerEntity.player.ui.sendData({
                    type: 'newGame',
                    message: 'New game starting...'
                });
            });
            
            setTimeout(() => {
                this.startRound();
            }, 5000);
        } else {
            this.waitingForPlayers = true;
            this.broadcastWaitingForPlayers(this.getPlayerCount());
        }
    }

    private broadcastRoundInfo(): void {
        const config = this.getRoundConfig(this.currentRound);
        const currentTime = Date.now();
        const elapsedTime = currentTime - this.roundStartTime;
        const remainingTime = Math.max(0, config.duration - elapsedTime);
        
        const message = {
            type: 'roundUpdate',
            data: {
                round: this.currentRound,
                totalRounds: this.GAME_CONFIG.maxRounds,
                remainingRounds: this.getRemainingRounds(),
                duration: config.duration,
                timeRemaining: remainingTime
            }
        };

        for (const player of this.world.entityManager.getAllPlayerEntities()) {
            player.player.ui.sendData(message);
        }
    }

    private broadcastRoundEnd(winnerId: string | null, placements: Array<{ playerId: string, points: number }>): void {
        // Get player stats for enhanced placements with player info
        const enhancedPlacements = placements.map(placement => {
            // Get player stats from score manager
            const playerStats = (this.scoreManager as any).playerStats.get(placement.playerId);
            const playerNumber = playerStats?.playerNumber || 0;
            
            // Get color from the player colors array
            const playerColors = (this.scoreManager as any).constructor.PLAYER_COLORS || [];
            const playerColor = playerColors[playerNumber - 1] || '#FFFFFF';
            
            return {
                ...placement,
                playerNumber,
                playerColor
            };
        });
        
        // Send enhanced data to each player
        for (const playerEntity of this.world.entityManager.getAllPlayerEntities()) {
            const currentPlayerId = playerEntity.player.id;
            
            playerEntity.player.ui.sendData({
                type: 'roundEnd',
                data: {
                    round: this.currentRound,
                    totalRounds: this.GAME_CONFIG.maxRounds,
                    nextRoundIn: this.TRANSITION_DURATION,
                    winnerId: winnerId,
                    placements: enhancedPlacements,
                    currentPlayerId // Send current player ID for highlighting
                }
            });
        }
    }

    private broadcastWaitingForPlayers(currentCount: number): void {
        const message = {
            type: 'waitingForPlayers',
            data: {
                current: currentCount,
                required: this.REQUIRED_PLAYERS,
                remaining: this.REQUIRED_PLAYERS - currentCount
            }
        };

        for (const player of this.world.entityManager.getAllPlayerEntities()) {
            player.player.ui.sendData(message);
        }
    }

    public getCurrentRound(): number {
        return this.currentRound;
    }

    public isActive(): boolean {
        return this.isRoundActive;
    }

    public isShootingAllowed(): boolean {
        // Should return true when round is active and not waiting for players
        return this.isRoundActive && !this.waitingForPlayers;
    }

    public isWaitingForPlayers(): boolean {
        return this.waitingForPlayers;
    }

    public cleanup(): void {
        if (this.checkPlayersInterval) {
            clearInterval(this.checkPlayersInterval);
            this.checkPlayersInterval = null;
        }
        if (this.roundTimer) {
            clearTimeout(this.roundTimer);
            this.roundTimer = null;
        }
        if (this.blockSpawnTimer) {
            clearInterval(this.blockSpawnTimer);
            this.blockSpawnTimer = null;
        }
        this.roundTransitionPending = false;
    }

    private endGame(): void {
        this.gameInProgress = false;
        const finalStandings: GameEndStanding[] = [];
        
        this.world.entityManager.getAllPlayerEntities().forEach(playerEntity => {
            const playerId = playerEntity.player.id;
            const playerStats = (this.scoreManager as any).playerStats.get(playerId);
            const playerNumber = playerStats?.playerNumber || 0;
            
            // Get color from player colors array
            const playerColors = (this.scoreManager as any).constructor.PLAYER_COLORS || [];
            const playerColor = playerColors[playerNumber - 1] || '#FFFFFF';
            
            finalStandings.push({
                playerId,
                playerNumber,
                playerColor,
                placementPoints: this.scoreManager.getLeaderboardPoints(playerId),
                wins: this.scoreManager.getWins(playerId),
                totalScore: this.scoreManager.getScore(playerId)
            });
        });

        // Sort by placement points
        finalStandings.sort((a, b) => b.placementPoints - a.placementPoints);
        const gameWinner = finalStandings[0];
        
        // Clear any remaining blocks
        this.world.entityManager.getAllEntities()
            .filter(entity => entity.name.toLowerCase().includes('block'))
            .forEach(entity => entity.despawn());

        if (gameWinner) {
            // Send game end message to all players with current player ID
            this.world.entityManager.getAllPlayerEntities().forEach(playerEntity => {
                const currentPlayerId = playerEntity.player.id;
                
                // Send game end data with currentPlayerId
                playerEntity.player.ui.sendData({
                    type: 'gameEnd',
                    data: {
                        winner: gameWinner,
                        standings: finalStandings,
                        currentPlayerId,
                        nextGameIn: 10000, // 10 seconds until next game
                        stats: {
                            totalRounds: this.GAME_CONFIG.maxRounds,
                            completedRounds: this.currentRound
                        }
                    }
                });
                
                // Send congratulatory message to winner
                if (currentPlayerId === gameWinner.playerId) {
                    playerEntity.player.ui.sendData({
                        type: 'systemMessage',
                        message: `🏆 Congratulations! You won the game with ${gameWinner.placementPoints} placement points!`,
                        color: 'FFD700' // Gold color
                    });
                }
            });

            // Use player number for clearer winner announcement
            this.world.entityManager.getAllPlayerEntities().forEach(playerEntity => {
                playerEntity.player.ui.sendData({
                    type: 'systemMessage',
                    message: `Game Over! Player ${gameWinner.playerNumber} wins!`,
                    color: 'FFD700'
                });
            });
        }

        // Reset game after delay
        setTimeout(() => {
            this.resetGame();
        }, 10000);
    }

    // Add method to get remaining rounds
    public getRemainingRounds(): number {
        return this.GAME_CONFIG.maxRounds - this.currentRound;
    }
}

================
File: src/managers/score-manager.js
================
"use strict";
// The ScoreManager handles player scoring for block breaks and other game events
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScoreManager = void 0;
var hytopia_1 = require("hytopia");
var scene_ui_manager_1 = require("../scene-ui/scene-ui-manager");
var audio_manager_1 = require("./audio-manager");
var ScoreManager = /** @class */ (function (_super) {
    __extends(ScoreManager, _super);
    function ScoreManager() {
        var _this = _super.call(this, {
            name: 'ScoreManager',
            blockTextureUri: 'blocks/stone.png', // Use a basic block texture that definitely exists
            blockHalfExtents: { x: 0.5, y: 0.5, z: 0.5 } // Normal scale, will be positioned out of view anyway
        }) || this;
        // Map to hold scores and stats for each player by their ID
        _this.playerStats = new Map();
        _this.playerCount = 0;
        return _this;
    }
    ScoreManager.prototype.spawn = function (world, position) {
        // Position it far away where it won't be visible
        _super.prototype.spawn.call(this, world, { x: 0, y: -1000, z: 0 });
    };
    // Initialize a score entry for a player
    ScoreManager.prototype.initializePlayer = function (playerId) {
        if (!this.playerStats.has(playerId)) {
            this.playerCount++;
            this.playerStats.set(playerId, {
                totalScore: 0,
                roundScore: 0,
                placementPoints: 0, // Initialize placement points
                wins: 0,
                playerNumber: this.playerCount,
                consecutiveHits: 0,
                multiHitCount: 0,
                lastHitTime: 0
            });
        }
    };
    // Remove a player's score when they leave the game
    ScoreManager.prototype.removePlayer = function (playerId) {
        if (this.playerStats.has(playerId)) {
            this.playerCount--;
            this.playerStats.delete(playerId);
        }
    };
    // Start a new round - reset round scores and total scores, but keep placement points
    ScoreManager.prototype.startNewRound = function () {
        for (var _i = 0, _a = this.playerStats.entries(); _i < _a.length; _i++) {
            var _b = _a[_i], playerId = _b[0], stats = _b[1];
            stats.totalScore = 0; // Reset total score at start of round
            stats.roundScore = 0; // Reset round score
            stats.consecutiveHits = 0;
            stats.multiHitCount = 0;
            stats.lastHitTime = 0;
            this.playerStats.set(playerId, stats);
        }
    };
    // Add a win for the player with the highest score in the round
    ScoreManager.prototype.handleRoundEnd = function () {
        var _this = this;
        // Sort players by round score in descending order
        var sortedPlayers = Array.from(this.playerStats.entries())
            .sort(function (a, b) { return b[1].roundScore - a[1].roundScore; });
        var playerCount = sortedPlayers.length;
        var placements = [];
        // Handle ties by giving same points to players with equal scores
        var currentPoints = playerCount;
        var currentScore = -1;
        var sameScoreCount = 0;
        sortedPlayers.forEach(function (entry, index) {
            var playerId = entry[0], stats = entry[1];
            // If this is a new score, update the points
            if (stats.roundScore !== currentScore) {
                currentPoints = playerCount - index;
                currentScore = stats.roundScore;
                sameScoreCount = 0;
            }
            else {
                sameScoreCount++;
            }
            stats.placementPoints += currentPoints; // Add to placement points
            _this.playerStats.set(playerId, stats);
            placements.push({ playerId: playerId, points: currentPoints });
        });
        var winnerId = sortedPlayers.length > 0 ? sortedPlayers[0][0] : null;
        if (winnerId) {
            var stats = this.playerStats.get(winnerId);
            stats.wins++;
            this.playerStats.set(winnerId, stats);
        }
        return { winnerId: winnerId, placements: placements };
    };
    // Increment (or decrement) player's score
    ScoreManager.prototype.addScore = function (playerId, score) {
        var stats = this.playerStats.get(playerId);
        if (stats) {
            stats.totalScore += score;
            stats.roundScore += score;
            this.playerStats.set(playerId, stats);
            // Play the score sound effect
            if (this.world && score > 0) {
                var audioManager = audio_manager_1.AudioManager.getInstance(this.world);
                audioManager.playSoundEffect('audio/sfx/damage/blop1.mp3', 0.4); // 0.4 volume for less intrusive feedback
            }
        }
    };
    // Get the current total score for a player
    ScoreManager.prototype.getScore = function (playerId) {
        var _a, _b;
        return (_b = (_a = this.playerStats.get(playerId)) === null || _a === void 0 ? void 0 : _a.totalScore) !== null && _b !== void 0 ? _b : 0;
    };
    // Get the current round score for a player
    ScoreManager.prototype.getRoundScore = function (playerId) {
        var _a, _b;
        return (_b = (_a = this.playerStats.get(playerId)) === null || _a === void 0 ? void 0 : _a.roundScore) !== null && _b !== void 0 ? _b : 0;
    };
    // Get wins for a player
    ScoreManager.prototype.getWins = function (playerId) {
        var _a, _b;
        return (_b = (_a = this.playerStats.get(playerId)) === null || _a === void 0 ? void 0 : _a.wins) !== null && _b !== void 0 ? _b : 0;
    };
    // Reset score for a player
    ScoreManager.prototype.resetScore = function (playerId) {
        var stats = this.playerStats.get(playerId);
        if (stats) {
            stats.totalScore = 0;
            stats.roundScore = 0;
            this.playerStats.set(playerId, stats);
        }
    };
    // Reset all players' scores
    ScoreManager.prototype.resetAllScores = function () {
        for (var _i = 0, _a = this.playerStats.keys(); _i < _a.length; _i++) {
            var playerId = _a[_i];
            this.resetScore(playerId);
        }
    };
    // Reset all stats including wins and placement points
    ScoreManager.prototype.resetAllStats = function () {
        for (var _i = 0, _a = this.playerStats.entries(); _i < _a.length; _i++) {
            var _b = _a[_i], playerId = _b[0], stats = _b[1];
            stats.totalScore = 0;
            stats.roundScore = 0;
            stats.placementPoints = 0; // Reset placement points
            stats.wins = 0;
            stats.consecutiveHits = 0;
            stats.multiHitCount = 0;
            stats.lastHitTime = 0;
            this.playerStats.set(playerId, stats);
        }
    };
    // Add this method to broadcast scores and leaderboard
    ScoreManager.prototype.broadcastScores = function (world) {
        var _this = this;
        var scores = Array.from(world.entityManager.getAllPlayerEntities()).map(function (playerEntity) { return ({
            playerId: playerEntity.player.id,
            totalPoints: _this.getScore(playerEntity.player.id),
            roundScore: _this.getRoundScore(playerEntity.player.id)
        }); });
        // Create leaderboard data sorted by placement points
        var leaderboard = Array.from(this.playerStats.entries())
            .map(function (_a) {
            var playerId = _a[0], stats = _a[1];
            return ({
                playerNumber: stats.playerNumber,
                points: stats.placementPoints, // Use placement points for leaderboard
                isLeading: _this.isLeadingByPlacements(playerId) // New method for placement-based leading
            });
        })
            .sort(function (a, b) { return b.points - a.points; });
        world.entityManager.getAllPlayerEntities().forEach(function (playerEntity) {
            playerEntity.player.ui.sendData({
                type: 'updateScores',
                scores: scores
            });
            playerEntity.player.ui.sendData({
                type: 'updateLeaderboard',
                leaderboard: leaderboard
            });
        });
    };
    // New method to check who's leading by placement points
    ScoreManager.prototype.isLeadingByPlacements = function (playerId) {
        var _a, _b;
        var playerPoints = (_b = (_a = this.playerStats.get(playerId)) === null || _a === void 0 ? void 0 : _a.placementPoints) !== null && _b !== void 0 ? _b : 0;
        return Array.from(this.playerStats.values())
            .every(function (stats) { return stats.placementPoints <= playerPoints; });
    };
    // Calculate Euclidean distance between two points
    ScoreManager.prototype.calculateDistance = function (point1, point2) {
        var dx = point2.x - point1.x;
        var dy = point2.y - point1.y;
        var dz = point2.z - point1.z;
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    };
    // Calculate average of target's half-extents (S)
    ScoreManager.prototype.calculateAverageSize = function (halfExtents) {
        // Get the full dimensions by multiplying by 2 (since these are half-extents)
        var fullWidth = Math.max(halfExtents.x * 2, 2); // Minimum size of 2 for standard blocks
        var fullHeight = Math.max(halfExtents.y * 2, 2);
        var fullDepth = Math.max(halfExtents.z * 2, 2);
        // Calculate the average dimension, considering the actual block formation
        return (fullWidth + fullHeight + fullDepth) / 3;
    };
    // Get movement multiplier based on block type
    ScoreManager.prototype.getMovementMultiplier = function (block) {
        var behaviorType = block.getMovementBehaviorType();
        console.log("Determining multiplier for behavior type: ".concat(behaviorType));
        switch (behaviorType) {
            case 'ZAxisMovement':
                return ScoreManager.SCORING_CONFIG.Z_AXIS_MULTIPLIER;
            case 'SineWaveMovement':
                return ScoreManager.SCORING_CONFIG.SINE_WAVE_MULTIPLIER;
            case 'VerticalWaveMovement':
                return ScoreManager.SCORING_CONFIG.VERTICAL_WAVE_MULTIPLIER;
            case 'PopUpMovement':
                return ScoreManager.SCORING_CONFIG.POPUP_MULTIPLIER;
            case 'RisingMovement':
                return ScoreManager.SCORING_CONFIG.RISING_MULTIPLIER;
            case 'ParabolicMovement':
                return ScoreManager.SCORING_CONFIG.PARABOLIC_MULTIPLIER;
            case 'PendulumMovement':
                return ScoreManager.SCORING_CONFIG.PENDULUM_MULTIPLIER;
            default:
                return ScoreManager.SCORING_CONFIG.BASE_MOVEMENT_MULTIPLIER;
        }
    };
    // Update combo and multi-hit counters
    ScoreManager.prototype.updateHitCounters = function (playerId, hitPosition) {
        var _a;
        var stats = this.playerStats.get(playerId);
        if (!stats)
            return;
        var currentTime = Date.now();
        // Check if within combo window
        if (currentTime - stats.lastHitTime <= ScoreManager.SCORING_CONFIG.COMBO_TIMEOUT_MS) {
            stats.consecutiveHits++;
            stats.multiHitCount++;
        }
        else {
            stats.consecutiveHits = 1;
            stats.multiHitCount = 1;
        }
        stats.lastHitTime = currentTime;
        this.playerStats.set(playerId, stats);
        var comboBonus = Math.min((stats.consecutiveHits - 1) * 0.15, ScoreManager.SCORING_CONFIG.MAX_COMBO_BONUS);
        var multiHitBonus = Math.min((stats.multiHitCount - 1) * 0.1, ScoreManager.SCORING_CONFIG.MAX_MULTI_HIT_BONUS);
        // Show combo notification for 3+ hits
        if (stats.consecutiveHits >= 3 && this.world) {
            var totalBonus = Math.round((comboBonus + multiHitBonus) * 100);
            var player = (_a = this.world.entityManager.getAllPlayerEntities()
                .find(function (entity) { return entity.player.id === playerId; })) === null || _a === void 0 ? void 0 : _a.player;
            if (player) {
                scene_ui_manager_1.SceneUIManager.getInstance(this.world).showComboNotification(stats.consecutiveHits, totalBonus, player);
            }
        }
        console.log("Player ".concat(playerId, " hit counters updated:"), {
            consecutiveHits: stats.consecutiveHits,
            multiHitCount: stats.multiHitCount,
            comboTimeRemaining: ScoreManager.SCORING_CONFIG.COMBO_TIMEOUT_MS - (currentTime - stats.lastHitTime),
            currentComboBonus: comboBonus.toFixed(2),
            currentMultiHitBonus: multiHitBonus.toFixed(2)
        });
    };
    // Calculate the dynamic score for a grenade hit
    ScoreManager.prototype.calculateGrenadeTargetScore = function (projectile, block, impactPoint, playerId) {
        var spawnOrigin = projectile.getSpawnOrigin();
        if (!spawnOrigin) {
            console.warn('No spawn origin found for projectile, using default score');
            return ScoreManager.SCORING_CONFIG.MIN_SCORE;
        }
        // Calculate distance (D)
        var distance = this.calculateDistance(spawnOrigin, impactPoint);
        console.log('🎯 Distance Analysis:', {
            spawnPoint: spawnOrigin,
            impactPoint: impactPoint,
            distance: distance.toFixed(2),
            explanation: 'Higher distance should increase score'
        });
        // Calculate size factor (S)
        var averageSize = this.calculateAverageSize(block.getBlockDimensions());
        console.log('📏 Size Analysis:', {
            blockDimensions: block.getBlockDimensions(),
            averageSize: averageSize.toFixed(2),
            distanceToSizeRatio: (distance / averageSize).toFixed(2),
            explanation: 'Smaller targets should give higher scores'
        });
        // Get movement multiplier (M)
        var movementMultiplier = this.getMovementMultiplier(block);
        console.log('🔄 Movement Analysis:', {
            behaviorType: block.getMovementBehaviorType(),
            multiplier: movementMultiplier,
            explanation: "Using ".concat(movementMultiplier, "x multiplier based on movement pattern")
        });
        // Calculate time factor (T)
        var elapsedTime = (Date.now() - block.getSpawnTime()) / 1000; // Convert to seconds
        var timeFactor = ScoreManager.SCORING_CONFIG.TIME_DECAY_FACTOR / (elapsedTime + ScoreManager.SCORING_CONFIG.TIME_DECAY_FACTOR);
        console.log('⏱️ Time Analysis:', {
            elapsedSeconds: elapsedTime.toFixed(2),
            decayFactor: ScoreManager.SCORING_CONFIG.TIME_DECAY_FACTOR,
            timeFactor: timeFactor.toFixed(4),
            explanation: 'Time factor decreases score for older targets'
        });
        // Get combo (C) and multi-hit (H) bonuses
        var stats = this.playerStats.get(playerId);
        if (!stats) {
            console.warn('No stats found for player, initializing new stats');
            this.initializePlayer(playerId);
        }
        this.updateHitCounters(playerId, impactPoint);
        var updatedStats = this.playerStats.get(playerId);
        var comboBonus = Math.min((updatedStats.consecutiveHits - 1) * 0.15, ScoreManager.SCORING_CONFIG.MAX_COMBO_BONUS);
        var multiHitBonus = Math.min((updatedStats.multiHitCount - 1) * 0.1, ScoreManager.SCORING_CONFIG.MAX_MULTI_HIT_BONUS);
        console.log('🔄 Combo Analysis:', {
            consecutiveHits: updatedStats.consecutiveHits,
            maxComboBonus: ScoreManager.SCORING_CONFIG.MAX_COMBO_BONUS,
            actualComboBonus: comboBonus.toFixed(2),
            explanation: "".concat(updatedStats.consecutiveHits, " consecutive hits = ").concat(comboBonus.toFixed(2), "x bonus")
        });
        console.log('🎯 Multi-Hit Analysis:', {
            multiHitCount: updatedStats.multiHitCount,
            maxMultiHitBonus: ScoreManager.SCORING_CONFIG.MAX_MULTI_HIT_BONUS,
            actualMultiHitBonus: multiHitBonus.toFixed(2),
            explanation: "".concat(updatedStats.multiHitCount, " hits on target = ").concat(multiHitBonus.toFixed(2), "x bonus")
        });
        // Calculate base score components
        var distanceSizeFactor = distance / averageSize;
        var baseScore = distanceSizeFactor *
            movementMultiplier *
            timeFactor *
            ScoreManager.SCORING_CONFIG.BASE_SCORE_MULTIPLIER;
        var bonusMultiplier = 1 + comboBonus + multiHitBonus;
        var finalScore = Math.max(ScoreManager.SCORING_CONFIG.MIN_SCORE, Math.round(baseScore * bonusMultiplier));
        console.log('💯 Final Score Breakdown:', {
            components: {
                distanceSizeFactor: distanceSizeFactor.toFixed(2),
                movementMultiplier: movementMultiplier.toFixed(2),
                timeFactor: timeFactor.toFixed(2),
                baseMultiplier: ScoreManager.SCORING_CONFIG.BASE_SCORE_MULTIPLIER,
                bonusMultiplier: bonusMultiplier.toFixed(2)
            },
            calculations: {
                baseScore: baseScore.toFixed(2),
                afterBonuses: (baseScore * bonusMultiplier).toFixed(2),
                finalScore: finalScore
            },
            formula: 'Score = ((D/S * M * timeFactor * BASE_MULTIPLIER) * (1 + C + H))'
        });
        return finalScore;
    };
    // Add new method to reset combo
    ScoreManager.prototype.resetCombo = function (playerId) {
        var stats = this.playerStats.get(playerId);
        if (stats) {
            var hadCombo = stats.consecutiveHits >= 3;
            stats.consecutiveHits = 0;
            stats.multiHitCount = 0;
            this.playerStats.set(playerId, stats);
            // Only notify UI if there was an active combo
            if (hadCombo && this.world) {
                this.world.entityManager.getAllPlayerEntities()
                    .filter(function (entity) { return entity.player.id === playerId; })
                    .forEach(function (entity) {
                    entity.player.ui.sendData({
                        type: 'resetCombo'
                    });
                });
            }
        }
    };
    // Add this new method to get placement points
    ScoreManager.prototype.getLeaderboardPoints = function (playerId) {
        var _a, _b;
        return (_b = (_a = this.playerStats.get(playerId)) === null || _a === void 0 ? void 0 : _a.placementPoints) !== null && _b !== void 0 ? _b : 0;
    };
    ScoreManager.SCORING_CONFIG = {
        COMBO_TIMEOUT_MS: 4000, // Increased combo window for early rounds
        TIME_DECAY_FACTOR: 20.0, // More forgiving time decay
        BASE_SCORE_MULTIPLIER: 1.0, // Reduced base multiplier to make progression more meaningful
        MIN_SCORE: 5, // Increased minimum score for better feedback
        // Movement multipliers adjusted for progression
        BASE_MOVEMENT_MULTIPLIER: 1.0, // Base for static targets
        Z_AXIS_MULTIPLIER: 4.0, // New multiplier for Z-Axis blocks
        SINE_WAVE_MULTIPLIER: 3.0, // Reduced from 2.5 for better scaling
        VERTICAL_WAVE_MULTIPLIER: 3.0, // Reduced from 3.0
        POPUP_MULTIPLIER: 4.0, // Reduced from 3.5
        RISING_MULTIPLIER: 5.5, // Reduced from 4.0
        PARABOLIC_MULTIPLIER: 6.0, // Reduced from 4.5
        PENDULUM_MULTIPLIER: 5.0, // Added for pendulum targets
        // Combo system adjusted for early game
        MAX_COMBO_BONUS: 0.5, // Slightly reduced max combo
        MAX_MULTI_HIT_BONUS: 0.3, // Slightly reduced multi-hit
    };
    return ScoreManager;
}(hytopia_1.Entity));
exports.ScoreManager = ScoreManager;

================
File: src/managers/score-manager.ts
================
// The ScoreManager handles player scoring for block breaks and other game events

import { World, Vector3Like, Entity } from 'hytopia';
import { MovingBlockEntity, MOVING_BLOCK_CONFIG } from '../moving_blocks/moving-block-entity';
import { ProjectileEntity } from '../entities/projectile-entity';
import { SceneUIManager } from '../scene-ui/scene-ui-manager';
import { AudioManager } from './audio-manager';

export interface ScoreOptions {
  score: number;
}

interface PlayerStats {
  totalScore: number;     // Overall game total score
  roundScore: number;     // Current round's accumulated score
  lastScore: number;      // Last individual score received
  placementPoints: number;  // Points from placements at end of rounds
  wins: number;
  playerNumber: number;
  consecutiveHits: number;  
  multiHitCount: number;    
  lastHitTime: number;
  previousRank: number;     // Previous rank in the leaderboard
  currentRank: number;      // Current rank in the leaderboard
}

export class ScoreManager extends Entity {
  private static readonly SCORING_CONFIG = {
    COMBO_TIMEOUT_MS: 4000,         // Increased combo window for early rounds
    TIME_DECAY_FACTOR: 20.0,        // More forgiving time decay
    BASE_SCORE_MULTIPLIER: 1.0,     // Reduced base multiplier to make progression more meaningful
    MIN_SCORE: 5,                   // Increased minimum score for better feedback
    
    // Movement multipliers adjusted for progression
    BASE_MOVEMENT_MULTIPLIER: 1.0,   // Base for static targets
    Z_AXIS_MULTIPLIER: 4.0,         // New multiplier for Z-Axis blocks
    SINE_WAVE_MULTIPLIER: 3.0,      // Reduced from 2.5 for better scaling
    VERTICAL_WAVE_MULTIPLIER: 3.0,   // Reduced from 3.0
    POPUP_MULTIPLIER: 4.0,          // Reduced from 3.5
    RISING_MULTIPLIER: 5.5,         // Reduced from 4.0
    PARABOLIC_MULTIPLIER: 6.0,      // Reduced from 4.5
    PENDULUM_MULTIPLIER: 5.0,       // Added for pendulum targets
    
    // Combo system adjusted for early game
    MAX_COMBO_BONUS: 0.5,           // Slightly reduced max combo
    MAX_MULTI_HIT_BONUS: 0.3,       // Slightly reduced multi-hit
  };

  // Map to hold scores and stats for each player by their ID
  private playerStats = new Map<string, PlayerStats>();
  private playerCount = 0;

  constructor() {
    super({
      name: 'ScoreManager',
      blockTextureUri: 'blocks/stone.png',  // Use a basic block texture that definitely exists
      blockHalfExtents: { x: 0.5, y: 0.5, z: 0.5 }  // Normal scale, will be positioned out of view anyway
    });
  }

  override spawn(world: World, position: Vector3Like): void {
    // Position it far away where it won't be visible
    super.spawn(world, { x: 0, y: -1000, z: 0 });
  }

  // Initialize a score entry for a player
  public initializePlayer(playerId: string): void {
    if (!this.playerStats.has(playerId)) {
      this.playerCount++;
      this.playerStats.set(playerId, {
        totalScore: 0,
        roundScore: 0,
        lastScore: 0,      // Initialize last score
        placementPoints: 0,  // Initialize placement points
        wins: 0,
        playerNumber: this.playerCount,
        consecutiveHits: 0,
        multiHitCount: 0,
        lastHitTime: 0,
        previousRank: 0,     // Initialize previous rank (0 means new player)
        currentRank: this.playerCount // Default to last place initially
      });
    }
  }

  // Remove a player's score when they leave the game
  public removePlayer(playerId: string): void {
    if (this.playerStats.has(playerId)) {
      this.playerCount--;
      this.playerStats.delete(playerId);
    }
  }

  // Start a new round - reset round scores and total scores, but keep placement points and ranking
  public startNewRound(): void {
    for (const [playerId, stats] of this.playerStats.entries()) {
      stats.totalScore = 0;  // Reset total score at start of round
      stats.roundScore = 0;  // Reset round score
      stats.lastScore = 0;   // Reset last score
      stats.consecutiveHits = 0;
      stats.multiHitCount = 0;
      stats.lastHitTime = 0;
      // Keep previousRank and currentRank values
      this.playerStats.set(playerId, stats);
    }
  }

  // Add a win for the player with the highest score in the round
  public handleRoundEnd(): { winnerId: string | null, placements: Array<{ playerId: string, points: number }> } {
    // Update previous ranks before calculating new ones
    // Store current ranks as previous ranks
    for (const [playerId, stats] of this.playerStats.entries()) {
        stats.previousRank = stats.currentRank;
        this.playerStats.set(playerId, stats);
    }

    // Sort players by round score in descending order
    const sortedPlayers = Array.from(this.playerStats.entries())
        .sort((a, b) => b[1].roundScore - a[1].roundScore);

    const playerCount = sortedPlayers.length;
    const placements: Array<{ playerId: string, points: number }> = [];
    
    // Handle ties by giving same points to players with equal scores
    let currentPoints = playerCount;
    let currentScore = -1;
    let sameScoreCount = 0;

    sortedPlayers.forEach((entry, index) => {
        const [playerId, stats] = entry;
        
        // If this is a new score, update the points
        if (stats.roundScore !== currentScore) {
            currentPoints = playerCount - index;
            currentScore = stats.roundScore;
            sameScoreCount = 0;
        } else {
            sameScoreCount++;
        }
        
        stats.placementPoints += currentPoints; // Add to placement points
        this.playerStats.set(playerId, stats);
        
        placements.push({ playerId, points: currentPoints });
    });

    // Update current ranks based on updated placement points
    // Sort players by total placement points for the final leaderboard
    const leaderboardRanking = Array.from(this.playerStats.entries())
        .sort((a, b) => b[1].placementPoints - a[1].placementPoints);

    // Assign new ranks, handling ties
    let currentRank = 1;
    let lastPointsValue = -1;
    leaderboardRanking.forEach((entry, index) => {
        const [playerId, stats] = entry;
        
        // If this is a new score, update the rank
        if (stats.placementPoints !== lastPointsValue) {
            currentRank = index + 1;
            lastPointsValue = stats.placementPoints;
        }
        
        stats.currentRank = currentRank;
        this.playerStats.set(playerId, stats);
    });

    const winnerId = sortedPlayers.length > 0 ? sortedPlayers[0][0] : null;
    if (winnerId) {
        const stats = this.playerStats.get(winnerId)!;
        stats.wins++;
        this.playerStats.set(winnerId, stats);
    }

    return { winnerId, placements };
  }

  // Increment (or decrement) player's score
  public addScore(playerId: string, score: number): void {
    const stats = this.playerStats.get(playerId);
    if (stats) {
      stats.totalScore += score;
      stats.roundScore += score;
      stats.lastScore = score; // Store the last individual score separately
      this.playerStats.set(playerId, stats);

      // Play the score sound effect
      if (this.world && score > 0) {
        const audioManager = AudioManager.getInstance(this.world);
        audioManager.playSoundEffect('audio/sfx/damage/blop1.mp3', 0.4);  // 0.4 volume for less intrusive feedback
      }
    }
  }

  // Get the current total score for a player
  public getScore(playerId: string): number {
    return this.playerStats.get(playerId)?.totalScore ?? 0;
  }

  // Get the current round score for a player
  public getRoundScore(playerId: string): number {
    return this.playerStats.get(playerId)?.roundScore ?? 0;
  }
  
  // Get the last individual score received for a player
  public getLastScore(playerId: string): number {
    return this.playerStats.get(playerId)?.lastScore ?? 0;
  }

  // Get wins for a player
  public getWins(playerId: string): number {
    return this.playerStats.get(playerId)?.wins ?? 0;
  }

  // Reset score for a player
  public resetScore(playerId: string): void {
    const stats = this.playerStats.get(playerId);
    if (stats) {
      stats.totalScore = 0;
      stats.roundScore = 0;
      stats.lastScore = 0;
      this.playerStats.set(playerId, stats);
    }
  }

  // Reset all players' scores
  public resetAllScores(): void {
    for (const playerId of this.playerStats.keys()) {
      this.resetScore(playerId);
    }
  }

  // Reset all stats including wins and placement points
  public resetAllStats(): void {
    for (const [playerId, stats] of this.playerStats.entries()) {
      stats.totalScore = 0;
      stats.roundScore = 0;
      stats.lastScore = 0;
      stats.placementPoints = 0;  // Reset placement points
      stats.wins = 0;
      stats.consecutiveHits = 0;
      stats.multiHitCount = 0;
      stats.lastHitTime = 0;
      stats.previousRank = 0;  // Reset to "new player" state
      stats.currentRank = stats.playerNumber;  // Default to player number order
      this.playerStats.set(playerId, stats);
    }
  }

  // Colors for player identification
  private static readonly PLAYER_COLORS = [
    '#4CAF50', // Green
    '#2196F3', // Blue
    '#FFC107', // Amber
    '#E91E63', // Pink
    '#9C27B0', // Purple
    '#FF5722', // Deep Orange
    '#00BCD4', // Cyan
    '#FFEB3B'  // Yellow
  ];

  // Add this method to broadcast scores and leaderboard
  public broadcastScores(world: World) {
    const playerEntities = Array.from(world.entityManager.getAllPlayerEntities());
    
    // Build scores with player details
    const scores = playerEntities.map(playerEntity => ({
        playerId: playerEntity.player.id,
        playerNumber: this.playerStats.get(playerEntity.player.id)?.playerNumber || 0,
        playerColor: ScoreManager.PLAYER_COLORS[(this.playerStats.get(playerEntity.player.id)?.playerNumber || 1) - 1],
        totalPoints: this.getScore(playerEntity.player.id),
        roundScore: this.getRoundScore(playerEntity.player.id),
        lastScore: this.getLastScore(playerEntity.player.id)
    }));

    // Create leaderboard data sorted by placement points
    const leaderboard = Array.from(this.playerStats.entries())
        .map(([playerId, stats]) => {
            // Calculate the ranking change
            let rankChange = 'same';
            if (stats.previousRank === 0) {
                rankChange = 'new'; // New player
            } else if (stats.currentRank < stats.previousRank) {
                rankChange = 'up'; // Moved up in rankings
            } else if (stats.currentRank > stats.previousRank) {
                rankChange = 'down'; // Moved down in rankings
            }
            
            return {
                playerId,
                playerNumber: stats.playerNumber,
                playerColor: ScoreManager.PLAYER_COLORS[stats.playerNumber - 1],
                points: stats.placementPoints, // Use placement points for leaderboard
                isLeading: this.isLeadingByPlacements(playerId), // For highlighting the leading player
                currentRank: stats.currentRank,
                previousRank: stats.previousRank,
                rankChange: rankChange
            };
        })
        .sort((a, b) => a.currentRank - b.currentRank); // Sort by rank now instead of points

    world.entityManager.getAllPlayerEntities().forEach(playerEntity => {
        // Get player's own ID to highlight their scores in UI
        const currentPlayerId = playerEntity.player.id;

        playerEntity.player.ui.sendData({
            type: 'updateScores',
            scores,
            currentPlayerId
        });
        
        playerEntity.player.ui.sendData({
            type: 'updateLeaderboard',
            leaderboard,
            currentPlayerId
        });
    });
  }

  // New method to check who's leading by placement points
  private isLeadingByPlacements(playerId: string): boolean {
    const playerPoints = this.playerStats.get(playerId)?.placementPoints ?? 0;
    return Array.from(this.playerStats.values())
        .every(stats => stats.placementPoints <= playerPoints);
  }

  // Calculate Euclidean distance between two points
  private calculateDistance(point1: Vector3Like, point2: Vector3Like): number {
    const dx = point2.x - point1.x;
    const dy = point2.y - point1.y;
    const dz = point2.z - point1.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }

  // Calculate average of target's half-extents (S)
  private calculateAverageSize(halfExtents: Vector3Like): number {
    // Get the full dimensions by multiplying by 2 (since these are half-extents)
    const fullWidth = Math.max(halfExtents.x * 2, 2); // Minimum size of 2 for standard blocks
    const fullHeight = Math.max(halfExtents.y * 2, 2);
    const fullDepth = Math.max(halfExtents.z * 2, 2);
    
    // Calculate the average dimension, considering the actual block formation
    return (fullWidth + fullHeight + fullDepth) / 3;
  }

  // Get movement multiplier based on block type
  private getMovementMultiplier(block: MovingBlockEntity): number {
    const behaviorType = block.getMovementBehaviorType();
    console.log(`Determining multiplier for behavior type: ${behaviorType}`);
    
    switch (behaviorType) {
      case 'ZAxisMovement':
        return ScoreManager.SCORING_CONFIG.Z_AXIS_MULTIPLIER;
      case 'SineWaveMovement':
        return ScoreManager.SCORING_CONFIG.SINE_WAVE_MULTIPLIER;
      case 'VerticalWaveMovement':
        return ScoreManager.SCORING_CONFIG.VERTICAL_WAVE_MULTIPLIER;
      case 'PopUpMovement':
        return ScoreManager.SCORING_CONFIG.POPUP_MULTIPLIER;
      case 'RisingMovement':
        return ScoreManager.SCORING_CONFIG.RISING_MULTIPLIER;
      case 'ParabolicMovement':
        return ScoreManager.SCORING_CONFIG.PARABOLIC_MULTIPLIER;
      case 'PendulumMovement':
        return ScoreManager.SCORING_CONFIG.PENDULUM_MULTIPLIER;
      default:
        return ScoreManager.SCORING_CONFIG.BASE_MOVEMENT_MULTIPLIER;
    }
  }

  // Update combo and multi-hit counters
  private updateHitCounters(playerId: string, hitPosition: Vector3Like): void {
    const stats = this.playerStats.get(playerId);
    if (!stats) return;

    const currentTime = Date.now();
    
    // Check if within combo window
    if (currentTime - stats.lastHitTime <= ScoreManager.SCORING_CONFIG.COMBO_TIMEOUT_MS) {
      stats.consecutiveHits++;
      stats.multiHitCount++;
    } else {
      stats.consecutiveHits = 1;
      stats.multiHitCount = 1;
    }
    
    stats.lastHitTime = currentTime;
    this.playerStats.set(playerId, stats);
    
    const comboBonus = Math.min(
      (stats.consecutiveHits - 1) * 0.15,
      ScoreManager.SCORING_CONFIG.MAX_COMBO_BONUS
    );
    
    const multiHitBonus = Math.min(
      (stats.multiHitCount - 1) * 0.1,
      ScoreManager.SCORING_CONFIG.MAX_MULTI_HIT_BONUS
    );

    // Show combo notification for 3+ hits
    if (stats.consecutiveHits >= 3 && this.world) {
      const totalBonus = Math.round((comboBonus + multiHitBonus) * 100);
      const player = this.world.entityManager.getAllPlayerEntities()
        .find(entity => entity.player.id === playerId)?.player;
      
      if (player) {
        SceneUIManager.getInstance(this.world).showComboNotification(
          stats.consecutiveHits,
          totalBonus,
          player
        );
      }
    }

    console.log(`Player ${playerId} hit counters updated:`, {
      consecutiveHits: stats.consecutiveHits,
      multiHitCount: stats.multiHitCount,
      comboTimeRemaining: ScoreManager.SCORING_CONFIG.COMBO_TIMEOUT_MS - (currentTime - stats.lastHitTime),
      currentComboBonus: comboBonus.toFixed(2),
      currentMultiHitBonus: multiHitBonus.toFixed(2)
    });
  }

  // Calculate the dynamic score for a grenade hit
  public calculateGrenadeTargetScore(
    projectile: ProjectileEntity,
    block: MovingBlockEntity,
    impactPoint: Vector3Like,
    playerId: string
  ): number {
    const spawnOrigin = projectile.getSpawnOrigin();
    if (!spawnOrigin) {
      console.warn('No spawn origin found for projectile, using default score');
      return ScoreManager.SCORING_CONFIG.MIN_SCORE;
    }

    // Calculate distance (D)
    const distance = this.calculateDistance(spawnOrigin, impactPoint);
    console.log('🎯 Distance Analysis:', {
      spawnPoint: spawnOrigin,
      impactPoint,
      distance: distance.toFixed(2),
      explanation: 'Higher distance should increase score'
    });

    // Calculate size factor (S)
    const averageSize = this.calculateAverageSize(block.getBlockDimensions());
    console.log('📏 Size Analysis:', {
      blockDimensions: block.getBlockDimensions(),
      averageSize: averageSize.toFixed(2),
      distanceToSizeRatio: (distance / averageSize).toFixed(2),
      explanation: 'Smaller targets should give higher scores'
    });

    // Get movement multiplier (M)
    const movementMultiplier = this.getMovementMultiplier(block);
    console.log('🔄 Movement Analysis:', {
      behaviorType: block.getMovementBehaviorType(),
      multiplier: movementMultiplier,
      explanation: `Using ${movementMultiplier}x multiplier based on movement pattern`
    });

    // Calculate time factor (T)
    const elapsedTime = (Date.now() - block.getSpawnTime()) / 1000; // Convert to seconds
    const timeFactor = ScoreManager.SCORING_CONFIG.TIME_DECAY_FACTOR / (elapsedTime + ScoreManager.SCORING_CONFIG.TIME_DECAY_FACTOR);
    console.log('⏱️ Time Analysis:', {
      elapsedSeconds: elapsedTime.toFixed(2),
      decayFactor: ScoreManager.SCORING_CONFIG.TIME_DECAY_FACTOR,
      timeFactor: timeFactor.toFixed(4),
      explanation: 'Time factor decreases score for older targets'
    });

    // Get combo (C) and multi-hit (H) bonuses
    const stats = this.playerStats.get(playerId);
    if (!stats) {
      console.warn('No stats found for player, initializing new stats');
      this.initializePlayer(playerId);
    }
    
    this.updateHitCounters(playerId, impactPoint);
    const updatedStats = this.playerStats.get(playerId)!;
    
    const comboBonus = Math.min(
      (updatedStats.consecutiveHits - 1) * 0.15,
      ScoreManager.SCORING_CONFIG.MAX_COMBO_BONUS
    );
    
    const multiHitBonus = Math.min(
      (updatedStats.multiHitCount - 1) * 0.1,
      ScoreManager.SCORING_CONFIG.MAX_MULTI_HIT_BONUS
    );

    console.log('🔄 Combo Analysis:', {
      consecutiveHits: updatedStats.consecutiveHits,
      maxComboBonus: ScoreManager.SCORING_CONFIG.MAX_COMBO_BONUS,
      actualComboBonus: comboBonus.toFixed(2),
      explanation: `${updatedStats.consecutiveHits} consecutive hits = ${comboBonus.toFixed(2)}x bonus`
    });

    console.log('🎯 Multi-Hit Analysis:', {
      multiHitCount: updatedStats.multiHitCount,
      maxMultiHitBonus: ScoreManager.SCORING_CONFIG.MAX_MULTI_HIT_BONUS,
      actualMultiHitBonus: multiHitBonus.toFixed(2),
      explanation: `${updatedStats.multiHitCount} hits on target = ${multiHitBonus.toFixed(2)}x bonus`
    });

    // Calculate base score components
    const distanceSizeFactor = distance / averageSize;
    const baseScore = distanceSizeFactor * 
                     movementMultiplier * 
                     timeFactor * 
                     ScoreManager.SCORING_CONFIG.BASE_SCORE_MULTIPLIER;
                     
    const bonusMultiplier = 1 + comboBonus + multiHitBonus;
    const finalScore = Math.max(
      ScoreManager.SCORING_CONFIG.MIN_SCORE,
      Math.round(baseScore * bonusMultiplier)
    );

    console.log('💯 Final Score Breakdown:', {
      components: {
        distanceSizeFactor: distanceSizeFactor.toFixed(2),
        movementMultiplier: movementMultiplier.toFixed(2),
        timeFactor: timeFactor.toFixed(2),
        baseMultiplier: ScoreManager.SCORING_CONFIG.BASE_SCORE_MULTIPLIER,
        bonusMultiplier: bonusMultiplier.toFixed(2)
      },
      calculations: {
        baseScore: baseScore.toFixed(2),
        afterBonuses: (baseScore * bonusMultiplier).toFixed(2),
        finalScore: finalScore
      },
      formula: 'Score = ((D/S * M * timeFactor * BASE_MULTIPLIER) * (1 + C + H))'
    });

    return finalScore;
  }

  // Add new method to reset combo
  public resetCombo(playerId: string): void {
    const stats = this.playerStats.get(playerId);
    if (stats) {
      const hadCombo = stats.consecutiveHits >= 3;
      stats.consecutiveHits = 0;
      stats.multiHitCount = 0;
      this.playerStats.set(playerId, stats);

      // Only notify UI if there was an active combo
      if (hadCombo && this.world) {
        this.world.entityManager.getAllPlayerEntities()
          .filter(entity => entity.player.id === playerId)
          .forEach(entity => {
            entity.player.ui.sendData({
              type: 'resetCombo'
            });
          });
      }
    }
  }

  // Add this new method to get placement points
  public getLeaderboardPoints(playerId: string): number {
    return this.playerStats.get(playerId)?.placementPoints ?? 0;
  }
}

================
File: src/moving_blocks/block-movement.js
================
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PendulumMovement = exports.ParabolicMovement = exports.RisingMovement = exports.PopUpMovement = exports.StaticMovement = exports.SineWaveMovement = exports.DefaultBlockMovement = void 0;
var DefaultBlockMovement = /** @class */ (function () {
    function DefaultBlockMovement() {
        this.initialY = 0;
        this.heightVariation = 2; // Height variation range
        this.heightPhase = 0; // Phase for height oscillation
    }
    DefaultBlockMovement.prototype.update = function (block, deltaTimeMs) {
        // Initialize height parameters on first update if needed
        if (this.initialY === 0) {
            this.initialY = block.position.y;
            this.heightPhase = Math.random() * Math.PI * 2; // Random starting phase
            this.heightVariation = 1 + Math.random() * 2; // Random height variation between 1-3
        }
        var deltaSeconds = deltaTimeMs / 1000;
        // Calculate height oscillation
        var heightOffset = Math.sin(this.heightPhase + deltaTimeMs / 1000) * this.heightVariation;
        // Update phase
        this.heightPhase += deltaSeconds;
        // Get normalized direction and calculate movement
        var direction = block.getDirection();
        var speed = block.getMoveSpeed() * deltaSeconds;
        // Calculate new position with normalized movement
        var newPosition = {
            x: block.position.x + direction.x * speed,
            y: this.initialY + heightOffset,
            z: block.position.z + direction.z * speed,
        };
        // Check bounds and handle oscillation
        if (!block.isWithinMovementBounds(newPosition)) {
            if (block.shouldOscillate()) {
                block.reverseMovementDirection();
                // Recalculate with reversed direction
                var newDirection = block.getDirection();
                newPosition = {
                    x: block.position.x + newDirection.x * speed,
                    y: this.initialY + heightOffset,
                    z: block.position.z + newDirection.z * speed,
                };
            }
            else {
                block.resetToInitialPosition();
                this.initialY = block.position.y;
                return;
            }
        }
        block.setPosition(newPosition);
    };
    return DefaultBlockMovement;
}());
exports.DefaultBlockMovement = DefaultBlockMovement;
var SineWaveMovement = /** @class */ (function () {
    function SineWaveMovement(options) {
        if (options === void 0) { options = {}; }
        var _a, _b, _c, _d;
        this.elapsedTime = 0;
        this.initialY = 0;
        this.lastWaveOffset = 0; // Track last offset for smoother transitions
        this.amplitude = (_a = options.amplitude) !== null && _a !== void 0 ? _a : 8; // Default to wider amplitude
        this.frequency = (_b = options.frequency) !== null && _b !== void 0 ? _b : 0.2; // Default to slower frequency
        this.baseAxis = (_c = options.baseAxis) !== null && _c !== void 0 ? _c : 'z';
        this.waveAxis = (_d = options.waveAxis) !== null && _d !== void 0 ? _d : 'x';
    }
    /**
     * Optionally clamps the position to be safely within the bounds.
     * If an axis is fixed (min === max) then it returns that fixed value.
     */
    SineWaveMovement.prototype.clampPosition = function (pos, bounds) {
        var epsilon = 0.05; // Increased epsilon for smoother clamping
        return {
            x: bounds.min.x === bounds.max.x ? bounds.min.x : Math.max(bounds.min.x + epsilon, Math.min(pos.x, bounds.max.x - epsilon)),
            y: bounds.min.y === bounds.max.y ? bounds.min.y : Math.max(bounds.min.y + epsilon, Math.min(pos.y, bounds.max.y - epsilon)),
            z: bounds.min.z === bounds.max.z ? bounds.min.z : Math.max(bounds.min.z + epsilon, Math.min(pos.z, bounds.max.z - epsilon))
        };
    };
    SineWaveMovement.prototype.update = function (block, deltaTimeMs) {
        // Set initialY on first update.
        if (this.elapsedTime === 0) {
            this.initialY = block.position.y;
            this.lastWaveOffset = 0;
        }
        var deltaSeconds = deltaTimeMs / 1000;
        this.elapsedTime += deltaSeconds;
        var baseSpeed = block.getMoveSpeed() * deltaSeconds;
        var baseMovement = block.getDirection()[this.baseAxis] * baseSpeed;
        // Calculate new wave offset with smooth transition
        var targetWaveOffset = this.amplitude * Math.sin(2 * Math.PI * this.frequency * this.elapsedTime);
        // Interpolate between last and target offset for smoother movement
        var smoothingFactor = 0.1; // Lower value = smoother but slower response
        this.lastWaveOffset += (targetWaveOffset - this.lastWaveOffset) * smoothingFactor;
        var newPosition = __assign({}, block.position);
        newPosition[this.baseAxis] += baseMovement;
        // Apply wave offset on the proper axis with smoothing
        if (this.waveAxis === 'y') {
            newPosition.y = this.initialY + this.lastWaveOffset;
        }
        else {
            newPosition[this.waveAxis] = this.lastWaveOffset;
        }
        if (!block.isWithinMovementBounds(newPosition)) {
            if (block.shouldOscillate()) {
                block.reverseMovementDirection();
                // Adjust elapsed time to maintain wave pattern
                this.elapsedTime = Math.PI / (2 * Math.PI * this.frequency) - this.elapsedTime;
                // Recalculate with reversed direction
                var reversedBaseSpeed = block.getMoveSpeed() * deltaSeconds;
                var reversedBaseMovement = block.getDirection()[this.baseAxis] * reversedBaseSpeed;
                newPosition = __assign({}, block.position);
                newPosition[this.baseAxis] += reversedBaseMovement;
                if (this.waveAxis === 'y') {
                    newPosition.y = this.initialY + this.lastWaveOffset;
                }
                else {
                    newPosition[this.waveAxis] = this.lastWaveOffset;
                }
                // Ensure position is within bounds
                if (block['movementBounds']) {
                    newPosition = this.clampPosition(newPosition, block['movementBounds']);
                }
            }
            else {
                block.resetToInitialPosition();
                this.elapsedTime = 0;
                this.lastWaveOffset = 0;
                return;
            }
        }
        block.setPosition(newPosition);
    };
    return SineWaveMovement;
}());
exports.SineWaveMovement = SineWaveMovement;
var StaticMovement = /** @class */ (function () {
    function StaticMovement() {
    }
    StaticMovement.prototype.update = function (block, deltaTimeMs) {
        // Static blocks don't move, but we still need to check if they're within bounds
        if (!block.isWithinMovementBounds(block.position)) {
            block.resetToInitialPosition();
        }
    };
    return StaticMovement;
}());
exports.StaticMovement = StaticMovement;
var PopUpMovement = /** @class */ (function () {
    function PopUpMovement(options) {
        if (options === void 0) { options = {}; }
        var _a, _b, _c;
        this.elapsedTime = 0;
        this.state = 'rising';
        this.pauseDuration = 3000; // 3 seconds pause at top
        this.pauseStartTime = 0;
        this.startY = (_a = options.startY) !== null && _a !== void 0 ? _a : -20;
        this.topY = (_b = options.topY) !== null && _b !== void 0 ? _b : 8;
        this.pauseDuration = (_c = options.pauseDuration) !== null && _c !== void 0 ? _c : 3000;
    }
    Object.defineProperty(PopUpMovement.prototype, "currentState", {
        // Getters for movement state
        get: function () {
            return this.state;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PopUpMovement.prototype, "isComplete", {
        get: function () {
            return this.state === 'complete';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PopUpMovement.prototype, "isPaused", {
        get: function () {
            return this.state === 'paused';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PopUpMovement.prototype, "timeRemainingInPause", {
        get: function () {
            if (this.state !== 'paused')
                return 0;
            return Math.max(0, this.pauseDuration - (this.elapsedTime - this.pauseStartTime));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PopUpMovement.prototype, "totalElapsedTime", {
        get: function () {
            return this.elapsedTime;
        },
        enumerable: false,
        configurable: true
    });
    // Helper methods for state management
    PopUpMovement.prototype.transitionToState = function (newState) {
        this.state = newState;
        if (newState === 'paused') {
            this.pauseStartTime = this.elapsedTime;
        }
    };
    PopUpMovement.prototype.shouldTransitionFromPaused = function () {
        return this.elapsedTime - this.pauseStartTime >= this.pauseDuration;
    };
    PopUpMovement.prototype.calculateNewPosition = function (currentPosition, deltaSeconds, speed) {
        var newPosition = __assign({}, currentPosition);
        switch (this.state) {
            case 'rising':
                newPosition.y += speed * 2 * deltaSeconds;
                if (newPosition.y >= this.topY) {
                    newPosition.y = this.topY;
                    this.transitionToState('paused');
                }
                break;
            case 'falling':
                newPosition.y -= speed * 2 * deltaSeconds;
                if (newPosition.y <= this.startY) {
                    newPosition.y = this.startY;
                    this.transitionToState('complete');
                }
                break;
        }
        return newPosition;
    };
    PopUpMovement.prototype.update = function (block, deltaTimeMs) {
        this.elapsedTime += deltaTimeMs;
        var deltaSeconds = deltaTimeMs / 1000;
        var speed = block.getMoveSpeed();
        if (this.state === 'complete') {
            if (block.isSpawned) {
                block.despawn();
            }
            return;
        }
        if (this.state === 'paused' && this.shouldTransitionFromPaused()) {
            this.transitionToState('falling');
        }
        var newPosition = this.calculateNewPosition(block.position, deltaSeconds, speed);
        block.setPosition(newPosition);
    };
    return PopUpMovement;
}());
exports.PopUpMovement = PopUpMovement;
var RisingMovement = /** @class */ (function () {
    function RisingMovement(options) {
        if (options === void 0) { options = {}; }
        var _a, _b, _c, _d;
        this.elapsedTime = 0;
        this.state = 'rising';
        this.pauseDuration = 2000; // 2 seconds pause at first stop
        this.pauseStartTime = 0;
        this.startY = (_a = options.startY) !== null && _a !== void 0 ? _a : -20;
        this.firstStopY = (_b = options.firstStopY) !== null && _b !== void 0 ? _b : 8; // Same height as pop-up target
        this.finalY = (_c = options.finalY) !== null && _c !== void 0 ? _c : 30; // Much higher final position
        this.pauseDuration = (_d = options.pauseDuration) !== null && _d !== void 0 ? _d : 2000;
    }
    Object.defineProperty(RisingMovement.prototype, "currentState", {
        // Getters for movement state
        get: function () {
            return this.state;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RisingMovement.prototype, "isComplete", {
        get: function () {
            return this.state === 'complete';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RisingMovement.prototype, "isPaused", {
        get: function () {
            return this.state === 'paused';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RisingMovement.prototype, "isShooting", {
        get: function () {
            return this.state === 'shooting';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RisingMovement.prototype, "timeRemainingInPause", {
        get: function () {
            if (this.state !== 'paused')
                return 0;
            return Math.max(0, this.pauseDuration - (this.elapsedTime - this.pauseStartTime));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RisingMovement.prototype, "totalElapsedTime", {
        get: function () {
            return this.elapsedTime;
        },
        enumerable: false,
        configurable: true
    });
    // Helper methods for state management
    RisingMovement.prototype.transitionToState = function (newState) {
        this.state = newState;
        if (newState === 'paused') {
            this.pauseStartTime = this.elapsedTime;
        }
    };
    RisingMovement.prototype.shouldTransitionFromPaused = function () {
        return this.elapsedTime - this.pauseStartTime >= this.pauseDuration;
    };
    RisingMovement.prototype.calculateNewPosition = function (currentPosition, deltaSeconds, speed) {
        var newPosition = __assign({}, currentPosition);
        switch (this.state) {
            case 'rising':
                newPosition.y += speed * 2 * deltaSeconds; // Double speed for initial rise
                if (newPosition.y >= this.firstStopY) {
                    newPosition.y = this.firstStopY;
                    this.transitionToState('paused');
                }
                break;
            case 'shooting':
                newPosition.y += speed * 4 * deltaSeconds; // Quadruple speed for final ascent
                if (newPosition.y >= this.finalY) {
                    newPosition.y = this.finalY;
                    this.transitionToState('complete');
                }
                break;
        }
        return newPosition;
    };
    RisingMovement.prototype.update = function (block, deltaTimeMs) {
        this.elapsedTime += deltaTimeMs;
        var deltaSeconds = deltaTimeMs / 1000;
        var speed = block.getMoveSpeed();
        if (this.state === 'complete') {
            if (block.isSpawned) {
                block.despawn();
            }
            return;
        }
        if (this.state === 'paused' && this.shouldTransitionFromPaused()) {
            this.transitionToState('shooting');
        }
        var newPosition = this.calculateNewPosition(block.position, deltaSeconds, speed);
        block.setPosition(newPosition);
    };
    return RisingMovement;
}());
exports.RisingMovement = RisingMovement;
var ParabolicMovement = /** @class */ (function () {
    function ParabolicMovement(options) {
        if (options === void 0) { options = {}; }
        var _a, _b, _c, _d;
        this.elapsedTime = 0;
        this.startPoint = (_a = options.startPoint) !== null && _a !== void 0 ? _a : { x: 0, y: -20, z: 0 };
        this.endPoint = (_b = options.endPoint) !== null && _b !== void 0 ? _b : { x: 0, y: -20, z: 20 };
        this.maxHeight = (_c = options.maxHeight) !== null && _c !== void 0 ? _c : 15;
        this.totalDuration = (_d = options.duration) !== null && _d !== void 0 ? _d : 5000; // 5 seconds total
        // Calculate physics parameters
        this.gravity = 2 * (this.maxHeight - this.startPoint.y) / Math.pow(this.totalDuration / 4000, 2);
        this.initialVelocityY = Math.sqrt(2 * this.gravity * (this.maxHeight - this.startPoint.y));
        // Calculate horizontal speed based on total distance and time
        var horizontalDistance = Math.sqrt(Math.pow(this.endPoint.x - this.startPoint.x, 2) +
            Math.pow(this.endPoint.z - this.startPoint.z, 2));
        this.horizontalSpeed = horizontalDistance / (this.totalDuration / 1000);
    }
    ParabolicMovement.prototype.calculatePosition = function (time) {
        // Time in seconds
        var t = time / 1000;
        // Calculate progress through the motion (0 to 1)
        var progress = Math.min(t / (this.totalDuration / 1000), 1);
        // Calculate vertical position using physics equations
        var verticalTime = t;
        var y = this.startPoint.y +
            (this.initialVelocityY * verticalTime) -
            (0.5 * this.gravity * verticalTime * verticalTime);
        // Calculate horizontal position with linear interpolation
        var x = this.startPoint.x + (this.endPoint.x - this.startPoint.x) * progress;
        var z = this.startPoint.z + (this.endPoint.z - this.startPoint.z) * progress;
        return { x: x, y: y, z: z };
    };
    ParabolicMovement.prototype.update = function (block, deltaTimeMs) {
        this.elapsedTime += deltaTimeMs;
        // Check if the movement is complete
        if (this.elapsedTime >= this.totalDuration) {
            if (block.isSpawned) {
                block.despawn();
            }
            return;
        }
        var newPosition = this.calculatePosition(this.elapsedTime);
        block.setPosition(newPosition);
    };
    return ParabolicMovement;
}());
exports.ParabolicMovement = ParabolicMovement;
var PendulumMovement = /** @class */ (function () {
    function PendulumMovement(options) {
        if (options === void 0) { options = {}; }
        var _a, _b, _c, _d;
        this.elapsedTime = 0;
        this.pivotPoint = (_a = options.pivotPoint) !== null && _a !== void 0 ? _a : { x: 0, y: 15, z: 0 }; // Higher default pivot point
        this.length = (_b = options.length) !== null && _b !== void 0 ? _b : 10; // Longer default length
        this.amplitude = (_c = options.amplitude) !== null && _c !== void 0 ? _c : Math.PI / 3; // 60 degrees in radians
        this.frequency = (_d = options.frequency) !== null && _d !== void 0 ? _d : 0.4; // Slightly slower frequency
    }
    PendulumMovement.prototype.update = function (block, deltaTimeMs) {
        this.elapsedTime += deltaTimeMs / 1000;
        // Calculate the current angle using a sine wave
        var angle = this.amplitude * Math.sin(2 * Math.PI * this.frequency * this.elapsedTime);
        // Calculate new position - only rotating around Z axis
        var newPosition = {
            x: this.pivotPoint.x, // Keep X position fixed at pivot point
            y: this.pivotPoint.y - this.length * Math.cos(angle), // Y position changes with swing
            z: this.pivotPoint.z + this.length * Math.sin(angle) // Z position changes with swing
        };
        block.setPosition(newPosition);
    };
    return PendulumMovement;
}());
exports.PendulumMovement = PendulumMovement;

================
File: src/moving_blocks/block-movement.ts
================
import { Vector3Like } from 'hytopia';
import { MovingBlockEntity } from './moving-block-entity';

export interface BlockMovementBehavior {
  update(block: MovingBlockEntity, deltaTimeMs: number): void;
}

export class DefaultBlockMovement implements BlockMovementBehavior {
  private initialY: number = 0;
  private heightVariation: number = 2;  // Height variation range
  private heightPhase: number = 0;      // Phase for height oscillation

  update(block: MovingBlockEntity, deltaTimeMs: number): void {
    // Initialize height parameters on first update if needed
    if (this.initialY === 0) {
      this.initialY = block.position.y;
      this.heightPhase = Math.random() * Math.PI * 2; // Random starting phase
      this.heightVariation = 1 + Math.random() * 2;   // Random height variation between 1-3
    }

    const deltaSeconds = deltaTimeMs / 1000;
    
    // Calculate height oscillation
    const heightOffset = Math.sin(this.heightPhase + deltaTimeMs / 1000) * this.heightVariation;
    
    // Update phase
    this.heightPhase += deltaSeconds;

    // Get normalized direction and calculate movement
    const direction = block.getDirection();
    const speed = block.getMoveSpeed() * deltaSeconds;
    
    // Calculate new position with normalized movement
    let newPosition = {
      x: block.position.x + direction.x * speed,
      y: this.initialY + heightOffset,
      z: block.position.z + direction.z * speed,
    };

    // Check bounds and handle oscillation
    if (!block.isWithinMovementBounds(newPosition)) {
      if (block.shouldOscillate()) {
        block.reverseMovementDirection();
        // Recalculate with reversed direction
        const newDirection = block.getDirection();
        newPosition = {
          x: block.position.x + newDirection.x * speed,
          y: this.initialY + heightOffset,
          z: block.position.z + newDirection.z * speed,
        };
      } else {
        block.resetToInitialPosition();
        this.initialY = block.position.y;
        return;
      }
    }
    
    block.setPosition(newPosition);
  }
}

export class SineWaveMovement implements BlockMovementBehavior {
  private elapsedTime: number = 0;
  private readonly amplitude: number;
  private readonly frequency: number;
  private readonly baseAxis: 'x' | 'y' | 'z';
  private readonly waveAxis: 'x' | 'y' | 'z';
  private initialY: number = 0;
  private lastWaveOffset: number = 0; // Track last offset for smoother transitions

  constructor(options: {
    amplitude?: number;
    frequency?: number;
    baseAxis?: 'x' | 'y' | 'z';
    waveAxis?: 'x' | 'y' | 'z';
  } = {}) {
    this.amplitude = options.amplitude ?? 8;  // Default to wider amplitude
    this.frequency = options.frequency ?? 0.2; // Default to slower frequency
    this.baseAxis = options.baseAxis ?? 'z';
    this.waveAxis = options.waveAxis ?? 'x';
  }

  /**
   * Optionally clamps the position to be safely within the bounds.
   * If an axis is fixed (min === max) then it returns that fixed value.
   */
  private clampPosition(pos: Vector3Like, bounds: { min: Vector3Like; max: Vector3Like }): Vector3Like {
    const epsilon = 0.05; // Increased epsilon for smoother clamping
    return {
      x: bounds.min.x === bounds.max.x ? bounds.min.x : Math.max(bounds.min.x + epsilon, Math.min(pos.x, bounds.max.x - epsilon)),
      y: bounds.min.y === bounds.max.y ? bounds.min.y : Math.max(bounds.min.y + epsilon, Math.min(pos.y, bounds.max.y - epsilon)),
      z: bounds.min.z === bounds.max.z ? bounds.min.z : Math.max(bounds.min.z + epsilon, Math.min(pos.z, bounds.max.z - epsilon))
    };
  }

  update(block: MovingBlockEntity, deltaTimeMs: number): void {
    // Set initialY on first update.
    if (this.elapsedTime === 0) {
      this.initialY = block.position.y;
      this.lastWaveOffset = 0;
    }
    
    const deltaSeconds = deltaTimeMs / 1000;
    this.elapsedTime += deltaSeconds;

    const baseSpeed = block.getMoveSpeed() * deltaSeconds;
    const baseMovement = block.getDirection()[this.baseAxis] * baseSpeed;
    
    // Calculate new wave offset with smooth transition
    const targetWaveOffset = this.amplitude * Math.sin(2 * Math.PI * this.frequency * this.elapsedTime);
    // Interpolate between last and target offset for smoother movement
    const smoothingFactor = 0.1; // Lower value = smoother but slower response
    this.lastWaveOffset += (targetWaveOffset - this.lastWaveOffset) * smoothingFactor;
    
    let newPosition = { ...block.position };
    newPosition[this.baseAxis] += baseMovement;

    // Apply wave offset on the proper axis with smoothing
    if (this.waveAxis === 'y') {
      newPosition.y = this.initialY + this.lastWaveOffset;
    } else {
      newPosition[this.waveAxis] = this.lastWaveOffset;
    }

    if (!block.isWithinMovementBounds(newPosition)) {
      if (block.shouldOscillate()) {
        block.reverseMovementDirection();
        
        // Adjust elapsed time to maintain wave pattern
        this.elapsedTime = Math.PI / (2 * Math.PI * this.frequency) - this.elapsedTime;
        
        // Recalculate with reversed direction
        const reversedBaseSpeed = block.getMoveSpeed() * deltaSeconds;
        const reversedBaseMovement = block.getDirection()[this.baseAxis] * reversedBaseSpeed;
        newPosition = { ...block.position };
        newPosition[this.baseAxis] += reversedBaseMovement;
        
        if (this.waveAxis === 'y') {
          newPosition.y = this.initialY + this.lastWaveOffset;
        } else {
          newPosition[this.waveAxis] = this.lastWaveOffset;
        }
        
        // Ensure position is within bounds
        if (block['movementBounds']) {
          newPosition = this.clampPosition(newPosition, (block as any)['movementBounds']);
        }
      } else {
        block.resetToInitialPosition();
        this.elapsedTime = 0;
        this.lastWaveOffset = 0;
        return;
      }
    }

    block.setPosition(newPosition);
  }
}

export class StaticMovement implements BlockMovementBehavior {
  update(block: MovingBlockEntity, deltaTimeMs: number): void {
    // Static blocks don't move, but we still need to check if they're within bounds
    if (!block.isWithinMovementBounds(block.position)) {
      block.resetToInitialPosition();
    }
  }
}

export class PopUpMovement implements BlockMovementBehavior {
  private elapsedTime: number = 0;
  private state: 'rising' | 'paused' | 'falling' | 'complete' = 'rising';
  private readonly pauseDuration: number = 3000; // 3 seconds pause at top
  private readonly startY: number;
  private readonly topY: number;
  private pauseStartTime: number = 0;

  constructor(options: {
    startY?: number;
    topY?: number;
    pauseDuration?: number;
  } = {}) {
    this.startY = options.startY ?? -20;
    this.topY = options.topY ?? 8;
    this.pauseDuration = options.pauseDuration ?? 3000;
  }

  // Getters for movement state
  public get currentState(): 'rising' | 'paused' | 'falling' | 'complete' {
    return this.state;
  }

  public get isComplete(): boolean {
    return this.state === 'complete';
  }

  public get isPaused(): boolean {
    return this.state === 'paused';
  }

  public get timeRemainingInPause(): number {
    if (this.state !== 'paused') return 0;
    return Math.max(0, this.pauseDuration - (this.elapsedTime - this.pauseStartTime));
  }

  public get totalElapsedTime(): number {
    return this.elapsedTime;
  }

  // Helper methods for state management
  private transitionToState(newState: 'rising' | 'paused' | 'falling' | 'complete'): void {
    this.state = newState;
    if (newState === 'paused') {
      this.pauseStartTime = this.elapsedTime;
    }
  }

  private shouldTransitionFromPaused(): boolean {
    return this.elapsedTime - this.pauseStartTime >= this.pauseDuration;
  }

  private calculateNewPosition(currentPosition: Vector3Like, deltaSeconds: number, speed: number): Vector3Like {
    const newPosition = { ...currentPosition };
    
    switch (this.state) {
      case 'rising':
        newPosition.y += speed * 2 * deltaSeconds;
        if (newPosition.y >= this.topY) {
          newPosition.y = this.topY;
          this.transitionToState('paused');
        }
        break;
        
      case 'falling':
        newPosition.y -= speed * 2 * deltaSeconds;
        if (newPosition.y <= this.startY) {
          newPosition.y = this.startY;
          this.transitionToState('complete');
        }
        break;
    }
    
    return newPosition;
  }

  update(block: MovingBlockEntity, deltaTimeMs: number): void {
    this.elapsedTime += deltaTimeMs;
    const deltaSeconds = deltaTimeMs / 1000;
    const speed = block.getMoveSpeed();
    
    if (this.state === 'complete') {
      if (block.isSpawned) {
        block.despawn();
      }
      return;
    }

    if (this.state === 'paused' && this.shouldTransitionFromPaused()) {
      this.transitionToState('falling');
    }

    const newPosition = this.calculateNewPosition(block.position, deltaSeconds, speed);
    block.setPosition(newPosition);
  }
}

export class RisingMovement implements BlockMovementBehavior {
  private elapsedTime: number = 0;
  private state: 'rising' | 'paused' | 'shooting' | 'complete' = 'rising';
  private readonly pauseDuration: number = 2000; // 2 seconds pause at first stop
  private readonly startY: number;
  private readonly firstStopY: number;
  private readonly finalY: number;
  private pauseStartTime: number = 0;

  constructor(options: {
    startY?: number;
    firstStopY?: number;
    finalY?: number;
    pauseDuration?: number;
  } = {}) {
    this.startY = options.startY ?? -20;
    this.firstStopY = options.firstStopY ?? 8; // Same height as pop-up target
    this.finalY = options.finalY ?? 30; // Much higher final position
    this.pauseDuration = options.pauseDuration ?? 2000;
  }

  // Getters for movement state
  public get currentState(): 'rising' | 'paused' | 'shooting' | 'complete' {
    return this.state;
  }

  public get isComplete(): boolean {
    return this.state === 'complete';
  }

  public get isPaused(): boolean {
    return this.state === 'paused';
  }

  public get isShooting(): boolean {
    return this.state === 'shooting';
  }

  public get timeRemainingInPause(): number {
    if (this.state !== 'paused') return 0;
    return Math.max(0, this.pauseDuration - (this.elapsedTime - this.pauseStartTime));
  }

  public get totalElapsedTime(): number {
    return this.elapsedTime;
  }

  // Helper methods for state management
  private transitionToState(newState: 'rising' | 'paused' | 'shooting' | 'complete'): void {
    this.state = newState;
    if (newState === 'paused') {
      this.pauseStartTime = this.elapsedTime;
    }
  }

  private shouldTransitionFromPaused(): boolean {
    return this.elapsedTime - this.pauseStartTime >= this.pauseDuration;
  }

  private calculateNewPosition(currentPosition: Vector3Like, deltaSeconds: number, speed: number): Vector3Like {
    const newPosition = { ...currentPosition };
    
    switch (this.state) {
      case 'rising':
        newPosition.y += speed * 2 * deltaSeconds; // Double speed for initial rise
        if (newPosition.y >= this.firstStopY) {
          newPosition.y = this.firstStopY;
          this.transitionToState('paused');
        }
        break;

      case 'shooting':
        newPosition.y += speed * 4 * deltaSeconds; // Quadruple speed for final ascent
        if (newPosition.y >= this.finalY) {
          newPosition.y = this.finalY;
          this.transitionToState('complete');
        }
        break;
    }
    
    return newPosition;
  }

  update(block: MovingBlockEntity, deltaTimeMs: number): void {
    this.elapsedTime += deltaTimeMs;
    const deltaSeconds = deltaTimeMs / 1000;
    const speed = block.getMoveSpeed();
    
    if (this.state === 'complete') {
      if (block.isSpawned) {
        block.despawn();
      }
      return;
    }

    if (this.state === 'paused' && this.shouldTransitionFromPaused()) {
      this.transitionToState('shooting');
    }

    const newPosition = this.calculateNewPosition(block.position, deltaSeconds, speed);
    block.setPosition(newPosition);
  }
}

export class ParabolicMovement implements BlockMovementBehavior {
  private elapsedTime: number = 0;
  private readonly startPoint: Vector3Like;
  private readonly endPoint: Vector3Like;
  private readonly totalDuration: number;
  private readonly maxHeight: number;
  private readonly gravity: number;
  private readonly initialVelocityY: number;
  private readonly horizontalSpeed: number;

  constructor(options: {
    startPoint?: Vector3Like;
    endPoint?: Vector3Like;
    maxHeight?: number;
    duration?: number;
  } = {}) {
    this.startPoint = options.startPoint ?? { x: 0, y: -20, z: 0 };
    this.endPoint = options.endPoint ?? { x: 0, y: -20, z: 20 };
    this.maxHeight = options.maxHeight ?? 15;
    this.totalDuration = options.duration ?? 5000; // 5 seconds total

    // Calculate physics parameters
    this.gravity = 2 * (this.maxHeight - this.startPoint.y) / Math.pow(this.totalDuration / 4000, 2);
    this.initialVelocityY = Math.sqrt(2 * this.gravity * (this.maxHeight - this.startPoint.y));
    
    // Calculate horizontal speed based on total distance and time
    const horizontalDistance = Math.sqrt(
      Math.pow(this.endPoint.x - this.startPoint.x, 2) +
      Math.pow(this.endPoint.z - this.startPoint.z, 2)
    );
    this.horizontalSpeed = horizontalDistance / (this.totalDuration / 1000);
  }

  private calculatePosition(time: number): Vector3Like {
    // Time in seconds
    const t = time / 1000;
    
    // Calculate progress through the motion (0 to 1)
    const progress = Math.min(t / (this.totalDuration / 1000), 1);
    
    // Calculate vertical position using physics equations
    const verticalTime = t;
    const y = this.startPoint.y + 
              (this.initialVelocityY * verticalTime) - 
              (0.5 * this.gravity * verticalTime * verticalTime);
    
    // Calculate horizontal position with linear interpolation
    const x = this.startPoint.x + (this.endPoint.x - this.startPoint.x) * progress;
    const z = this.startPoint.z + (this.endPoint.z - this.startPoint.z) * progress;

    return { x, y, z };
  }

  update(block: MovingBlockEntity, deltaTimeMs: number): void {
    this.elapsedTime += deltaTimeMs;
    
    // Check if the movement is complete
    if (this.elapsedTime >= this.totalDuration) {
      if (block.isSpawned) {
        block.despawn();
      }
      return;
    }

    const newPosition = this.calculatePosition(this.elapsedTime);
    block.setPosition(newPosition);
  }
}

export class PendulumMovement implements BlockMovementBehavior {
  private elapsedTime: number = 0;
  private readonly pivotPoint: Vector3Like;
  private readonly length: number;
  private readonly amplitude: number;
  private readonly frequency: number;

  constructor(options: {
    pivotPoint?: Vector3Like;
    length?: number;
    amplitude?: number;
    frequency?: number;
  } = {}) {
    this.pivotPoint = options.pivotPoint ?? { x: 0, y: 15, z: 0 }; // Higher default pivot point
    this.length = options.length ?? 10; // Longer default length
    this.amplitude = options.amplitude ?? Math.PI / 3; // 60 degrees in radians
    this.frequency = options.frequency ?? 0.4; // Slightly slower frequency
  }

  update(block: MovingBlockEntity, deltaTimeMs: number): void {
    this.elapsedTime += deltaTimeMs / 1000;
    
    // Calculate the current angle using a sine wave
    const angle = this.amplitude * Math.sin(2 * Math.PI * this.frequency * this.elapsedTime);
    
    // Calculate new position - only rotating around Z axis
    const newPosition = {
      x: this.pivotPoint.x, // Keep X position fixed at pivot point
      y: this.pivotPoint.y - this.length * Math.cos(angle), // Y position changes with swing
      z: this.pivotPoint.z + this.length * Math.sin(angle)  // Z position changes with swing
    };
    
    block.setPosition(newPosition);
  }
}

================
File: src/moving_blocks/moving-block-entity.js
================
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MovingBlockManager = exports.MovingBlockEntity = exports.MOVING_BLOCK_CONFIG = void 0;
var hytopia_1 = require("hytopia");
var score_manager_1 = require("../managers/score-manager");
var block_movement_1 = require("./block-movement");
var block_particle_effects_1 = require("../effects/block-particle-effects");
var scene_ui_manager_1 = require("../scene-ui/scene-ui-manager");
var projectile_entity_1 = require("../entities/projectile-entity");
// Configuration for our Z-axis moving block
exports.MOVING_BLOCK_CONFIG = {
    DEFAULT_SPEED: 6,
    DEFAULT_HEALTH: 5,
    DEFAULT_TEXTURE: 'blocks/creep.png',
    DEFAULT_HALF_EXTENTS: { x: 0.5, y: 2, z: 2 },
    MOVEMENT_BOUNDS: {
        min: { x: -15, y: 2, z: -15 }, // Wider X range, higher minimum Y
        max: { x: 15, y: 12, z: 16 } // Wider X range, higher maximum Y
    },
    SPAWN_POSITION: { x: 0, y: 4, z: 0 }, // Higher default spawn
    BREAK_SCORE: 5, // Points awarded for breaking a block
    STATIC_TARGET: {
        TEXTURE: 'blocks/gold-ore.png',
        HALF_EXTENTS: { x: 0.8, y: 0.8, z: 0.8 }, // Balanced size for visibility and challenge
        HEIGHT_RANGE: { min: 3, max: 8 }, // Higher range for better visibility
        SCORE: 10, // More points for hitting target
        HEALTH: 1 // One-shot kill
    },
    PLATFORM_SAFETY: {
        RIGHT_PLATFORM_EDGE: {
            X: 19,
            Z_MIN: -9,
            Z_MAX: 9
        },
        LEFT_PLATFORM_EDGE: {
            X: -18,
            Z_MIN: -9,
            Z_MAX: -8
        },
        PLATFORM_SAFETY_MARGIN: 8, // Increased margin for better spacing
        MIN_DISTANCE_BETWEEN_TARGETS: 7 // Increased minimum distance between targets
    },
    PENDULUM_TARGET: {
        TEXTURE: 'blocks/nuit-leaves.png',
        HALF_EXTENTS: { x: 0.8, y: 0.8, z: 0.8 },
        PIVOT_HEIGHT: 15,
        LENGTH: 10,
        AMPLITUDE: Math.PI / 3,
        FREQUENCY: 0.4,
        SCORE_MULTIPLIER: 3,
        HEALTH: 1,
        SPAWN_BOUNDS: {
            LATERAL: {
                MIN: -12, // Reduced to keep further from left platform
                MAX: 13 // Reduced to keep further from right platform
            },
            FORWARD: {
                MIN: -5, // Reduced to keep further from platform depths
                MAX: 5 // Reduced to keep further from platform depths
            }
        },
        MIN_DISTANCE_FROM_PLATFORMS: 8, // Increased minimum distance from platforms
        SPAWN_SPACING: {
            MIN_X_DISTANCE: 2, // Increased minimum X distance between pendulums
            MIN_Z_DISTANCE: 8 // Increased minimum Z distance between pendulums
        }
    },
    VERTICAL_WAVE: {
        TEXTURE: 'blocks/infected-shadowrock.png',
        HALF_EXTENTS: { x: 1, y: 1, z: 1 },
        DEFAULT_AMPLITUDE: 4, // Reduced amplitude to prevent floor collision
        DEFAULT_FREQUENCY: 0.5, // Slightly faster than horizontal sine wave
        HEIGHT_OFFSET: 10, // Significantly increased base height
        SAFETY_MARGIN: 2, // Extra space to prevent any collision
        SCORE_MULTIPLIER: 2, // Double points for hitting this challenging target
        SPEED_MULTIPLIER: 0.7, // Slightly slower forward movement for better visibility
        HEALTH: 1 // One-shot kill, like static targets
    },
    POPUP_TARGET: {
        TEXTURE: 'blocks/diamond-ore.png',
        HALF_EXTENTS: { x: 0.8, y: 0.8, z: 0.8 },
        START_Y: -20,
        TOP_Y: 8,
        SPEED_MULTIPLIER: 1.5, // Faster than normal blocks
        SCORE_MULTIPLIER: 2, // Double points for hitting this challenging target
        HEALTH: 1 // One-shot kill
    },
    RISING_TARGET: {
        TEXTURE: 'blocks/emerald-ore.png',
        HALF_EXTENTS: { x: 0.8, y: 0.8, z: 0.8 },
        START_Y: -20,
        FIRST_STOP_Y: 8, // Same height as pop-up target
        FINAL_Y: 30, // Much higher final position
        SPEED_MULTIPLIER: 2.0, // Faster than pop-up target
        SCORE_MULTIPLIER: 3, // Triple points for hitting this challenging target
        HEALTH: 1, // One-shot kill
        PAUSE_DURATION: 2000 // 2 seconds at first stop
    },
    PARABOLIC_TARGET: {
        TEXTURE: 'blocks/swirl-rune.png',
        HALF_EXTENTS: { x: 0.8, y: 0.8, z: 0.8 },
        START_Y: -20,
        MAX_HEIGHT: 20, // Increased height for more dramatic arc
        END_Y: -20,
        SPEED_MULTIPLIER: 1.0, // Not used in new physics-based system
        SCORE_MULTIPLIER: 4, // Highest points due to difficulty
        HEALTH: 1, // One-shot kill
        DURATION: 5000, // 5 seconds total
        SPAWN_BOUNDS: {
            FORWARD: {
                MIN: -25, // How far back it can start
                MAX: 25 // How far forward it can go
            },
            LATERAL: {
                MIN: -15, // How far left it can go
                MAX: 15 // How far right it can go
            }
        },
        MIN_TRAVEL_DISTANCE: 30, // Minimum distance the block must travel
        MAX_TRAVEL_DISTANCE: 50 // Maximum distance the block can travel
    },
    PARTICLE_CONFIG: {
        COUNT: 50,
        SCALE: 0.15,
        LIFETIME: 800,
        SPREAD_RADIUS: 0.3,
        SPEED: 0.15
    }
};
var MovingBlockEntity = /** @class */ (function (_super) {
    __extends(MovingBlockEntity, _super);
    function MovingBlockEntity(options) {
        var _a, _b, _c, _d;
        var _this = _super.call(this, __assign(__assign({}, options), { name: options.name || 'MovingBlock', blockTextureUri: options.blockTextureUri || exports.MOVING_BLOCK_CONFIG.DEFAULT_TEXTURE, blockHalfExtents: options.blockHalfExtents || exports.MOVING_BLOCK_CONFIG.DEFAULT_HALF_EXTENTS, rigidBodyOptions: {
                type: hytopia_1.RigidBodyType.KINEMATIC_POSITION,
                colliders: [{
                        shape: hytopia_1.ColliderShape.BLOCK,
                        halfExtents: options.blockHalfExtents || exports.MOVING_BLOCK_CONFIG.DEFAULT_HALF_EXTENTS,
                        collisionGroups: {
                            belongsTo: [hytopia_1.CollisionGroup.BLOCK],
                            collidesWith: [hytopia_1.CollisionGroup.PLAYER, hytopia_1.CollisionGroup.BLOCK, hytopia_1.CollisionGroup.ENTITY]
                        },
                        onCollision: function (other, started) {
                            if (started && _this.isBreakable && other instanceof hytopia_1.Entity) {
                                _this.handleCollision(other);
                            }
                        }
                    }]
            } })) || this;
        _this.isReversed = false;
        _this.particles = [];
        _this.despawnTimer = null; // Add despawn timer
        _this.onTick = function (entity, deltaTimeMs) {
            // Delegate movement update to injected behavior
            _this.movementBehavior.update(_this, deltaTimeMs);
        };
        // Initialize other properties
        _this.moveSpeed = (_a = options.moveSpeed) !== null && _a !== void 0 ? _a : exports.MOVING_BLOCK_CONFIG.DEFAULT_SPEED;
        _this.direction = _this.normalizeDirection(options.direction || { x: 0, y: 0, z: 1 });
        _this.movementBounds = options.movementBounds || exports.MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS;
        _this.oscillate = (_b = options.oscillate) !== null && _b !== void 0 ? _b : true;
        _this.initialPosition = { x: 0, y: 0, z: 0 };
        _this.health = (_c = options.health) !== null && _c !== void 0 ? _c : exports.MOVING_BLOCK_CONFIG.DEFAULT_HEALTH;
        _this.isBreakable = (_d = options.isBreakable) !== null && _d !== void 0 ? _d : true;
        _this.onBlockBroken = options.onBlockBroken;
        _this.movementBehavior = options.movementBehavior || new block_movement_1.DefaultBlockMovement();
        _this.particleEffects = null;
        _this.spawnTime = Date.now();
        // Set up despawn timer if specified
        if (options.despawnTime) {
            _this.despawnTimer = setTimeout(function () {
                if (_this.isSpawned) {
                    _this.despawn();
                }
            }, options.despawnTime);
        }
        return _this;
    }
    MovingBlockEntity.prototype.normalizeDirection = function (dir) {
        var magnitude = Math.sqrt(dir.x * dir.x + dir.y * dir.y + dir.z * dir.z);
        if (magnitude === 0)
            return { x: 0, y: 0, z: 1 }; // Default to moving along Z-axis
        return {
            x: dir.x / magnitude,
            y: dir.y / magnitude,
            z: dir.z / magnitude
        };
    };
    MovingBlockEntity.prototype.spawn = function (world, position) {
        _super.prototype.spawn.call(this, world, position);
        this.initialPosition = __assign({}, position);
        this.particleEffects = block_particle_effects_1.BlockParticleEffects.getInstance(world);
    };
    MovingBlockEntity.prototype.isWithinBounds = function (position) {
        if (!this.movementBounds)
            return true;
        // Use a larger epsilon for boundary checks to prevent jittering
        var epsilon = 0.05;
        // Check each axis independently and apply epsilon consistently
        var withinX = position.x >= (this.movementBounds.min.x + epsilon) &&
            position.x <= (this.movementBounds.max.x - epsilon);
        var withinY = position.y >= (this.movementBounds.min.y + epsilon) &&
            position.y <= (this.movementBounds.max.y - epsilon);
        var withinZ = position.z >= (this.movementBounds.min.z + epsilon) &&
            position.z <= (this.movementBounds.max.z - epsilon);
        // Only enforce bounds on axes that have different min/max values
        var needsXCheck = Math.abs(this.movementBounds.max.x - this.movementBounds.min.x) > epsilon;
        var needsYCheck = Math.abs(this.movementBounds.max.y - this.movementBounds.min.y) > epsilon;
        var needsZCheck = Math.abs(this.movementBounds.max.z - this.movementBounds.min.z) > epsilon;
        return (!needsXCheck || withinX) &&
            (!needsYCheck || withinY) &&
            (!needsZCheck || withinZ);
    };
    MovingBlockEntity.prototype.reverseDirection = function () {
        this.direction.x *= -1;
        this.direction.y *= -1;
        this.direction.z *= -1;
        this.isReversed = !this.isReversed;
    };
    MovingBlockEntity.prototype.handleCollision = function (other) {
        var _this = this;
        var _a;
        // Check if the colliding entity is a projectile
        if (other.name.toLowerCase().includes('projectile') && other instanceof projectile_entity_1.ProjectileEntity) {
            // Store the player ID from the projectile if available
            this.playerId = other.playerId;
            // Calculate score using the new dynamic scoring system
            if (this.world && this.playerId) {
                var scoreManager = this.world.entityManager.getAllEntities()
                    .find(function (entity) { return entity instanceof score_manager_1.ScoreManager; });
                if (scoreManager) {
                    var score = scoreManager.calculateGrenadeTargetScore(other, this, this.position, this.playerId);
                    scoreManager.addScore(this.playerId, score);
                    // Get the player who hit the block
                    var player = (_a = this.world.entityManager.getAllPlayerEntities()
                        .find(function (p) { return p.player.id === _this.playerId; })) === null || _a === void 0 ? void 0 : _a.player;
                    if (player) {
                        // Show block destroyed notification with the score
                        var sceneUIManager = scene_ui_manager_1.SceneUIManager.getInstance(this.world);
                        sceneUIManager.showBlockDestroyedNotification(this.position, score, player);
                    }
                    // Create destruction effect before despawning
                    if (this.blockTextureUri) {
                        var particleEffects = block_particle_effects_1.BlockParticleEffects.getInstance(this.world);
                        particleEffects.createDestructionEffect(this.world, this.position, this.blockTextureUri);
                    }
                    // Broadcast updated scores
                    scoreManager.broadcastScores(this.world);
                    // Destroy the block after scoring
                    if (this.isSpawned) {
                        this.despawn();
                    }
                }
                else {
                    this.takeDamage(1); // Fallback to simple damage
                }
            }
            else {
                this.takeDamage(1); // Fallback to simple damage
            }
            // Despawn the projectile that hit us
            if (other.isSpawned) {
                other.despawn();
            }
        }
    };
    MovingBlockEntity.prototype.takeDamage = function (amount) {
        var _this = this;
        var _a, _b;
        if (!this.isBreakable)
            return;
        this.health -= amount;
        // Get the player who hit the block
        var player = (_b = (_a = this.world) === null || _a === void 0 ? void 0 : _a.entityManager.getAllPlayerEntities().find(function (p) { return p.player.id === _this.playerId; })) === null || _b === void 0 ? void 0 : _b.player;
        if (!player || !this.world)
            return;
        // Get the SceneUIManager instance
        var sceneUIManager = scene_ui_manager_1.SceneUIManager.getInstance(this.world);
        if (this.health <= 0) {
            // Calculate score before showing notification
            var score = this.calculateScore();
            // Show block destroyed notification with appropriate score
            sceneUIManager.showBlockDestroyedNotification(this.position, score, player);
            // Create destruction effect before despawning
            this.createDestructionEffect();
            if (this.onBlockBroken) {
                this.onBlockBroken();
            }
            this.despawn();
            return;
        }
        else {
            // Show hit notification for non-destroying hits
            sceneUIManager.showHitNotification(this.position, 1, player); // Show +1 for each hit
        }
        // Instead of changing opacity, change the block type based on health
        var blockTypes = [
            'blocks/void-sand.png',
            'blocks/infected-shadowrock.png',
            'blocks/dragons-stone.png',
            'blocks/diamond-ore.png',
            'blocks/clay.png'
        ];
        // Calculate which block type to use based on health
        var blockIndex = Math.floor((this.health / exports.MOVING_BLOCK_CONFIG.DEFAULT_HEALTH) * (blockTypes.length - 1));
        var newBlockType = blockTypes[Math.max(0, Math.min(blockIndex, blockTypes.length - 1))];
        // Create a new block with the same properties but different texture
        var newBlock = new MovingBlockEntity({
            blockTextureUri: newBlockType,
            moveSpeed: this.moveSpeed,
            direction: this.direction,
            movementBounds: this.movementBounds,
            oscillate: this.oscillate,
            health: this.health,
            isBreakable: this.isBreakable,
            onBlockBroken: this.onBlockBroken, // Transfer the callback
            movementBehavior: this.movementBehavior // Transfer the movement behavior
        });
        // Transfer the player ID to the new block
        newBlock.playerId = this.playerId;
        // Spawn the new block at the current position
        if (this.world) {
            newBlock.spawn(this.world, this.position);
        }
        // Despawn the old block
        this.despawn();
    };
    MovingBlockEntity.prototype.calculateScore = function () {
        // Base score calculation based on block type and difficulty
        var score = exports.MOVING_BLOCK_CONFIG.BREAK_SCORE;
        // Multiply score based on movement behavior
        if (this.movementBehavior instanceof block_movement_1.SineWaveMovement) {
            score *= 1.5; // Sine wave blocks are harder to hit
        }
        else if (this.movementBehavior instanceof block_movement_1.PopUpMovement) {
            score *= exports.MOVING_BLOCK_CONFIG.POPUP_TARGET.SCORE_MULTIPLIER;
        }
        else if (this.movementBehavior instanceof block_movement_1.RisingMovement) {
            score *= exports.MOVING_BLOCK_CONFIG.RISING_TARGET.SCORE_MULTIPLIER;
        }
        else if (this.movementBehavior instanceof block_movement_1.ParabolicMovement) {
            score *= exports.MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SCORE_MULTIPLIER;
        }
        else if (this.movementBehavior instanceof block_movement_1.StaticMovement) {
            score = exports.MOVING_BLOCK_CONFIG.STATIC_TARGET.SCORE; // Static targets have their own base score
        }
        return Math.round(score);
    };
    // --- Added getter and helper methods for movement behavior use ---
    MovingBlockEntity.prototype.getDirection = function () {
        return __assign({}, this.direction); // Return a copy to prevent direct modification
    };
    MovingBlockEntity.prototype.getMoveSpeed = function () {
        return this.moveSpeed;
    };
    MovingBlockEntity.prototype.isWithinMovementBounds = function (position) {
        return this.isWithinBounds(position);
    };
    MovingBlockEntity.prototype.shouldOscillate = function () {
        return this.oscillate;
    };
    MovingBlockEntity.prototype.reverseMovementDirection = function () {
        this.reverseDirection();
    };
    MovingBlockEntity.prototype.resetToInitialPosition = function () {
        this.setPosition(this.initialPosition);
    };
    MovingBlockEntity.prototype.getDebugInfo = function () {
        var halfExtents = this.blockHalfExtents || { x: 0, y: 0, z: 0 };
        return "MovingBlock Debug Info:\n      ID: ".concat(this.id, "\n      Position: x=").concat(this.position.x.toFixed(2), ", y=").concat(this.position.y.toFixed(2), ", z=").concat(this.position.z.toFixed(2), "\n      Direction: x=").concat(this.direction.x.toFixed(2), ", y=").concat(this.direction.y.toFixed(2), ", z=").concat(this.direction.z.toFixed(2), "\n      Speed: ").concat(this.moveSpeed, "\n      Health: ").concat(this.health, "\n      Is Breakable: ").concat(this.isBreakable, "\n      Oscillating: ").concat(this.oscillate, "\n      Is Reversed: ").concat(this.isReversed, "\n      Movement Bounds: ").concat(this.movementBounds ?
            "\n        Min: x=".concat(this.movementBounds.min.x, ", y=").concat(this.movementBounds.min.y, ", z=").concat(this.movementBounds.min.z, "\n        Max: x=").concat(this.movementBounds.max.x, ", y=").concat(this.movementBounds.max.y, ", z=").concat(this.movementBounds.max.z)
            : 'None', "\n      Last Hit By Player: ").concat(this.playerId || 'None', "\n      Texture: ").concat(this.blockTextureUri || 'None', "\n      Half Extents: x=").concat(halfExtents.x, ", y=").concat(halfExtents.y, ", z=").concat(halfExtents.z, "\n      Is Spawned: ").concat(this.isSpawned);
    };
    MovingBlockEntity.prototype.createDestructionEffect = function () {
        var _a;
        if (!this.world || !this.blockTextureUri)
            return;
        (_a = this.particleEffects) === null || _a === void 0 ? void 0 : _a.createDestructionEffect(this.world, this.position, this.blockTextureUri);
    };
    Object.defineProperty(MovingBlockEntity, "DefaultTargetTexture", {
        // Static getters for default target configuration
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.STATIC_TARGET.TEXTURE;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultTargetHalfExtents", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.STATIC_TARGET.HALF_EXTENTS;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultTargetHeightRange", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.STATIC_TARGET.HEIGHT_RANGE;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultTargetScore", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.STATIC_TARGET.SCORE;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultTargetHealth", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.STATIC_TARGET.HEALTH;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultBlockSpeed", {
        // Z-Axis Moving Block (Default Block) Getters
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.DEFAULT_SPEED;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultBlockHealth", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.DEFAULT_HEALTH;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultBlockTexture", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.DEFAULT_TEXTURE;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultBlockHalfExtents", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.DEFAULT_HALF_EXTENTS;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultBlockScore", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.BREAK_SCORE;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultMovementBounds", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultSpawnPosition", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.SPAWN_POSITION;
        },
        enumerable: false,
        configurable: true
    });
    // Helper methods for Z-Axis Moving Block
    MovingBlockEntity.createDefaultBlockConfiguration = function (customConfig) {
        return __assign({ moveSpeed: this.DefaultBlockSpeed, blockTextureUri: this.DefaultBlockTexture, blockHalfExtents: this.DefaultBlockHalfExtents, health: this.DefaultBlockHealth, movementBehavior: new block_movement_1.DefaultBlockMovement(), movementBounds: this.DefaultMovementBounds, oscillate: true }, customConfig);
    };
    MovingBlockEntity.isValidDefaultBlockPosition = function (position) {
        var bounds = this.DefaultMovementBounds;
        return (position.x >= bounds.min.x && position.x <= bounds.max.x &&
            position.y >= bounds.min.y && position.y <= bounds.max.y &&
            position.z >= bounds.min.z && position.z <= bounds.max.z);
    };
    MovingBlockEntity.generateDefaultSpawnPosition = function (customBounds) {
        var bounds = customBounds || this.DefaultMovementBounds;
        return {
            x: bounds.min.x + Math.random() * (bounds.max.x - bounds.min.x),
            y: bounds.min.y, // Usually fixed height for Z-axis moving blocks
            z: bounds.min.z + Math.random() * (bounds.max.z - bounds.min.z)
        };
    };
    // Helper method to calculate movement step
    MovingBlockEntity.calculateMovementStep = function (currentPosition, direction, speed, deltaSeconds) {
        return {
            x: currentPosition.x + direction.x * speed * deltaSeconds,
            y: currentPosition.y + direction.y * speed * deltaSeconds,
            z: currentPosition.z + direction.z * speed * deltaSeconds
        };
    };
    // Helper methods for target positioning
    MovingBlockEntity.generateRandomTargetPosition = function (bounds) {
        var heightRange = this.DefaultTargetHeightRange;
        var randomHeight = heightRange.min + Math.random() * (heightRange.max - heightRange.min);
        var defaultBounds = exports.MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS;
        var targetBounds = bounds || defaultBounds;
        return {
            x: targetBounds.min.x + Math.random() * (targetBounds.max.x - targetBounds.min.x),
            y: randomHeight,
            z: targetBounds.min.z + Math.random() * (targetBounds.max.z - targetBounds.min.z)
        };
    };
    MovingBlockEntity.isValidTargetPosition = function (position, bounds) {
        var targetBounds = bounds || exports.MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS;
        var heightRange = this.DefaultTargetHeightRange;
        return (position.x >= targetBounds.min.x && position.x <= targetBounds.max.x &&
            position.y >= heightRange.min && position.y <= heightRange.max &&
            position.z >= targetBounds.min.z && position.z <= targetBounds.max.z);
    };
    // Helper method to create target configuration
    MovingBlockEntity.createTargetConfiguration = function (customConfig) {
        return __assign({ blockTextureUri: this.DefaultTargetTexture, blockHalfExtents: this.DefaultTargetHalfExtents, health: this.DefaultTargetHealth, movementBehavior: new block_movement_1.StaticMovement(), movementBounds: {
                min: {
                    x: exports.MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.min.x,
                    y: this.DefaultTargetHeightRange.min,
                    z: exports.MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.min.z
                },
                max: {
                    x: exports.MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.max.x,
                    y: this.DefaultTargetHeightRange.max,
                    z: exports.MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.max.z
                }
            } }, customConfig);
    };
    Object.defineProperty(MovingBlockEntity, "DefaultPopUpTexture", {
        // Static getters for pop-up target configuration
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.POPUP_TARGET.TEXTURE;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultPopUpHalfExtents", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.POPUP_TARGET.HALF_EXTENTS;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultPopUpStartY", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.POPUP_TARGET.START_Y;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultPopUpTopY", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.POPUP_TARGET.TOP_Y;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultPopUpSpeedMultiplier", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.POPUP_TARGET.SPEED_MULTIPLIER;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultPopUpScoreMultiplier", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.POPUP_TARGET.SCORE_MULTIPLIER;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultPopUpHealth", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.POPUP_TARGET.HEALTH;
        },
        enumerable: false,
        configurable: true
    });
    // Helper method to create pop-up target configuration
    MovingBlockEntity.createPopUpConfiguration = function (customConfig) {
        return __assign({ blockTextureUri: this.DefaultPopUpTexture, blockHalfExtents: this.DefaultPopUpHalfExtents, health: this.DefaultPopUpHealth, moveSpeed: this.DefaultBlockSpeed * this.DefaultPopUpSpeedMultiplier, movementBehavior: new block_movement_1.PopUpMovement({
                startY: this.DefaultPopUpStartY,
                topY: this.DefaultPopUpTopY
            }), movementBounds: undefined, oscillate: false }, customConfig);
    };
    // Helper method to validate pop-up target position
    MovingBlockEntity.isValidPopUpPosition = function (position) {
        // Pop-up targets only need to validate X and Z coordinates since Y is controlled by the movement
        return (position.x >= exports.MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.min.x &&
            position.x <= exports.MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.max.x &&
            position.z >= exports.MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.min.z &&
            position.z <= exports.MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.max.z);
    };
    // Helper method to generate a random pop-up target position
    MovingBlockEntity.generatePopUpSpawnPosition = function () {
        return {
            x: Math.random() * 10 - 5, // Random X between -5 and 5
            y: this.DefaultPopUpStartY,
            z: Math.random() * 20 - 10 // Random Z between -10 and 10
        };
    };
    Object.defineProperty(MovingBlockEntity, "DefaultRisingTexture", {
        // Static getters for rising target configuration
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.RISING_TARGET.TEXTURE;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultRisingHalfExtents", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.RISING_TARGET.HALF_EXTENTS;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultRisingStartY", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.RISING_TARGET.START_Y;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultRisingFirstStopY", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.RISING_TARGET.FIRST_STOP_Y;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultRisingFinalY", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.RISING_TARGET.FINAL_Y;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultRisingSpeedMultiplier", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.RISING_TARGET.SPEED_MULTIPLIER;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultRisingScoreMultiplier", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.RISING_TARGET.SCORE_MULTIPLIER;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultRisingHealth", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.RISING_TARGET.HEALTH;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultRisingPauseDuration", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.RISING_TARGET.PAUSE_DURATION;
        },
        enumerable: false,
        configurable: true
    });
    // Helper method to create rising target configuration
    MovingBlockEntity.createRisingConfiguration = function (customConfig) {
        return __assign({ blockTextureUri: this.DefaultRisingTexture, blockHalfExtents: this.DefaultRisingHalfExtents, health: this.DefaultRisingHealth, moveSpeed: this.DefaultBlockSpeed * this.DefaultRisingSpeedMultiplier, movementBehavior: new block_movement_1.RisingMovement({
                startY: this.DefaultRisingStartY,
                firstStopY: this.DefaultRisingFirstStopY,
                finalY: this.DefaultRisingFinalY,
                pauseDuration: this.DefaultRisingPauseDuration
            }), movementBounds: undefined, oscillate: false }, customConfig);
    };
    // Helper method to validate rising target position
    MovingBlockEntity.isValidRisingPosition = function (position) {
        // Rising targets only need to validate X and Z coordinates since Y is controlled by the movement
        return (position.x >= exports.MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.min.x &&
            position.x <= exports.MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.max.x &&
            position.z >= exports.MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.min.z &&
            position.z <= exports.MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.max.z);
    };
    // Helper method to generate a random rising target position
    MovingBlockEntity.generateRisingSpawnPosition = function () {
        return {
            x: Math.random() * 10 - 5, // Random X between -5 and 5
            y: this.DefaultRisingStartY,
            z: Math.random() * 20 - 10 // Random Z between -10 and 10
        };
    };
    Object.defineProperty(MovingBlockEntity, "DefaultParabolicTexture", {
        // Static getters for parabolic target configuration
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.TEXTURE;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultParabolicHalfExtents", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.HALF_EXTENTS;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultParabolicScoreMultiplier", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SCORE_MULTIPLIER;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultPendulumTexture", {
        // Static getters for pendulum target configuration
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.PENDULUM_TARGET.TEXTURE;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultPendulumHalfExtents", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.PENDULUM_TARGET.HALF_EXTENTS;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultPendulumPivotHeight", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.PENDULUM_TARGET.PIVOT_HEIGHT;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultPendulumLength", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.PENDULUM_TARGET.LENGTH;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultPendulumAmplitude", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.PENDULUM_TARGET.AMPLITUDE;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultPendulumFrequency", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.PENDULUM_TARGET.FREQUENCY;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MovingBlockEntity, "DefaultPendulumScoreMultiplier", {
        get: function () {
            return exports.MOVING_BLOCK_CONFIG.PENDULUM_TARGET.SCORE_MULTIPLIER;
        },
        enumerable: false,
        configurable: true
    });
    // Helper method to create pendulum target configuration
    MovingBlockEntity.createPendulumConfiguration = function (customConfig) {
        return __assign({ blockTextureUri: this.DefaultPendulumTexture, blockHalfExtents: this.DefaultPendulumHalfExtents, health: exports.MOVING_BLOCK_CONFIG.PENDULUM_TARGET.HEALTH, movementBehavior: new block_movement_1.PendulumMovement({
                pivotPoint: {
                    x: 0,
                    y: this.DefaultPendulumPivotHeight,
                    z: 0
                },
                length: this.DefaultPendulumLength,
                amplitude: this.DefaultPendulumAmplitude,
                frequency: this.DefaultPendulumFrequency
            }) }, customConfig);
    };
    // Helper method to create parabolic target configuration
    MovingBlockEntity.createParabolicConfiguration = function (customConfig) {
        // Calculate random start and end X positions using LATERAL bounds
        var randomStartX = Math.random() *
            (exports.MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SPAWN_BOUNDS.LATERAL.MAX -
                exports.MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SPAWN_BOUNDS.LATERAL.MIN) +
            exports.MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SPAWN_BOUNDS.LATERAL.MIN;
        var randomEndX = Math.random() *
            (exports.MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SPAWN_BOUNDS.LATERAL.MAX -
                exports.MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SPAWN_BOUNDS.LATERAL.MIN) +
            exports.MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SPAWN_BOUNDS.LATERAL.MIN;
        // Calculate random distance within the new min/max range
        var distance = exports.MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.MIN_TRAVEL_DISTANCE +
            Math.random() * (exports.MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.MAX_TRAVEL_DISTANCE -
                exports.MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.MIN_TRAVEL_DISTANCE);
        // Use FORWARD bounds for Z coordinates
        var startZ = exports.MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SPAWN_BOUNDS.FORWARD.MIN;
        var endZ = Math.min(startZ + distance, exports.MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SPAWN_BOUNDS.FORWARD.MAX);
        return __assign({ blockTextureUri: this.DefaultParabolicTexture, blockHalfExtents: this.DefaultParabolicHalfExtents, health: exports.MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.HEALTH, movementBehavior: new block_movement_1.ParabolicMovement({
                startPoint: { x: randomStartX, y: exports.MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.START_Y, z: startZ },
                endPoint: { x: randomEndX, y: exports.MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.END_Y, z: endZ },
                maxHeight: exports.MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.MAX_HEIGHT,
                duration: exports.MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.DURATION
            }) }, customConfig);
    };
    // Add getters for scoring calculations
    MovingBlockEntity.prototype.getSpawnTime = function () {
        return this.spawnTime;
    };
    // Use the base class's blockHalfExtents property
    MovingBlockEntity.prototype.getBlockDimensions = function () {
        return this.blockHalfExtents || exports.MOVING_BLOCK_CONFIG.DEFAULT_HALF_EXTENTS;
    };
    MovingBlockEntity.prototype.getMovementBehaviorType = function () {
        return this.movementBehavior.constructor.name;
    };
    MovingBlockEntity.prototype.despawn = function () {
        // Clear despawn timer if it exists
        if (this.despawnTimer) {
            clearTimeout(this.despawnTimer);
            this.despawnTimer = null;
        }
        _super.prototype.despawn.call(this);
    };
    return MovingBlockEntity;
}(hytopia_1.Entity));
exports.MovingBlockEntity = MovingBlockEntity;
var MovingBlockManager = /** @class */ (function () {
    function MovingBlockManager(world, scoreManager) {
        this.world = world;
        this.scoreManager = scoreManager;
        this.blocks = [];
    }
    MovingBlockManager.prototype.getBlockCount = function () {
        var MAX_BLOCK_AGE_MS = 300000; // 5 minutes
        var now = Date.now();
        // Filter out despawned blocks AND old blocks
        this.blocks = this.blocks.filter(function (block) {
            var isValid = block.isSpawned &&
                (now - block.getSpawnTime()) < MAX_BLOCK_AGE_MS;
            // If not valid, make sure it's properly despawned
            if (!isValid && block.isSpawned) {
                block.despawn();
            }
            return isValid;
        });
        return this.blocks.length;
    };
    MovingBlockManager.prototype.createZAxisBlock = function (spawnPosition) {
        var _this = this;
        // Clean up any despawned blocks first
        this.blocks = this.blocks.filter(function (block) { return block.isSpawned; });
        // Get default half extents and reduce by 40%
        var defaultHalfExtents = MovingBlockEntity.DefaultBlockHalfExtents;
        var scaledHalfExtents = {
            x: defaultHalfExtents.x * 0.6, // 40% smaller
            y: defaultHalfExtents.y * 0.6, // 40% smaller
            z: defaultHalfExtents.z * 0.6 // 40% smaller
        };
        // Generate random direction with X component
        var randomAngle = Math.random() * Math.PI * 0.5 - Math.PI * 0.25; // -45 to 45 degrees
        var direction = {
            x: Math.sin(randomAngle) * 0.5, // X component limited to 0.5 magnitude
            y: 0, // Y handled by movement behavior
            z: Math.cos(randomAngle) // Z component
        };
        var block = new MovingBlockEntity(MovingBlockEntity.createDefaultBlockConfiguration({
            blockHalfExtents: scaledHalfExtents,
            direction: direction,
            onBlockBroken: function () {
                if (_this.scoreManager && block.playerId) {
                    var playerId = block.playerId;
                    var score = MovingBlockEntity.DefaultBlockScore;
                    _this.scoreManager.addScore(playerId, score);
                    _this.scoreManager.broadcastScores(_this.world);
                    _this.removeBlock(block);
                }
            }
        }));
        // Generate spawn position respecting platform safety
        var finalSpawnPosition = spawnPosition || this.generateSafeSpawnPosition();
        block.spawn(this.world, finalSpawnPosition);
        this.blocks.push(block);
        return block;
    };
    MovingBlockManager.prototype.generateSafeSpawnPosition = function () {
        var bounds = MovingBlockEntity.DefaultMovementBounds;
        var safetyMargin = exports.MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.PLATFORM_SAFETY_MARGIN;
        var rightPlatformX = exports.MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.RIGHT_PLATFORM_EDGE.X;
        var leftPlatformX = exports.MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.LEFT_PLATFORM_EDGE.X;
        var attempts = 0;
        var position;
        do {
            position = {
                x: bounds.min.x + Math.random() * (bounds.max.x - bounds.min.x),
                y: bounds.min.y + Math.random() * (bounds.max.y - bounds.min.y),
                z: bounds.min.z + Math.random() * (bounds.max.z - bounds.min.z)
            };
            // Check if position is safe from platforms
            var isNearRightPlatform = Math.abs(position.x - rightPlatformX) < safetyMargin &&
                position.z >= exports.MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.RIGHT_PLATFORM_EDGE.Z_MIN - safetyMargin &&
                position.z <= exports.MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.RIGHT_PLATFORM_EDGE.Z_MAX + safetyMargin;
            var isNearLeftPlatform = Math.abs(position.x - leftPlatformX) < safetyMargin &&
                position.z >= exports.MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.LEFT_PLATFORM_EDGE.Z_MIN - safetyMargin &&
                position.z <= exports.MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.LEFT_PLATFORM_EDGE.Z_MAX + safetyMargin;
            if (!isNearRightPlatform && !isNearLeftPlatform) {
                break;
            }
            attempts++;
        } while (attempts < 10);
        // If we couldn't find a safe position, use a guaranteed safe default
        if (attempts >= 10) {
            position = __assign({}, MovingBlockEntity.DefaultSpawnPosition);
        }
        return position;
    };
    MovingBlockManager.prototype.createSineWaveBlock = function (options) {
        var _this = this;
        var _a, _b, _c, _d, _e, _f;
        if (options === void 0) { options = {}; }
        // Clean up any despawned blocks first
        this.blocks = this.blocks.filter(function (block) { return block.isSpawned; });
        var block = new MovingBlockEntity({
            moveSpeed: (_a = options.moveSpeed) !== null && _a !== void 0 ? _a : exports.MOVING_BLOCK_CONFIG.DEFAULT_SPEED * 0.8,
            blockTextureUri: (_b = options.blockTextureUri) !== null && _b !== void 0 ? _b : 'blocks/diamond-ore.png',
            blockHalfExtents: { x: 1, y: 1, z: 1 },
            movementBehavior: new block_movement_1.SineWaveMovement({
                amplitude: (_c = options.amplitude) !== null && _c !== void 0 ? _c : 8, // Increased from 4 to 8 for wider X movement
                frequency: (_d = options.frequency) !== null && _d !== void 0 ? _d : 0.2, // Reduced from 0.5 to 0.2 for slower oscillation
                baseAxis: (_e = options.baseAxis) !== null && _e !== void 0 ? _e : 'z',
                waveAxis: (_f = options.waveAxis) !== null && _f !== void 0 ? _f : 'x'
            }),
            // Wider movement bounds for sine wave pattern
            movementBounds: {
                min: {
                    x: -12, // Increased from -5 to -12 for wider X range
                    y: 1,
                    z: exports.MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.min.z
                },
                max: {
                    x: 12, // Increased from 5 to 12 for wider X range
                    y: 1,
                    z: exports.MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.max.z
                }
            },
            onBlockBroken: function () {
                if (_this.scoreManager && block.playerId) {
                    var playerId = block.playerId;
                    // Give more points for hitting this more challenging target
                    var score = exports.MOVING_BLOCK_CONFIG.BREAK_SCORE * 1.5;
                    _this.scoreManager.addScore(playerId, score);
                    _this.scoreManager.broadcastScores(_this.world);
                    _this.removeBlock(block);
                }
            }
        });
        // Ensure we have a valid spawn position
        var spawnPosition = options.spawnPosition || __assign(__assign({}, exports.MOVING_BLOCK_CONFIG.SPAWN_POSITION), { z: -5 });
        block.spawn(this.world, spawnPosition);
        this.blocks.push(block);
        return block;
    };
    MovingBlockManager.prototype.createStaticTarget = function (options) {
        var _this = this;
        var _a, _b, _c;
        if (options === void 0) { options = {}; }
        // Clean up any despawned blocks first
        this.blocks = this.blocks.filter(function (block) { return block.isSpawned; });
        var spawnPosition = {
            x: (_a = options.x) !== null && _a !== void 0 ? _a : (Math.random() * 16 - 8),
            y: (_b = options.y) !== null && _b !== void 0 ? _b : (2 + Math.random() * 4),
            z: (_c = options.z) !== null && _c !== void 0 ? _c : (Math.random() * 24 - 12)
        };
        // Create block with default target configuration
        var block = new MovingBlockEntity(MovingBlockEntity.createTargetConfiguration({
            despawnTime: options.despawnTime,
            onBlockBroken: function () {
                if (_this.scoreManager && block.playerId) {
                    var playerId = block.playerId;
                    var score = MovingBlockEntity.DefaultTargetScore;
                    _this.scoreManager.addScore(playerId, score);
                    _this.scoreManager.broadcastScores(_this.world);
                    _this.removeBlock(block);
                }
            }
        }));
        block.spawn(this.world, spawnPosition);
        this.blocks.push(block);
        return block;
    };
    MovingBlockManager.prototype.createVerticalWaveBlock = function (options) {
        var _this = this;
        var _a, _b, _c, _d;
        if (options === void 0) { options = {}; }
        // Clean up any despawned blocks first
        this.blocks = this.blocks.filter(function (block) { return block.isSpawned; });
        var amplitude = (_a = options.amplitude) !== null && _a !== void 0 ? _a : exports.MOVING_BLOCK_CONFIG.VERTICAL_WAVE.DEFAULT_AMPLITUDE;
        var heightOffset = exports.MOVING_BLOCK_CONFIG.VERTICAL_WAVE.HEIGHT_OFFSET;
        var safetyMargin = exports.MOVING_BLOCK_CONFIG.VERTICAL_WAVE.SAFETY_MARGIN;
        // Set a fixed Y value for spawning so that the Y movement is not restricted in the bounds.
        var fixedY = heightOffset + safetyMargin;
        var block = new MovingBlockEntity({
            moveSpeed: (_b = options.moveSpeed) !== null && _b !== void 0 ? _b : exports.MOVING_BLOCK_CONFIG.DEFAULT_SPEED * exports.MOVING_BLOCK_CONFIG.VERTICAL_WAVE.SPEED_MULTIPLIER,
            blockTextureUri: (_c = options.blockTextureUri) !== null && _c !== void 0 ? _c : exports.MOVING_BLOCK_CONFIG.VERTICAL_WAVE.TEXTURE,
            blockHalfExtents: exports.MOVING_BLOCK_CONFIG.VERTICAL_WAVE.HALF_EXTENTS,
            health: exports.MOVING_BLOCK_CONFIG.VERTICAL_WAVE.HEALTH, // Set health to 1
            movementBehavior: new block_movement_1.SineWaveMovement({
                amplitude: amplitude,
                frequency: (_d = options.frequency) !== null && _d !== void 0 ? _d : exports.MOVING_BLOCK_CONFIG.VERTICAL_WAVE.DEFAULT_FREQUENCY,
                baseAxis: 'z', // Move forward along Z axis
                waveAxis: 'y' // Oscillate on Y axis
            }),
            // Modified movement bounds: we fix Y to let the sine function determine vertical movement.
            movementBounds: {
                min: {
                    x: -5,
                    y: fixedY,
                    z: exports.MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.min.z
                },
                max: {
                    x: 5,
                    y: fixedY,
                    z: exports.MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.max.z
                }
            },
            onBlockBroken: function () {
                if (_this.scoreManager && block.playerId) {
                    var playerId = block.playerId;
                    var score = exports.MOVING_BLOCK_CONFIG.BREAK_SCORE * exports.MOVING_BLOCK_CONFIG.VERTICAL_WAVE.SCORE_MULTIPLIER;
                    _this.scoreManager.addScore(playerId, score);
                    _this.scoreManager.broadcastScores(_this.world);
                    _this.removeBlock(block);
                }
            }
        });
        // Calculate spawn position with appropriate height offset and safety margin
        var spawnPosition = options.spawnPosition || __assign(__assign({}, exports.MOVING_BLOCK_CONFIG.SPAWN_POSITION), { y: fixedY, z: -5 });
        block.spawn(this.world, spawnPosition);
        this.blocks.push(block);
        return block;
    };
    MovingBlockManager.prototype.createPopUpTarget = function (options) {
        var _this = this;
        var _a, _b;
        if (options === void 0) { options = {}; }
        // Clean up any despawned blocks first
        this.blocks = this.blocks.filter(function (block) { return block.isSpawned; });
        var config = MovingBlockEntity.createPopUpConfiguration({
            moveSpeed: options.moveSpeed,
            blockTextureUri: options.blockTextureUri,
            movementBehavior: new block_movement_1.PopUpMovement({
                startY: (_a = options.startY) !== null && _a !== void 0 ? _a : MovingBlockEntity.DefaultPopUpStartY,
                topY: (_b = options.topY) !== null && _b !== void 0 ? _b : MovingBlockEntity.DefaultPopUpTopY
            })
        });
        var block = new MovingBlockEntity(__assign(__assign({}, config), { onBlockBroken: function () {
                if (_this.scoreManager && block.playerId) {
                    var playerId = block.playerId;
                    var score = exports.MOVING_BLOCK_CONFIG.BREAK_SCORE * MovingBlockEntity.DefaultPopUpScoreMultiplier;
                    _this.scoreManager.addScore(playerId, score);
                    _this.scoreManager.broadcastScores(_this.world);
                    _this.removeBlock(block);
                }
            } }));
        // Calculate spawn position
        var spawnPosition = options.spawnPosition || MovingBlockEntity.generatePopUpSpawnPosition();
        if (!MovingBlockEntity.isValidPopUpPosition(spawnPosition)) {
            block.spawn(this.world, MovingBlockEntity.generatePopUpSpawnPosition());
        }
        else {
            block.spawn(this.world, spawnPosition);
        }
        this.blocks.push(block);
        return block;
    };
    MovingBlockManager.prototype.createRisingTarget = function (options) {
        var _this = this;
        var _a, _b, _c, _d;
        if (options === void 0) { options = {}; }
        // Clean up any despawned blocks first
        this.blocks = this.blocks.filter(function (block) { return block.isSpawned; });
        var config = MovingBlockEntity.createRisingConfiguration({
            moveSpeed: options.moveSpeed,
            blockTextureUri: options.blockTextureUri,
            movementBehavior: new block_movement_1.RisingMovement({
                startY: (_a = options.startY) !== null && _a !== void 0 ? _a : MovingBlockEntity.DefaultRisingStartY,
                firstStopY: (_b = options.firstStopY) !== null && _b !== void 0 ? _b : MovingBlockEntity.DefaultRisingFirstStopY,
                finalY: (_c = options.finalY) !== null && _c !== void 0 ? _c : MovingBlockEntity.DefaultRisingFinalY,
                pauseDuration: (_d = options.pauseDuration) !== null && _d !== void 0 ? _d : MovingBlockEntity.DefaultRisingPauseDuration
            })
        });
        var block = new MovingBlockEntity(__assign(__assign({}, config), { onBlockBroken: function () {
                if (_this.scoreManager && block.playerId) {
                    var playerId = block.playerId;
                    var score = exports.MOVING_BLOCK_CONFIG.BREAK_SCORE * MovingBlockEntity.DefaultRisingScoreMultiplier;
                    _this.scoreManager.addScore(playerId, score);
                    _this.scoreManager.broadcastScores(_this.world);
                    _this.removeBlock(block);
                }
            } }));
        // Calculate spawn position
        var spawnPosition = options.spawnPosition || MovingBlockEntity.generateRisingSpawnPosition();
        if (!MovingBlockEntity.isValidRisingPosition(spawnPosition)) {
            block.spawn(this.world, MovingBlockEntity.generateRisingSpawnPosition());
        }
        else {
            block.spawn(this.world, spawnPosition);
        }
        this.blocks.push(block);
        return block;
    };
    MovingBlockManager.prototype.createParabolicTarget = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        // Clean up any despawned blocks first
        this.blocks = this.blocks.filter(function (block) { return block.isSpawned; });
        var config = MovingBlockEntity.createParabolicConfiguration({
            moveSpeed: options.moveSpeed,
            blockTextureUri: options.blockTextureUri,
            movementBehavior: new block_movement_1.ParabolicMovement({
                startPoint: options.startPoint,
                endPoint: options.endPoint,
                maxHeight: options.maxHeight,
                duration: options.duration
            })
        });
        var block = new MovingBlockEntity(__assign(__assign({}, config), { onBlockBroken: function () {
                if (_this.scoreManager && block.playerId) {
                    var playerId = block.playerId;
                    var score = exports.MOVING_BLOCK_CONFIG.BREAK_SCORE * MovingBlockEntity.DefaultParabolicScoreMultiplier;
                    _this.scoreManager.addScore(playerId, score);
                    _this.scoreManager.broadcastScores(_this.world);
                    _this.removeBlock(block);
                }
            } }));
        // Use the start point from the movement behavior
        var startPosition = config.movementBehavior['startPoint'];
        block.spawn(this.world, startPosition);
        this.blocks.push(block);
        return block;
    };
    MovingBlockManager.prototype.createPendulumTarget = function (options) {
        var _this = this;
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (options === void 0) { options = {}; }
        // Clean up any despawned blocks first
        this.blocks = this.blocks.filter(function (block) { return block.isSpawned; });
        var config = MovingBlockEntity.createPendulumConfiguration({
            moveSpeed: options.moveSpeed,
            blockTextureUri: options.blockTextureUri,
            movementBehavior: new block_movement_1.PendulumMovement({
                pivotPoint: options.pivotPoint,
                length: options.length,
                amplitude: options.amplitude,
                frequency: options.frequency
            })
        });
        var block = new MovingBlockEntity(__assign(__assign({}, config), { onBlockBroken: function () {
                if (_this.scoreManager && block.playerId) {
                    var playerId = block.playerId;
                    // Let ScoreManager handle the scoring calculation
                    var score = exports.MOVING_BLOCK_CONFIG.BREAK_SCORE;
                    _this.scoreManager.addScore(playerId, score);
                    _this.scoreManager.broadcastScores(_this.world);
                    _this.removeBlock(block);
                }
            } }));
        // Calculate spawn position based on pivot point and length
        var spawnPosition = {
            x: (_b = (_a = options.pivotPoint) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : 0,
            y: ((_d = (_c = options.pivotPoint) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : MovingBlockEntity.DefaultPendulumPivotHeight) -
                ((_e = options.length) !== null && _e !== void 0 ? _e : MovingBlockEntity.DefaultPendulumLength),
            z: ((_g = (_f = options.pivotPoint) === null || _f === void 0 ? void 0 : _f.z) !== null && _g !== void 0 ? _g : 0) + ((_h = options.length) !== null && _h !== void 0 ? _h : MovingBlockEntity.DefaultPendulumLength)
        };
        block.spawn(this.world, spawnPosition);
        this.blocks.push(block);
        return block;
    };
    MovingBlockManager.prototype.removeBlock = function (block) {
        var index = this.blocks.indexOf(block);
        if (index !== -1) {
            this.blocks.splice(index, 1);
        }
    };
    return MovingBlockManager;
}());
exports.MovingBlockManager = MovingBlockManager;

================
File: src/moving_blocks/moving-block-entity.ts
================
import { Entity, EntityOptions, Vector3Like, ColliderShape, CollisionGroup, World, RigidBodyType, BlockType, PlayerEntity, EntityEvent } from 'hytopia';
import { ScoreManager } from '../managers/score-manager';
import { BlockMovementBehavior, DefaultBlockMovement, SineWaveMovement, StaticMovement, PopUpMovement, RisingMovement, ParabolicMovement, PendulumMovement } from './block-movement';
import { DESTRUCTION_PARTICLE_CONFIG } from '../config/particle-config';
import { BlockParticleEffects } from '../effects/block-particle-effects';
import { SceneUIManager } from '../scene-ui/scene-ui-manager';
import { ProjectileEntity } from '../entities/projectile-entity';


// Configuration for our Z-axis moving block
export const MOVING_BLOCK_CONFIG = {
  DEFAULT_SPEED: 6,
  DEFAULT_HEALTH: 5,
  DEFAULT_TEXTURE: 'blocks/creep.png',
  DEFAULT_HALF_EXTENTS: { x: 0.5, y: 2, z: 2 },
  MOVEMENT_BOUNDS: {
    min: { x: -15, y: 2, z: -15 },  // Wider X range, higher minimum Y
    max: { x: 15, y: 12, z: 16 }    // Wider X range, higher maximum Y
  },
  SPAWN_POSITION: { x: 0, y: 4, z: 0 },  // Higher default spawn
  BREAK_SCORE: 5,  // Points awarded for breaking a block
  STATIC_TARGET: {
    TEXTURE: 'blocks/gold-ore.png',
    HALF_EXTENTS: { x: 0.8, y: 0.8, z: 0.8 }, // Balanced size for visibility and challenge
    HEIGHT_RANGE: { min: 3, max: 8 },  // Higher range for better visibility
    SCORE: 10, // More points for hitting target
    HEALTH: 1  // One-shot kill
  },
  PLATFORM_SAFETY: {
    RIGHT_PLATFORM_EDGE: {
      X: 19,
      Z_MIN: -9,
      Z_MAX: 9
    },
    LEFT_PLATFORM_EDGE: {
      X: -18,
      Z_MIN: -9,
      Z_MAX: -8
    },
    PLATFORM_SAFETY_MARGIN: 8, // Increased margin for better spacing
    MIN_DISTANCE_BETWEEN_TARGETS: 7  // Increased minimum distance between targets
  },
  PENDULUM_TARGET: {
    TEXTURE: 'blocks/nuit-leaves.png',
    HALF_EXTENTS: { x: 0.8, y: 0.8, z: 0.8 },
    PIVOT_HEIGHT: 15,
    LENGTH: 10,
    AMPLITUDE: Math.PI / 3,
    FREQUENCY: 0.4,
    SCORE_MULTIPLIER: 3,
    HEALTH: 1,
    SPAWN_BOUNDS: {
      LATERAL: { 
        MIN: -12,  // Reduced to keep further from left platform
        MAX: 13    // Reduced to keep further from right platform
      },
      FORWARD: { 
        MIN: -5,   // Reduced to keep further from platform depths
        MAX: 5     // Reduced to keep further from platform depths
      }
    },
    MIN_DISTANCE_FROM_PLATFORMS: 8, // Increased minimum distance from platforms
    SPAWN_SPACING: {
      MIN_X_DISTANCE: 2,  // Increased minimum X distance between pendulums
      MIN_Z_DISTANCE: 8    // Increased minimum Z distance between pendulums
    }
  },
  VERTICAL_WAVE: {  // New configuration for vertical sine wave blocks
    TEXTURE: 'blocks/infected-shadowrock.png',
    HALF_EXTENTS: { x: 1, y: 1, z: 1 },
    DEFAULT_AMPLITUDE: 4,  // Reduced amplitude to prevent floor collision
    DEFAULT_FREQUENCY: 0.5,  // Slightly faster than horizontal sine wave
    HEIGHT_OFFSET: 10,  // Significantly increased base height
    SAFETY_MARGIN: 2,   // Extra space to prevent any collision
    SCORE_MULTIPLIER: 2,  // Double points for hitting this challenging target
    SPEED_MULTIPLIER: 0.7,  // Slightly slower forward movement for better visibility
    HEALTH: 1  // One-shot kill, like static targets
  },
  POPUP_TARGET: {
    TEXTURE: 'blocks/diamond-ore.png',
    HALF_EXTENTS: { x: 0.8, y: 0.8, z: 0.8 },
    START_Y: -20,
    TOP_Y: 8,
    SPEED_MULTIPLIER: 1.5,  // Faster than normal blocks
    SCORE_MULTIPLIER: 2,    // Double points for hitting this challenging target
    HEALTH: 1              // One-shot kill
  },
  RISING_TARGET: {
    TEXTURE: 'blocks/emerald-ore.png',
    HALF_EXTENTS: { x: 0.8, y: 0.8, z: 0.8 },
    START_Y: -20,
    FIRST_STOP_Y: 8,    // Same height as pop-up target
    FINAL_Y: 30,        // Much higher final position
    SPEED_MULTIPLIER: 2.0,  // Faster than pop-up target
    SCORE_MULTIPLIER: 3,    // Triple points for hitting this challenging target
    HEALTH: 1,             // One-shot kill
    PAUSE_DURATION: 2000   // 2 seconds at first stop
  },
  PARABOLIC_TARGET: {
    TEXTURE: 'blocks/swirl-rune.png',
    HALF_EXTENTS: { x: 0.8, y: 0.8, z: 0.8 },
    START_Y: -20,
    MAX_HEIGHT: 20,        // Increased height for more dramatic arc
    END_Y: -20,
    SPEED_MULTIPLIER: 1.0,  // Not used in new physics-based system
    SCORE_MULTIPLIER: 4,    // Highest points due to difficulty
    HEALTH: 1,             // One-shot kill
    DURATION: 5000,        // 5 seconds total
    SPAWN_BOUNDS: {
      FORWARD: {          // Z-axis (depth) boundaries
        MIN: -25,         // How far back it can start
        MAX: 25          // How far forward it can go
      },
      LATERAL: {          // X-axis (side-to-side) boundaries
        MIN: -15,         // How far left it can go
        MAX: 15          // How far right it can go
      }
    },
    MIN_TRAVEL_DISTANCE: 30,  // Minimum distance the block must travel
    MAX_TRAVEL_DISTANCE: 50   // Maximum distance the block can travel
  },
  PARTICLE_CONFIG: {
    COUNT: 50,               
    SCALE: 0.15,            
    LIFETIME: 800,          
    SPREAD_RADIUS: 0.3,     
    SPEED: 0.15             
  }
};


export interface MovingBlockOptions extends EntityOptions {
  moveSpeed?: number;         // Speed at which the block moves (units per second)
  direction?: Vector3Like;    // Direction vector for movement
  movementBounds?: {         // Optional boundaries for movement
    min: Vector3Like;
    max: Vector3Like;
  };
  oscillate?: boolean;       // Whether the block should reverse direction at boundaries
  blockTextureUri?: string;  // The texture to use for the block
  blockHalfExtents?: Vector3Like; // The size of the block
  health?: number;           // Health of the block before breaking
  isBreakable?: boolean;     // Whether the block can be broken
  onBlockBroken?: () => void; // Optional callback to be triggered when the block is broken
  movementBehavior?: BlockMovementBehavior; // New: inject block-specific movement logic
  despawnTime?: number;      // Optional: Time in milliseconds after which the block should despawn
}

export class MovingBlockEntity extends Entity {
  protected moveSpeed: number;
  protected direction: Vector3Like;
  protected initialPosition: Vector3Like;
  protected movementBounds?: { min: Vector3Like; max: Vector3Like };
  protected oscillate: boolean;
  private isReversed: boolean = false;
  private health: number;
  private isBreakable: boolean;
  private onBlockBroken?: () => void;
  private playerId?: string;  // Store the ID of player who last hit the block
  protected movementBehavior: BlockMovementBehavior;
  private particles: Entity[] = [];
  private particleEffects: BlockParticleEffects | null;
  private spawnTime: number;  // Add spawn time tracking
  private despawnTimer: NodeJS.Timeout | null = null;  // Add despawn timer

  constructor(options: MovingBlockOptions) {
    super({
      ...options,
      name: options.name || 'MovingBlock',
      blockTextureUri: options.blockTextureUri || MOVING_BLOCK_CONFIG.DEFAULT_TEXTURE,
      blockHalfExtents: options.blockHalfExtents || MOVING_BLOCK_CONFIG.DEFAULT_HALF_EXTENTS,
      rigidBodyOptions: {
        type: RigidBodyType.KINEMATIC_POSITION,
        colliders: [{
          shape: ColliderShape.BLOCK,
          halfExtents: options.blockHalfExtents || MOVING_BLOCK_CONFIG.DEFAULT_HALF_EXTENTS,
          collisionGroups: {
            belongsTo: [CollisionGroup.BLOCK],
            collidesWith: [CollisionGroup.PLAYER, CollisionGroup.BLOCK, CollisionGroup.ENTITY]
          },
          onCollision: (other: Entity | BlockType, started: boolean) => {
            if (started && this.isBreakable && other instanceof Entity) {
              this.handleCollision(other);
            }
          }
        }]
      }
    });
    
    // Initialize other properties
    this.moveSpeed = options.moveSpeed ?? MOVING_BLOCK_CONFIG.DEFAULT_SPEED;
    this.direction = this.normalizeDirection(options.direction || { x: 0, y: 0, z: 1 });
    this.movementBounds = options.movementBounds || MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS;
    this.oscillate = options.oscillate ?? true;
    this.initialPosition = { x: 0, y: 0, z: 0 };
    this.health = options.health ?? MOVING_BLOCK_CONFIG.DEFAULT_HEALTH;
    this.isBreakable = options.isBreakable ?? true;
    this.onBlockBroken = options.onBlockBroken;
    this.movementBehavior = options.movementBehavior || new DefaultBlockMovement();
    this.particleEffects = null;
    this.spawnTime = Date.now();
    
    // Register for tick events using the event system
    this.on(EntityEvent.TICK, ({ tickDeltaMs }) => {
      // Delegate movement update to injected behavior
      this.movementBehavior.update(this, tickDeltaMs);
    });

    // Set up despawn timer if specified
    if (options.despawnTime) {
      this.despawnTimer = setTimeout(() => {
        if (this.isSpawned) {
          this.despawn();
        }
      }, options.despawnTime);
    }
  }

  private normalizeDirection(dir: Vector3Like): Vector3Like {
    const magnitude = Math.sqrt(dir.x * dir.x + dir.y * dir.y + dir.z * dir.z);
    if (magnitude === 0) return { x: 0, y: 0, z: 1 }; // Default to moving along Z-axis
    return {
      x: dir.x / magnitude,
      y: dir.y / magnitude,
      z: dir.z / magnitude
    };
  }

  override spawn(world: World, position: Vector3Like): void {
    super.spawn(world, position);
    this.initialPosition = { ...position };
    this.particleEffects = BlockParticleEffects.getInstance(world);
    
    // Movement is now handled by the onTick event registered in the constructor
  }

  private isWithinBounds(position: Vector3Like): boolean {
    if (!this.movementBounds) return true;

    // Use a larger epsilon for boundary checks to prevent jittering
    const epsilon = 0.05;
    
    // Check each axis independently and apply epsilon consistently
    const withinX = position.x >= (this.movementBounds.min.x + epsilon) && 
                    position.x <= (this.movementBounds.max.x - epsilon);
    const withinY = position.y >= (this.movementBounds.min.y + epsilon) && 
                    position.y <= (this.movementBounds.max.y - epsilon);
    const withinZ = position.z >= (this.movementBounds.min.z + epsilon) && 
                    position.z <= (this.movementBounds.max.z - epsilon);

    // Only enforce bounds on axes that have different min/max values
    const needsXCheck = Math.abs(this.movementBounds.max.x - this.movementBounds.min.x) > epsilon;
    const needsYCheck = Math.abs(this.movementBounds.max.y - this.movementBounds.min.y) > epsilon;
    const needsZCheck = Math.abs(this.movementBounds.max.z - this.movementBounds.min.z) > epsilon;

    return (!needsXCheck || withinX) && 
           (!needsYCheck || withinY) && 
           (!needsZCheck || withinZ);
  }

  private reverseDirection(): void {
    this.direction.x *= -1;
    this.direction.y *= -1;
    this.direction.z *= -1;
    this.isReversed = !this.isReversed;
  }


  private handleCollision(other: Entity): void {
    // Check if the colliding entity is a projectile
    if (other.name.toLowerCase().includes('projectile') && other instanceof ProjectileEntity) {
      // Store the player ID from the projectile if available
      this.playerId = other.playerId;
      
      // Calculate score using the new dynamic scoring system
      if (this.world && this.playerId) {
        const scoreManager = this.world.entityManager.getAllEntities()
          .find(entity => entity instanceof ScoreManager) as ScoreManager | undefined;
          
        if (scoreManager) {
          const score = scoreManager.calculateGrenadeTargetScore(
            other,
            this,
            this.position,
            this.playerId
          );
          
          scoreManager.addScore(this.playerId, score);
          
          // Get the player who hit the block
          const player = this.world.entityManager.getAllPlayerEntities()
            .find(p => p.player.id === this.playerId)?.player;

          if (player) {
            // Show block destroyed notification with the score
            const sceneUIManager = SceneUIManager.getInstance(this.world);
            sceneUIManager.showBlockDestroyedNotification(this.position, score, player);
          }
          
          // Create destruction effect before despawning
          if (this.blockTextureUri) {
            const particleEffects = BlockParticleEffects.getInstance(this.world);
            particleEffects.createDestructionEffect(this.world, this.position, this.blockTextureUri);
          }
          
          // Broadcast updated scores
          scoreManager.broadcastScores(this.world);
          
          // Destroy the block after scoring
          if (this.isSpawned) {
            this.despawn();
          }
        } else {
          this.takeDamage(1); // Fallback to simple damage
        }
      } else {
        this.takeDamage(1); // Fallback to simple damage
      }
      
      // Despawn the projectile that hit us
      if (other.isSpawned) {
        other.despawn();
      }
    }
  }

  private takeDamage(amount: number): void {
    if (!this.isBreakable) return;

    this.health -= amount;
    
    // Get the player who hit the block
    const player = this.world?.entityManager.getAllPlayerEntities()
      .find((p: PlayerEntity) => p.player.id === this.playerId)?.player;
    
    if (!player || !this.world) return;
    
    // Get the SceneUIManager instance
    const sceneUIManager = SceneUIManager.getInstance(this.world);
    
    if (this.health <= 0) {
      // Calculate score before showing notification
      const score = this.calculateScore();
      
      // Show block destroyed notification with appropriate score
      sceneUIManager.showBlockDestroyedNotification(this.position, score, player);
      
      // Create destruction effect before despawning
      this.createDestructionEffect();
      
      if (this.onBlockBroken) {
        this.onBlockBroken();
      }
      
      this.despawn();
      return;
    } else {
      // Show hit notification for non-destroying hits
      sceneUIManager.showHitNotification(this.position, 1, player); // Show +1 for each hit
    }
    
    // Instead of changing opacity, change the block type based on health
    const blockTypes = [
      'blocks/void-sand.png',
      'blocks/infected-shadowrock.png',
      'blocks/dragons-stone.png',
      'blocks/diamond-ore.png',
      'blocks/clay.png'
    ];
    
    // Calculate which block type to use based on health
    const blockIndex = Math.floor((this.health / MOVING_BLOCK_CONFIG.DEFAULT_HEALTH) * (blockTypes.length - 1));
    const newBlockType = blockTypes[Math.max(0, Math.min(blockIndex, blockTypes.length - 1))];
    
    // Create a new block with the same properties but different texture
    const newBlock = new MovingBlockEntity({
      blockTextureUri: newBlockType,
      moveSpeed: this.moveSpeed,
      direction: this.direction,
      movementBounds: this.movementBounds,
      oscillate: this.oscillate,
      health: this.health,
      isBreakable: this.isBreakable,
      onBlockBroken: this.onBlockBroken,  // Transfer the callback
      movementBehavior: this.movementBehavior // Transfer the movement behavior
    });

    // Transfer the player ID to the new block
    (newBlock as any).playerId = this.playerId;

    // Spawn the new block at the current position
    if (this.world) {
      newBlock.spawn(this.world, this.position);
    }

    // Despawn the old block
    this.despawn();
  }

  private calculateScore(): number {
    // Base score calculation based on block type and difficulty
    let score = MOVING_BLOCK_CONFIG.BREAK_SCORE;
    
    // Multiply score based on movement behavior
    if (this.movementBehavior instanceof SineWaveMovement) {
      score *= 1.5; // Sine wave blocks are harder to hit
    } else if (this.movementBehavior instanceof PopUpMovement) {
      score *= MOVING_BLOCK_CONFIG.POPUP_TARGET.SCORE_MULTIPLIER;
    } else if (this.movementBehavior instanceof RisingMovement) {
      score *= MOVING_BLOCK_CONFIG.RISING_TARGET.SCORE_MULTIPLIER;
    } else if (this.movementBehavior instanceof ParabolicMovement) {
      score *= MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SCORE_MULTIPLIER;
    } else if (this.movementBehavior instanceof StaticMovement) {
      score = MOVING_BLOCK_CONFIG.STATIC_TARGET.SCORE; // Static targets have their own base score
    }
    
    return Math.round(score);
  }

  // --- Added getter and helper methods for movement behavior use ---

  public getDirection(): Vector3Like {
    return { ...this.direction }; // Return a copy to prevent direct modification
  }

  public getMoveSpeed(): number {
    return this.moveSpeed;
  }

  public isWithinMovementBounds(position: Vector3Like): boolean {
    return this.isWithinBounds(position);
  }

  public shouldOscillate(): boolean {
    return this.oscillate;
  }

  public reverseMovementDirection(): void {
    this.reverseDirection();
  }

  public resetToInitialPosition(): void {
    this.setPosition(this.initialPosition);
  }

  private getDebugInfo(): string {
    const halfExtents = this.blockHalfExtents || { x: 0, y: 0, z: 0 };
    return `MovingBlock Debug Info:
      ID: ${this.id}
      Position: x=${this.position.x.toFixed(2)}, y=${this.position.y.toFixed(2)}, z=${this.position.z.toFixed(2)}
      Direction: x=${this.direction.x.toFixed(2)}, y=${this.direction.y.toFixed(2)}, z=${this.direction.z.toFixed(2)}
      Speed: ${this.moveSpeed}
      Health: ${this.health}
      Is Breakable: ${this.isBreakable}
      Oscillating: ${this.oscillate}
      Is Reversed: ${this.isReversed}
      Movement Bounds: ${this.movementBounds ? 
        `\n        Min: x=${this.movementBounds.min.x}, y=${this.movementBounds.min.y}, z=${this.movementBounds.min.z}
        Max: x=${this.movementBounds.max.x}, y=${this.movementBounds.max.y}, z=${this.movementBounds.max.z}` 
        : 'None'}
      Last Hit By Player: ${this.playerId || 'None'}
      Texture: ${this.blockTextureUri || 'None'}
      Half Extents: x=${halfExtents.x}, y=${halfExtents.y}, z=${halfExtents.z}
      Is Spawned: ${this.isSpawned}`;
  }

  private createDestructionEffect(): void {
    if (!this.world || !this.blockTextureUri) return;
    this.particleEffects?.createDestructionEffect(this.world, this.position, this.blockTextureUri);
  }

  // Static getters for default target configuration
  static get DefaultTargetTexture(): string {
    return MOVING_BLOCK_CONFIG.STATIC_TARGET.TEXTURE;
  }

  static get DefaultTargetHalfExtents(): Vector3Like {
    return MOVING_BLOCK_CONFIG.STATIC_TARGET.HALF_EXTENTS;
  }

  static get DefaultTargetHeightRange(): { min: number; max: number } {
    return MOVING_BLOCK_CONFIG.STATIC_TARGET.HEIGHT_RANGE;
  }

  static get DefaultTargetScore(): number {
    return MOVING_BLOCK_CONFIG.STATIC_TARGET.SCORE;
  }

  static get DefaultTargetHealth(): number {
    return MOVING_BLOCK_CONFIG.STATIC_TARGET.HEALTH;
  }

  // Z-Axis Moving Block (Default Block) Getters
  static get DefaultBlockSpeed(): number {
    return MOVING_BLOCK_CONFIG.DEFAULT_SPEED;
  }

  static get DefaultBlockHealth(): number {
    return MOVING_BLOCK_CONFIG.DEFAULT_HEALTH;
  }

  static get DefaultBlockTexture(): string {
    return MOVING_BLOCK_CONFIG.DEFAULT_TEXTURE;
  }

  static get DefaultBlockHalfExtents(): Vector3Like {
    return MOVING_BLOCK_CONFIG.DEFAULT_HALF_EXTENTS;
  }

  static get DefaultBlockScore(): number {
    return MOVING_BLOCK_CONFIG.BREAK_SCORE;
  }

  static get DefaultMovementBounds(): { min: Vector3Like; max: Vector3Like } {
    return MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS;
  }

  static get DefaultSpawnPosition(): Vector3Like {
    return MOVING_BLOCK_CONFIG.SPAWN_POSITION;
  }

  // Helper methods for Z-Axis Moving Block
  static createDefaultBlockConfiguration(customConfig?: Partial<MovingBlockOptions>): MovingBlockOptions {
    return {
      moveSpeed: this.DefaultBlockSpeed,
      blockTextureUri: this.DefaultBlockTexture,
      blockHalfExtents: this.DefaultBlockHalfExtents,
      health: this.DefaultBlockHealth,
      movementBehavior: new DefaultBlockMovement(),
      movementBounds: this.DefaultMovementBounds,
      oscillate: true, // Default behavior is to oscillate
      ...customConfig
    };
  }

  static isValidDefaultBlockPosition(position: Vector3Like): boolean {
    const bounds = this.DefaultMovementBounds;
    return (
      position.x >= bounds.min.x && position.x <= bounds.max.x &&
      position.y >= bounds.min.y && position.y <= bounds.max.y &&
      position.z >= bounds.min.z && position.z <= bounds.max.z
    );
  }

  static generateDefaultSpawnPosition(customBounds?: { min: Vector3Like; max: Vector3Like }): Vector3Like {
    const bounds = customBounds || this.DefaultMovementBounds;
    return {
      x: bounds.min.x + Math.random() * (bounds.max.x - bounds.min.x),
      y: bounds.min.y, // Usually fixed height for Z-axis moving blocks
      z: bounds.min.z + Math.random() * (bounds.max.z - bounds.min.z)
    };
  }

  // Helper method to calculate movement step
  static calculateMovementStep(currentPosition: Vector3Like, direction: Vector3Like, speed: number, deltaSeconds: number): Vector3Like {
    return {
      x: currentPosition.x + direction.x * speed * deltaSeconds,
      y: currentPosition.y + direction.y * speed * deltaSeconds,
      z: currentPosition.z + direction.z * speed * deltaSeconds
    };
  }

  // Helper methods for target positioning
  static generateRandomTargetPosition(bounds?: { min: Vector3Like; max: Vector3Like }): Vector3Like {
    const heightRange = this.DefaultTargetHeightRange;
    const randomHeight = heightRange.min + Math.random() * (heightRange.max - heightRange.min);

    const defaultBounds = MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS;
    const targetBounds = bounds || defaultBounds;

    return {
      x: targetBounds.min.x + Math.random() * (targetBounds.max.x - targetBounds.min.x),
      y: randomHeight,
      z: targetBounds.min.z + Math.random() * (targetBounds.max.z - targetBounds.min.z)
    };
  }

  static isValidTargetPosition(position: Vector3Like, bounds?: { min: Vector3Like; max: Vector3Like }): boolean {
    const targetBounds = bounds || MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS;
    const heightRange = this.DefaultTargetHeightRange;

    return (
      position.x >= targetBounds.min.x && position.x <= targetBounds.max.x &&
      position.y >= heightRange.min && position.y <= heightRange.max &&
      position.z >= targetBounds.min.z && position.z <= targetBounds.max.z
    );
  }

  // Helper method to create target configuration
  static createTargetConfiguration(customConfig?: Partial<MovingBlockOptions>): MovingBlockOptions {
    return {
      blockTextureUri: this.DefaultTargetTexture,
      blockHalfExtents: this.DefaultTargetHalfExtents,
      health: this.DefaultTargetHealth,
      movementBehavior: new StaticMovement(),
      movementBounds: {
        min: { 
          x: MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.min.x,
          y: this.DefaultTargetHeightRange.min,
          z: MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.min.z
        },
        max: {
          x: MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.max.x,
          y: this.DefaultTargetHeightRange.max,
          z: MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.max.z
        }
      },
      ...customConfig
    };
  }

  // Static getters for pop-up target configuration
  static get DefaultPopUpTexture(): string {
    return MOVING_BLOCK_CONFIG.POPUP_TARGET.TEXTURE;
  }

  static get DefaultPopUpHalfExtents(): Vector3Like {
    return MOVING_BLOCK_CONFIG.POPUP_TARGET.HALF_EXTENTS;
  }

  static get DefaultPopUpStartY(): number {
    return MOVING_BLOCK_CONFIG.POPUP_TARGET.START_Y;
  }

  static get DefaultPopUpTopY(): number {
    return MOVING_BLOCK_CONFIG.POPUP_TARGET.TOP_Y;
  }

  static get DefaultPopUpSpeedMultiplier(): number {
    return MOVING_BLOCK_CONFIG.POPUP_TARGET.SPEED_MULTIPLIER;
  }

  static get DefaultPopUpScoreMultiplier(): number {
    return MOVING_BLOCK_CONFIG.POPUP_TARGET.SCORE_MULTIPLIER;
  }

  static get DefaultPopUpHealth(): number {
    return MOVING_BLOCK_CONFIG.POPUP_TARGET.HEALTH;
  }

  // Helper method to create pop-up target configuration
  static createPopUpConfiguration(customConfig?: Partial<MovingBlockOptions>): MovingBlockOptions {
    return {
      blockTextureUri: this.DefaultPopUpTexture,
      blockHalfExtents: this.DefaultPopUpHalfExtents,
      health: this.DefaultPopUpHealth,
      moveSpeed: this.DefaultBlockSpeed * this.DefaultPopUpSpeedMultiplier,
      movementBehavior: new PopUpMovement({
        startY: this.DefaultPopUpStartY,
        topY: this.DefaultPopUpTopY
      }),
      movementBounds: undefined, // Pop-up targets handle their own boundaries
      oscillate: false, // Pop-up targets don't oscillate
      ...customConfig
    };
  }

  // Helper method to validate pop-up target position
  static isValidPopUpPosition(position: Vector3Like): boolean {
    // Pop-up targets only need to validate X and Z coordinates since Y is controlled by the movement
    return (
      position.x >= MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.min.x &&
      position.x <= MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.max.x &&
      position.z >= MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.min.z &&
      position.z <= MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.max.z
    );
  }

  // Helper method to generate a random pop-up target position
  static generatePopUpSpawnPosition(): Vector3Like {
    return {
      x: Math.random() * 10 - 5, // Random X between -5 and 5
      y: this.DefaultPopUpStartY,
      z: Math.random() * 20 - 10 // Random Z between -10 and 10
    };
  }

  // Static getters for rising target configuration
  static get DefaultRisingTexture(): string {
    return MOVING_BLOCK_CONFIG.RISING_TARGET.TEXTURE;
  }

  static get DefaultRisingHalfExtents(): Vector3Like {
    return MOVING_BLOCK_CONFIG.RISING_TARGET.HALF_EXTENTS;
  }

  static get DefaultRisingStartY(): number {
    return MOVING_BLOCK_CONFIG.RISING_TARGET.START_Y;
  }

  static get DefaultRisingFirstStopY(): number {
    return MOVING_BLOCK_CONFIG.RISING_TARGET.FIRST_STOP_Y;
  }

  static get DefaultRisingFinalY(): number {
    return MOVING_BLOCK_CONFIG.RISING_TARGET.FINAL_Y;
  }

  static get DefaultRisingSpeedMultiplier(): number {
    return MOVING_BLOCK_CONFIG.RISING_TARGET.SPEED_MULTIPLIER;
  }

  static get DefaultRisingScoreMultiplier(): number {
    return MOVING_BLOCK_CONFIG.RISING_TARGET.SCORE_MULTIPLIER;
  }

  static get DefaultRisingHealth(): number {
    return MOVING_BLOCK_CONFIG.RISING_TARGET.HEALTH;
  }

  static get DefaultRisingPauseDuration(): number {
    return MOVING_BLOCK_CONFIG.RISING_TARGET.PAUSE_DURATION;
  }

  // Helper method to create rising target configuration
  static createRisingConfiguration(customConfig?: Partial<MovingBlockOptions>): MovingBlockOptions {
    return {
      blockTextureUri: this.DefaultRisingTexture,
      blockHalfExtents: this.DefaultRisingHalfExtents,
      health: this.DefaultRisingHealth,
      moveSpeed: this.DefaultBlockSpeed * this.DefaultRisingSpeedMultiplier,
      movementBehavior: new RisingMovement({
        startY: this.DefaultRisingStartY,
        firstStopY: this.DefaultRisingFirstStopY,
        finalY: this.DefaultRisingFinalY,
        pauseDuration: this.DefaultRisingPauseDuration
      }),
      movementBounds: undefined,
      oscillate: false,
      ...customConfig
    };
  }

  // Helper method to validate rising target position
  static isValidRisingPosition(position: Vector3Like): boolean {
    // Rising targets only need to validate X and Z coordinates since Y is controlled by the movement
    return (
      position.x >= MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.min.x &&
      position.x <= MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.max.x &&
      position.z >= MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.min.z &&
      position.z <= MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.max.z
    );
  }

  // Helper method to generate a random rising target position
  static generateRisingSpawnPosition(): Vector3Like {
    return {
      x: Math.random() * 10 - 5, // Random X between -5 and 5
      y: this.DefaultRisingStartY,
      z: Math.random() * 20 - 10 // Random Z between -10 and 10
    };
  }

  // Static getters for parabolic target configuration
  static get DefaultParabolicTexture(): string {
    return MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.TEXTURE;
  }

  static get DefaultParabolicHalfExtents(): Vector3Like {
    return MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.HALF_EXTENTS;
  }

  static get DefaultParabolicScoreMultiplier(): number {
    return MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SCORE_MULTIPLIER;
  }

  // Static getters for pendulum target configuration
  static get DefaultPendulumTexture(): string {
    return MOVING_BLOCK_CONFIG.PENDULUM_TARGET.TEXTURE;
  }

  static get DefaultPendulumHalfExtents(): Vector3Like {
    return MOVING_BLOCK_CONFIG.PENDULUM_TARGET.HALF_EXTENTS;
  }

  static get DefaultPendulumPivotHeight(): number {
    return MOVING_BLOCK_CONFIG.PENDULUM_TARGET.PIVOT_HEIGHT;
  }

  static get DefaultPendulumLength(): number {
    return MOVING_BLOCK_CONFIG.PENDULUM_TARGET.LENGTH;
  }

  static get DefaultPendulumAmplitude(): number {
    return MOVING_BLOCK_CONFIG.PENDULUM_TARGET.AMPLITUDE;
  }

  static get DefaultPendulumFrequency(): number {
    return MOVING_BLOCK_CONFIG.PENDULUM_TARGET.FREQUENCY;
  }

  static get DefaultPendulumScoreMultiplier(): number {
    return MOVING_BLOCK_CONFIG.PENDULUM_TARGET.SCORE_MULTIPLIER;
  }

  // Helper method to create pendulum target configuration
  static createPendulumConfiguration(customConfig?: Partial<MovingBlockOptions>): MovingBlockOptions {
    return {
      blockTextureUri: this.DefaultPendulumTexture,
      blockHalfExtents: this.DefaultPendulumHalfExtents,
      health: MOVING_BLOCK_CONFIG.PENDULUM_TARGET.HEALTH,
      movementBehavior: new PendulumMovement({
        pivotPoint: { 
          x: 0, 
          y: this.DefaultPendulumPivotHeight, 
          z: 0 
        },
        length: this.DefaultPendulumLength,
        amplitude: this.DefaultPendulumAmplitude,
        frequency: this.DefaultPendulumFrequency
      }),
      ...customConfig
    };
  }

  // Helper method to create parabolic target configuration
  static createParabolicConfiguration(customConfig?: Partial<MovingBlockOptions>): MovingBlockOptions {
    // Calculate random start and end X positions using LATERAL bounds
    const randomStartX = Math.random() * 
                        (MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SPAWN_BOUNDS.LATERAL.MAX - 
                         MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SPAWN_BOUNDS.LATERAL.MIN) + 
                         MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SPAWN_BOUNDS.LATERAL.MIN;

    const randomEndX = Math.random() * 
                      (MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SPAWN_BOUNDS.LATERAL.MAX - 
                       MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SPAWN_BOUNDS.LATERAL.MIN) + 
                       MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SPAWN_BOUNDS.LATERAL.MIN;

    // Calculate random distance within the new min/max range
    const distance = MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.MIN_TRAVEL_DISTANCE + 
                    Math.random() * (MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.MAX_TRAVEL_DISTANCE - 
                                   MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.MIN_TRAVEL_DISTANCE);

    // Use FORWARD bounds for Z coordinates
    const startZ = MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SPAWN_BOUNDS.FORWARD.MIN;
    const endZ = Math.min(
      startZ + distance,
      MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SPAWN_BOUNDS.FORWARD.MAX
    );

    return {
      blockTextureUri: this.DefaultParabolicTexture,
      blockHalfExtents: this.DefaultParabolicHalfExtents,
      health: MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.HEALTH,
      movementBehavior: new ParabolicMovement({
        startPoint: { x: randomStartX, y: MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.START_Y, z: startZ },
        endPoint: { x: randomEndX, y: MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.END_Y, z: endZ },
        maxHeight: MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.MAX_HEIGHT,
        duration: MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.DURATION
      }),
      ...customConfig
    };
  }

  // Add getters for scoring calculations
  public getSpawnTime(): number {
    return this.spawnTime;
  }

  // Use the base class's blockHalfExtents property
  public getBlockDimensions(): Vector3Like {
    return this.blockHalfExtents || MOVING_BLOCK_CONFIG.DEFAULT_HALF_EXTENTS;
  }

  public getMovementBehaviorType(): string {
    return this.movementBehavior.constructor.name;
  }

  override despawn(): void {
    // Clear despawn timer if it exists
    if (this.despawnTimer) {
      clearTimeout(this.despawnTimer);
      this.despawnTimer = null;
    }
    super.despawn();
  }
}

export class MovingBlockManager {
  private blocks: MovingBlockEntity[] = [];

  constructor(
    private world: World,
    private scoreManager?: ScoreManager
  ) {}

  public getBlockCount(): number {
    const MAX_BLOCK_AGE_MS = 300000; // 5 minutes
    const now = Date.now();
    
    // Filter out despawned blocks AND old blocks
    this.blocks = this.blocks.filter(block => {
        const isValid = block.isSpawned && 
                       (now - block.getSpawnTime()) < MAX_BLOCK_AGE_MS;
        
        // If not valid, make sure it's properly despawned
        if (!isValid && block.isSpawned) {
            block.despawn();
        }
        return isValid;
    });
    
    return this.blocks.length;
  }

  public createZAxisBlock(spawnPosition?: Vector3Like): MovingBlockEntity {
    // Clean up any despawned blocks first
    this.blocks = this.blocks.filter(block => block.isSpawned);

    // Get default half extents and reduce by 40%
    const defaultHalfExtents = MovingBlockEntity.DefaultBlockHalfExtents;
    const scaledHalfExtents = {
        x: defaultHalfExtents.x * 0.6,  // 40% smaller
        y: defaultHalfExtents.y * 0.6,  // 40% smaller
        z: defaultHalfExtents.z * 0.6   // 40% smaller
    };

    // Generate random direction with X component
    const randomAngle = Math.random() * Math.PI * 0.5 - Math.PI * 0.25; // -45 to 45 degrees
    const direction = {
        x: Math.sin(randomAngle) * 0.5,  // X component limited to 0.5 magnitude
        y: 0,                            // Y handled by movement behavior
        z: Math.cos(randomAngle)         // Z component
    };

    const block = new MovingBlockEntity(MovingBlockEntity.createDefaultBlockConfiguration({
        blockHalfExtents: scaledHalfExtents,
        direction: direction,
        onBlockBroken: () => {
            if (this.scoreManager && (block as any).playerId) {
                const playerId = (block as any).playerId;
                const score = MovingBlockEntity.DefaultBlockScore;
                
                this.scoreManager.addScore(playerId, score);
                this.scoreManager.broadcastScores(this.world);
                this.removeBlock(block);
            }
        }
    }));
    
    // Generate spawn position respecting platform safety
    const finalSpawnPosition = spawnPosition || this.generateSafeSpawnPosition();
    
    block.spawn(this.world, finalSpawnPosition);
    this.blocks.push(block);
    
    // Movement is now handled by the onTick method
    
    return block;
  }

  private generateSafeSpawnPosition(): Vector3Like {
    const bounds = MovingBlockEntity.DefaultMovementBounds;
    const safetyMargin = MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.PLATFORM_SAFETY_MARGIN;
    const rightPlatformX = MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.RIGHT_PLATFORM_EDGE.X;
    const leftPlatformX = MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.LEFT_PLATFORM_EDGE.X;
    
    let attempts = 0;
    let position: Vector3Like;
    
    do {
        position = {
            x: bounds.min.x + Math.random() * (bounds.max.x - bounds.min.x),
            y: bounds.min.y + Math.random() * (bounds.max.y - bounds.min.y),
            z: bounds.min.z + Math.random() * (bounds.max.z - bounds.min.z)
        };
        
        // Check if position is safe from platforms
        const isNearRightPlatform = Math.abs(position.x - rightPlatformX) < safetyMargin &&
            position.z >= MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.RIGHT_PLATFORM_EDGE.Z_MIN - safetyMargin &&
            position.z <= MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.RIGHT_PLATFORM_EDGE.Z_MAX + safetyMargin;
            
        const isNearLeftPlatform = Math.abs(position.x - leftPlatformX) < safetyMargin &&
            position.z >= MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.LEFT_PLATFORM_EDGE.Z_MIN - safetyMargin &&
            position.z <= MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.LEFT_PLATFORM_EDGE.Z_MAX + safetyMargin;
        
        if (!isNearRightPlatform && !isNearLeftPlatform) {
            break;
        }
        
        attempts++;
    } while (attempts < 10);
    
    // If we couldn't find a safe position, use a guaranteed safe default
    if (attempts >= 10) {
        position = { ...MovingBlockEntity.DefaultSpawnPosition };
    }
    
    return position;
  }

  public createSineWaveBlock(options: {
    spawnPosition?: Vector3Like;
    amplitude?: number;
    frequency?: number;
    baseAxis?: 'x' | 'y' | 'z';
    waveAxis?: 'x' | 'y' | 'z';
    moveSpeed?: number;
    blockTextureUri?: string;
  } = {}): MovingBlockEntity {
    // Clean up any despawned blocks first
    this.blocks = this.blocks.filter(block => block.isSpawned);

    const block = new MovingBlockEntity({
      moveSpeed: options.moveSpeed ?? MOVING_BLOCK_CONFIG.DEFAULT_SPEED * 0.8,
      blockTextureUri: options.blockTextureUri ?? 'blocks/diamond-ore.png',
      blockHalfExtents: { x: 1, y: 1, z: 1 },
      movementBehavior: new SineWaveMovement({
        amplitude: options.amplitude ?? 8,  // Increased from 4 to 8 for wider X movement
        frequency: options.frequency ?? 0.2,  // Reduced from 0.5 to 0.2 for slower oscillation
        baseAxis: options.baseAxis ?? 'z',
        waveAxis: options.waveAxis ?? 'x'
      }),
      // Wider movement bounds for sine wave pattern
      movementBounds: {
        min: { 
          x: -12,  // Increased from -5 to -12 for wider X range
          y: 1,
          z: MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.min.z
        },
        max: {
          x: 12,   // Increased from 5 to 12 for wider X range
          y: 1,
          z: MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.max.z
        }
      },
      onBlockBroken: () => {
        if (this.scoreManager && (block as any).playerId) {
          const playerId = (block as any).playerId;
          // Give more points for hitting this more challenging target
          const score = MOVING_BLOCK_CONFIG.BREAK_SCORE * 1.5;
          
          this.scoreManager.addScore(playerId, score);
          this.scoreManager.broadcastScores(this.world);
          this.removeBlock(block);
        }
      }
    });
    
    // Ensure we have a valid spawn position
    const spawnPosition = options.spawnPosition || { ...MOVING_BLOCK_CONFIG.SPAWN_POSITION, z: -5 };
    
    block.spawn(this.world, spawnPosition);
    this.blocks.push(block);
    
    return block;
  }

  public createStaticTarget(options: {
    x?: number;
    y?: number;
    z?: number;
    despawnTime?: number;
  } = {}): MovingBlockEntity {
    // Clean up any despawned blocks first
    this.blocks = this.blocks.filter(block => block.isSpawned);

    const spawnPosition = {
      x: options.x ?? (Math.random() * 16 - 8),
      y: options.y ?? (2 + Math.random() * 4),
      z: options.z ?? (Math.random() * 24 - 12)
    };

    // Create block with default target configuration
    const block = new MovingBlockEntity(MovingBlockEntity.createTargetConfiguration({
      despawnTime: options.despawnTime,
      onBlockBroken: () => {
        if (this.scoreManager && (block as any).playerId) {
          const playerId = (block as any).playerId;
          const score = MovingBlockEntity.DefaultTargetScore;
          
          this.scoreManager.addScore(playerId, score);
          this.scoreManager.broadcastScores(this.world);
          this.removeBlock(block);
        }
      }
    }));
    
    block.spawn(this.world, spawnPosition);
    this.blocks.push(block);

    return block;
  }

  public createVerticalWaveBlock(options: {
    spawnPosition?: Vector3Like;
    amplitude?: number;
    frequency?: number;
    moveSpeed?: number;
    blockTextureUri?: string;
  } = {}): MovingBlockEntity {
    // Clean up any despawned blocks first
    this.blocks = this.blocks.filter(block => block.isSpawned);

    const amplitude = options.amplitude ?? MOVING_BLOCK_CONFIG.VERTICAL_WAVE.DEFAULT_AMPLITUDE;
    const heightOffset = MOVING_BLOCK_CONFIG.VERTICAL_WAVE.HEIGHT_OFFSET;
    const safetyMargin = MOVING_BLOCK_CONFIG.VERTICAL_WAVE.SAFETY_MARGIN;

    // Set a fixed Y value for spawning so that the Y movement is not restricted in the bounds.
    const fixedY = heightOffset + safetyMargin;

    const block = new MovingBlockEntity({
      moveSpeed: options.moveSpeed ?? MOVING_BLOCK_CONFIG.DEFAULT_SPEED * MOVING_BLOCK_CONFIG.VERTICAL_WAVE.SPEED_MULTIPLIER,
      blockTextureUri: options.blockTextureUri ?? MOVING_BLOCK_CONFIG.VERTICAL_WAVE.TEXTURE,
      blockHalfExtents: MOVING_BLOCK_CONFIG.VERTICAL_WAVE.HALF_EXTENTS,
      health: MOVING_BLOCK_CONFIG.VERTICAL_WAVE.HEALTH,  // Set health to 1
      movementBehavior: new SineWaveMovement({
        amplitude: amplitude,
        frequency: options.frequency ?? MOVING_BLOCK_CONFIG.VERTICAL_WAVE.DEFAULT_FREQUENCY,
        baseAxis: 'z',  // Move forward along Z axis
        waveAxis: 'y'   // Oscillate on Y axis
      }),
      // Modified movement bounds: we fix Y to let the sine function determine vertical movement.
      movementBounds: {
        min: { 
          x: -5,
          y: fixedY,
          z: MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.min.z
        },
        max: {
          x: 5,
          y: fixedY,
          z: MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.max.z
        }
      },
      onBlockBroken: () => {
        if (this.scoreManager && (block as any).playerId) {
          const playerId = (block as any).playerId;
          const score = MOVING_BLOCK_CONFIG.BREAK_SCORE * MOVING_BLOCK_CONFIG.VERTICAL_WAVE.SCORE_MULTIPLIER;
          
          this.scoreManager.addScore(playerId, score);
          this.scoreManager.broadcastScores(this.world);
          this.removeBlock(block);
        }
      }
    });
    
    // Calculate spawn position with appropriate height offset and safety margin
    const spawnPosition = options.spawnPosition || {
      ...MOVING_BLOCK_CONFIG.SPAWN_POSITION,
      y: fixedY,  // Use the fixed Y value for spawn
      z: -5
    };
    
    block.spawn(this.world, spawnPosition);
    this.blocks.push(block);
    
    return block;
  }

  public createPopUpTarget(options: {
    spawnPosition?: Vector3Like;
    startY?: number;
    topY?: number;
    moveSpeed?: number;
    blockTextureUri?: string;
  } = {}): MovingBlockEntity {
    // Clean up any despawned blocks first
    this.blocks = this.blocks.filter(block => block.isSpawned);

    const config = MovingBlockEntity.createPopUpConfiguration({
      moveSpeed: options.moveSpeed,
      blockTextureUri: options.blockTextureUri,
      movementBehavior: new PopUpMovement({
        startY: options.startY ?? MovingBlockEntity.DefaultPopUpStartY,
        topY: options.topY ?? MovingBlockEntity.DefaultPopUpTopY
      })
    });

    const block = new MovingBlockEntity({
      ...config,
      onBlockBroken: () => {
        if (this.scoreManager && (block as any).playerId) {
          const playerId = (block as any).playerId;
          const score = MOVING_BLOCK_CONFIG.BREAK_SCORE * MovingBlockEntity.DefaultPopUpScoreMultiplier;
          
          this.scoreManager.addScore(playerId, score);
          this.scoreManager.broadcastScores(this.world);
          this.removeBlock(block);
        }
      }
    });
    
    // Calculate spawn position
    const spawnPosition = options.spawnPosition || MovingBlockEntity.generatePopUpSpawnPosition();
    
    if (!MovingBlockEntity.isValidPopUpPosition(spawnPosition)) {
      block.spawn(this.world, MovingBlockEntity.generatePopUpSpawnPosition());
    } else {
      block.spawn(this.world, spawnPosition);
    }
    
    this.blocks.push(block);
    return block;
  }

  public createRisingTarget(options: {
    spawnPosition?: Vector3Like;
    startY?: number;
    firstStopY?: number;
    finalY?: number;
    moveSpeed?: number;
    blockTextureUri?: string;
    pauseDuration?: number;
  } = {}): MovingBlockEntity {
    // Clean up any despawned blocks first
    this.blocks = this.blocks.filter(block => block.isSpawned);

    const config = MovingBlockEntity.createRisingConfiguration({
      moveSpeed: options.moveSpeed,
      blockTextureUri: options.blockTextureUri,
      movementBehavior: new RisingMovement({
        startY: options.startY ?? MovingBlockEntity.DefaultRisingStartY,
        firstStopY: options.firstStopY ?? MovingBlockEntity.DefaultRisingFirstStopY,
        finalY: options.finalY ?? MovingBlockEntity.DefaultRisingFinalY,
        pauseDuration: options.pauseDuration ?? MovingBlockEntity.DefaultRisingPauseDuration
      })
    });

    const block = new MovingBlockEntity({
      ...config,
      onBlockBroken: () => {
        if (this.scoreManager && (block as any).playerId) {
          const playerId = (block as any).playerId;
          const score = MOVING_BLOCK_CONFIG.BREAK_SCORE * MovingBlockEntity.DefaultRisingScoreMultiplier;
          
          this.scoreManager.addScore(playerId, score);
          this.scoreManager.broadcastScores(this.world);
          this.removeBlock(block);
        }
      }
    });
    
    // Calculate spawn position
    const spawnPosition = options.spawnPosition || MovingBlockEntity.generateRisingSpawnPosition();
    
    if (!MovingBlockEntity.isValidRisingPosition(spawnPosition)) {
      block.spawn(this.world, MovingBlockEntity.generateRisingSpawnPosition());
    } else {
      block.spawn(this.world, spawnPosition);
    }
    
    this.blocks.push(block);
    return block;
  }

  public createParabolicTarget(options: {
    startPoint?: Vector3Like;
    endPoint?: Vector3Like;
    maxHeight?: number;
    duration?: number;
    moveSpeed?: number;
    blockTextureUri?: string;
  } = {}): MovingBlockEntity {
    // Clean up any despawned blocks first
    this.blocks = this.blocks.filter(block => block.isSpawned);

    const config = MovingBlockEntity.createParabolicConfiguration({
      moveSpeed: options.moveSpeed,
      blockTextureUri: options.blockTextureUri,
      movementBehavior: new ParabolicMovement({
        startPoint: options.startPoint,
        endPoint: options.endPoint,
        maxHeight: options.maxHeight,
        duration: options.duration
      })
    });

    const block = new MovingBlockEntity({
      ...config,
      onBlockBroken: () => {
        if (this.scoreManager && (block as any).playerId) {
          const playerId = (block as any).playerId;
          const score = MOVING_BLOCK_CONFIG.BREAK_SCORE * MovingBlockEntity.DefaultParabolicScoreMultiplier;
          
          this.scoreManager.addScore(playerId, score);
          this.scoreManager.broadcastScores(this.world);
          this.removeBlock(block);
        }
      }
    });
    
    // Use the start point from the movement behavior
    const startPosition = (config.movementBehavior as ParabolicMovement)['startPoint'];
    block.spawn(this.world, startPosition);
    this.blocks.push(block);
    
    return block;
  }

  public createPendulumTarget(options: {
    pivotPoint?: Vector3Like;
    length?: number;
    amplitude?: number;
    frequency?: number;
    moveSpeed?: number;
    blockTextureUri?: string;
  } = {}): MovingBlockEntity {
    // Clean up any despawned blocks first
    this.blocks = this.blocks.filter(block => block.isSpawned);

    const config = MovingBlockEntity.createPendulumConfiguration({
      moveSpeed: options.moveSpeed,
      blockTextureUri: options.blockTextureUri,
      movementBehavior: new PendulumMovement({
        pivotPoint: options.pivotPoint,
        length: options.length,
        amplitude: options.amplitude,
        frequency: options.frequency
      })
    });

    const block = new MovingBlockEntity({
      ...config,
      onBlockBroken: () => {
        if (this.scoreManager && (block as any).playerId) {
          const playerId = (block as any).playerId;
          // Let ScoreManager handle the scoring calculation
          const score = MOVING_BLOCK_CONFIG.BREAK_SCORE;
          
          this.scoreManager.addScore(playerId, score);
          this.scoreManager.broadcastScores(this.world);
          this.removeBlock(block);
        }
      }
    });
    
    // Calculate spawn position based on pivot point and length
    const spawnPosition = {
      x: options.pivotPoint?.x ?? 0,
      y: (options.pivotPoint?.y ?? MovingBlockEntity.DefaultPendulumPivotHeight) - 
         (options.length ?? MovingBlockEntity.DefaultPendulumLength),
      z: (options.pivotPoint?.z ?? 0) + (options.length ?? MovingBlockEntity.DefaultPendulumLength)
    };
    
    block.spawn(this.world, spawnPosition);
    this.blocks.push(block);
    
    return block;
  }

  public removeBlock(block: MovingBlockEntity): void {
    const index = this.blocks.indexOf(block);
    if (index !== -1) {
      this.blocks.splice(index, 1);
    }
  }
}

================
File: src/raycast/raycast-handler.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RaycastHandler = void 0;
var RaycastHandler = /** @class */ (function () {
    function RaycastHandler(world) {
        this.world = world;
        this.log('RaycastHandler initialized');
    }
    RaycastHandler.prototype.log = function (message) {
        if (this.isDebugRaycastingEnabled()) {
            console.log(message);
        }
    };
    RaycastHandler.prototype.warn = function (message) {
        console.warn(message);
    };
    RaycastHandler.prototype.raycast = function (origin, direction, length, options) {
        // Validate inputs
        if (!origin || !direction || length <= 0) {
            this.warn('Invalid raycast parameters');
            return null;
        }
        // Check for zero vector
        var magnitude = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);
        if (magnitude === 0) {
            this.warn('Invalid raycast parameters: zero direction vector');
            return null;
        }
        this.log("Raycast: From (".concat(origin.x.toFixed(2), ", ").concat(origin.y.toFixed(2), ", ").concat(origin.z.toFixed(2), ") ") +
            "Dir (".concat(direction.x.toFixed(2), ", ").concat(direction.y.toFixed(2), ", ").concat(direction.z.toFixed(2), ") ") +
            "Length ".concat(length));
        var result = this.world.simulation.raycast(origin, direction, length, options);
        if (!result) {
            this.log('No hit detected');
            return null;
        }
        this.log("Hit detected at distance: ".concat(result.hitDistance.toFixed(2), " ") +
            "Point: (".concat(result.hitPoint.x.toFixed(2), ", ").concat(result.hitPoint.y.toFixed(2), ", ").concat(result.hitPoint.z.toFixed(2), ")"));
        if (result.hitBlock) {
            var coord = result.hitBlock.globalCoordinate;
            this.log("Block hit at: (".concat(coord.x, ", ").concat(coord.y, ", ").concat(coord.z, ")"));
        }
        return result;
    };
    RaycastHandler.prototype.enableDebugRaycasting = function (enabled) {
        console.log("".concat(enabled ? 'Enabling' : 'Disabling', " debug raycasting"));
        this.world.simulation.enableDebugRaycasting(enabled);
    };
    RaycastHandler.prototype.isDebugRaycastingEnabled = function () {
        return this.world.simulation.isDebugRaycastingEnabled;
    };
    return RaycastHandler;
}());
exports.RaycastHandler = RaycastHandler;

================
File: src/raycast/raycast-handler.ts
================
import { Vector3, RaycastHit } from '../types';
import { RaycastOptions, Simulation } from 'hytopia';

export interface WorldInterface {
    simulation: {
        raycast(origin: Vector3, direction: Vector3, length: number, options?: RaycastOptions): RaycastHit | null;
        enableDebugRaycasting(enabled: boolean): void;
        readonly isDebugRaycastingEnabled: boolean;
    };
}

export class RaycastHandler {
    constructor(private world: WorldInterface) {
        this.log('RaycastHandler initialized');
    }

    private log(message: string): void {
        if (this.isDebugRaycastingEnabled()) {
            console.log(message);
        }
    }

    private warn(message: string): void {
        console.warn(message);
    }

    raycast(origin: Vector3, direction: Vector3, length: number, options?: RaycastOptions): RaycastHit | null {
        // Validate inputs
        if (!origin || !direction || length <= 0) {
            this.warn('Invalid raycast parameters');
            return null;
        }

        // Check for zero vector
        const magnitude = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);
        if (magnitude === 0) {
            this.warn('Invalid raycast parameters: zero direction vector');
            return null;
        }

        this.log(`Raycast: From (${origin.x.toFixed(2)}, ${origin.y.toFixed(2)}, ${origin.z.toFixed(2)}) ` +
               `Dir (${direction.x.toFixed(2)}, ${direction.y.toFixed(2)}, ${direction.z.toFixed(2)}) ` +
               `Length ${length}`);
        
        const result = this.world.simulation.raycast(origin, direction, length, options);
        
        if (!result) {
            this.log('No hit detected');
            return null;
        }

        this.log(`Hit detected at distance: ${result.hitDistance.toFixed(2)} ` +
               `Point: (${result.hitPoint.x.toFixed(2)}, ${result.hitPoint.y.toFixed(2)}, ${result.hitPoint.z.toFixed(2)})`);
        
        if (result.hitBlock) {
            const coord = result.hitBlock.globalCoordinate;
            this.log(`Block hit at: (${coord.x}, ${coord.y}, ${coord.z})`);
        }

        return result;
    }

    enableDebugRaycasting(enabled: boolean): void {
        console.log(`${enabled ? 'Enabling' : 'Disabling'} debug raycasting`);
        this.world.simulation.enableDebugRaycasting(enabled);
    }

    isDebugRaycastingEnabled(): boolean {
        return this.world.simulation.isDebugRaycastingEnabled;
    }
}

================
File: src/raycast/README.md
================
# Raycast Handler

## Current Features

### Core Functionality
- Manages raycast operations in the game world
- Validates raycast parameters
- Provides detailed debug logging
- Handles collision detection through raycasts

### Debug Features
- Toggleable debug mode
- Detailed logging of raycast operations
- Visual debugging in-game
- Parameter validation warnings

### Input Validation
- Direction vector validation
- Origin point checking
- Length validation
- Zero vector detection

### Output Handling
- Structured hit detection results
- Block collision information
- Hit point coordinates
- Distance calculations

## Potential Future Enhancements

### Advanced Raycasting
1. **Multi-Ray System**
   ```typescript
   interface MultiRayConfig {
     rays: number;
     spread: number;
     pattern: 'circle' | 'grid' | 'cone';
   }
   ```
   - Spread patterns
   - Multiple simultaneous rays
   - Configurable patterns
   - Hit aggregation

2. **Layer System**
   ```typescript
   interface RaycastLayers {
     blocks: boolean;
     entities: boolean;
     triggers: boolean;
     custom: string[];
   }
   ```
   - Selective collision layers
   - Custom layer definitions
   - Layer priorities
   - Layer masks

### Performance Features
1. **Optimization Options**
   ```typescript
   interface RaycastOptimization {
     maxChecks: number;
     stepSize: number;
     earlyExit: boolean;
     cacheDuration: number;
   }
   ```
   - Result caching
   - Early exit conditions
   - Step size optimization
   - Maximum check limits

2. **Batch Processing**
   - Multiple ray batching
   - Parallel processing
   - Result pooling
   - Optimized memory usage

### Debug Enhancements
1. **Visualization Tools**
   ```typescript
   interface DebugVisualization {
     color: string;
     duration: number;
     thickness: number;
     showHitPoints: boolean;
   }
   ```
   - Customizable ray visualization
   - Hit point markers
   - Trajectory paths
   - Debug statistics

2. **Logging System**
   - Performance metrics
   - Hit statistics
   - Error tracking
   - Debug categories

### Special Features
1. **Ray Types**
   - Curved rays
   - Penetrating rays
   - Reflecting rays
   - Area scan rays

2. **Hit Detection**
   ```typescript
   interface EnhancedHitInfo {
     material: string;
     normal: Vector3;
     reflection: Vector3;
     penetration: number;
   }
   ```
   - Surface normal calculation
   - Material detection
   - Reflection angles
   - Penetration depth

## Integration Points
- Works with collision systems
- Supports projectile trajectory prediction
- Integrates with debug systems
- Can be used for AI line of sight

## Best Practices for Extensions

### 1. Performance Guidelines
- Cache results when appropriate
- Use efficient vector math
- Implement early exit conditions
- Optimize check frequency

### 2. Debug Considerations
- Maintain clear logging levels
- Provide visual feedback
- Include performance metrics
- Document edge cases

### 3. Implementation Tips
- Keep vector math clean
- Handle edge cases gracefully
- Validate all inputs
- Use type-safe interfaces

### 4. Usage Guidelines
- Don't overuse raycasts
- Batch similar checks
- Consider performance impact
- Use appropriate ray lengths

## Common Use Cases
1. **Line of Sight**
   - Enemy detection
   - Cover system
   - Visibility checks
   - Obstacle detection

2. **Interaction**
   - Object selection
   - Interactive elements
   - Distance checking
   - Collision prediction

3. **Combat**
   - Weapon aiming
   - Hit detection
   - Bullet penetration
   - Cover system

4. **Environment**
   - Terrain detection
   - Path finding
   - Surface normal calculation
   - Environment scanning

================
File: src/scene-ui/scene-ui-manager.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SceneUIManager = void 0;
var SceneUIManager = /** @class */ (function () {
    function SceneUIManager(world) {
        this.world = world;
    }
    SceneUIManager.getInstance = function (world) {
        if (!SceneUIManager.instance) {
            SceneUIManager.instance = new SceneUIManager(world);
        }
        return SceneUIManager.instance;
    };
    SceneUIManager.prototype.showHitNotification = function (worldPosition, score, player) {
        console.log('Showing hit notification with score:', score);
        player.ui.sendData({
            type: 'showHitNotification',
            data: {
                score: Math.round(score),
                position: worldPosition
            }
        });
    };
    SceneUIManager.prototype.showBlockDestroyedNotification = function (worldPosition, score, player, spawnOrigin) {
        console.log('Showing block destroyed notification with score:', score);
        // Ensure score is rounded and positive
        var roundedScore = Math.max(0, Math.round(score));
        // Calculate distance multiplier if spawn origin is available
        var distanceMultiplier = 1;
        if (worldPosition && spawnOrigin) {
            var dx = worldPosition.x - spawnOrigin.x;
            var dy = worldPosition.y - spawnOrigin.y;
            var dz = worldPosition.z - spawnOrigin.z;
            var distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            distanceMultiplier = 1 + Math.min(Math.pow(distance / 30, 1.1), 0.1);
        }
        // Calculate animation duration
        var duration = 500 + Math.min(roundedScore <= 30
            ? Math.pow(roundedScore, 1.2) * 3
            : Math.pow(roundedScore, 1.8) * 4
                * distanceMultiplier, 1200);
        // Calculate scale
        var scale = 1 + Math.min(roundedScore <= 30
            ? Math.pow(roundedScore / 80, 2.4)
            : Math.pow(roundedScore / 70, 2.4)
                * distanceMultiplier, 0.8);
        var verticalOffset = 1.5 + Math.min(Math.pow(roundedScore / 30, 1.4), 1.5);
        // Calculate color based on score
        var colorInfo = this.getScoreColor(roundedScore);
        // Create animation style
        var dynamicStyle = this.createDynamicStyle(roundedScore, scale, duration, colorInfo);
        // Send notification data to player's UI
        player.ui.sendData({
            type: 'showBlockDestroyedNotification',
            data: {
                score: roundedScore,
                position: worldPosition,
                style: dynamicStyle,
                verticalOffset: verticalOffset,
                duration: duration
            }
        });
    };
    SceneUIManager.prototype.showComboNotification = function (consecutiveHits, comboBonus, player) {
        console.log('Showing combo notification:', { hits: consecutiveHits, bonus: comboBonus });
        player.ui.sendData({
            type: 'showCombo',
            data: {
                hits: consecutiveHits,
                bonus: comboBonus,
                text: this.getComboText(consecutiveHits)
            }
        });
    };
    SceneUIManager.prototype.getComboText = function (hits) {
        if (hits >= 10)
            return 'UNSTOPPABLE!';
        if (hits >= 7)
            return 'DOMINATING!';
        if (hits >= 5)
            return 'IMPRESSIVE!';
        if (hits >= 3)
            return 'NICE COMBO!';
        return '';
    };
    SceneUIManager.prototype.getScoreColor = function (score) {
        var colors = [
            { score: 0, color: '#FFFFFF', glow: '#CCCCCC', intensity: 0.3 },
            { score: 15, color: '#FFFF00', glow: '#CCCC00', intensity: 0.6 },
            { score: 25, color: '#FFA500', glow: '#CC8400', intensity: 0.9 },
            { score: 50, color: '#FF0000', glow: '#CC0000', intensity: 1.2 },
            { score: 150, color: '#FF00FF', glow: '#FFFFFF', intensity: 1.5 }
        ];
        var lower = colors[0];
        var upper = colors[colors.length - 1];
        for (var i = 0; i < colors.length - 1; i++) {
            if (score >= colors[i].score && score < colors[i + 1].score) {
                lower = colors[i];
                upper = colors[i + 1];
                break;
            }
        }
        var range = upper.score - lower.score;
        var factor = range <= 0 ? 1 : (score - lower.score) / range;
        var intensity = lower.intensity + (upper.intensity - lower.intensity) * factor;
        return {
            main: this.interpolateHex(lower.color, upper.color, factor),
            glow: this.interpolateHex(lower.glow, upper.glow, factor),
            intensity: intensity
        };
    };
    SceneUIManager.prototype.interpolateHex = function (hex1, hex2, factor) {
        var r1 = parseInt(hex1.slice(1, 3), 16);
        var g1 = parseInt(hex1.slice(3, 5), 16);
        var b1 = parseInt(hex1.slice(5, 7), 16);
        var r2 = parseInt(hex2.slice(1, 3), 16);
        var g2 = parseInt(hex2.slice(3, 5), 16);
        var b2 = parseInt(hex2.slice(5, 7), 16);
        var r = Math.round(r1 + (r2 - r1) * factor);
        var g = Math.round(g1 + (g2 - g1) * factor);
        var b = Math.round(b1 + (b2 - b1) * factor);
        return "#".concat((r << 16 | g << 8 | b).toString(16).padStart(6, '0'));
    };
    SceneUIManager.prototype.createDynamicStyle = function (score, scale, duration, colorInfo) {
        return "\n      @keyframes scoreAnimation {\n        0% {\n          opacity: 0;\n          transform: translateY(0) scale(0.2);\n        }\n        15% {\n          opacity: 1;\n          transform: translateY(-".concat(8 * scale, "px) scale(").concat(scale * 0.9, ");\n        }\n        30% {\n          opacity: 1;\n          transform: translateY(-").concat(20 * scale, "px) scale(").concat(scale, ");\n        }\n        60% {\n          opacity: 1;\n          transform: translateY(-").concat(35 * scale, "px) scale(").concat(scale, ");\n        }\n        85% {\n          opacity: 0.5;\n          transform: translateY(-").concat(45 * scale, "px) scale(").concat(scale * 0.9, ");\n        }\n        100% {\n          opacity: 0;\n          transform: translateY(-").concat(50 * scale, "px) scale(").concat(scale * 0.8, ");\n        }\n      }\n      animation: scoreAnimation ").concat(duration, "ms ease-out forwards;\n      will-change: transform, opacity;\n      transform: translateZ(0);\n      font-size: ").concat(scale * 48, "px;\n      color: ").concat(colorInfo.main, ";\n      text-shadow: 0 0 ").concat(5 + colorInfo.intensity * 15, "px ").concat(colorInfo.glow, ";\n      --score-value: ").concat(score, ";\n      --intensity: ").concat(colorInfo.intensity, ";\n    ");
    };
    SceneUIManager.prototype.cleanup = function () {
        // No cleanup needed anymore as we're not storing any SceneUI instances
    };
    return SceneUIManager;
}());
exports.SceneUIManager = SceneUIManager;

================
File: src/scene-ui/scene-ui-manager.ts
================
import { World, Vector3Like, Player } from 'hytopia';

export class SceneUIManager {
  private static instance: SceneUIManager;
  private world: World;

  private constructor(world: World) {
    this.world = world;
  }

  public static getInstance(world: World): SceneUIManager {
    if (!SceneUIManager.instance) {
      SceneUIManager.instance = new SceneUIManager(world);
    }
    return SceneUIManager.instance;
  }

  public showHitNotification(worldPosition: Vector3Like, score: number, player: Player): void {
    console.log('Showing hit notification with score:', score);
    
    player.ui.sendData({
      type: 'showHitNotification',
      data: {
        score: Math.round(score),
        position: worldPosition
      }
    });
  }

  public showBlockDestroyedNotification(worldPosition: Vector3Like, score: number, player: Player, spawnOrigin?: Vector3Like): void {
    console.log('Showing block destroyed notification with score:', score);
    
    // Ensure score is rounded and positive
    const roundedScore = Math.max(0, Math.round(score));
    
    // Calculate distance multiplier if spawn origin is available
    let distanceMultiplier = 1;
    if (worldPosition && spawnOrigin) {
      const dx = worldPosition.x - spawnOrigin.x;
      const dy = worldPosition.y - spawnOrigin.y;
      const dz = worldPosition.z - spawnOrigin.z;
      const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
      
      distanceMultiplier = 1 + Math.min(Math.pow(distance / 30, 1.1), 0.1);
    }
    
    // Calculate animation duration
    const duration = 500 + Math.min(
      roundedScore <= 30 
        ? Math.pow(roundedScore, 1.2) * 3 
        : Math.pow(roundedScore, 1.8) * 4
      * distanceMultiplier, 1200);
    
    // Calculate scale
    const scale = 1 + Math.min(
      roundedScore <= 30
        ? Math.pow(roundedScore / 80, 2.4)
        : Math.pow(roundedScore / 70, 2.4)
      * distanceMultiplier, 0.8);
    
    const verticalOffset = 1.5 + Math.min(Math.pow(roundedScore / 30, 1.4), 1.5);

    // Calculate color based on score
    const colorInfo = this.getScoreColor(roundedScore);
    
    // Create animation style
    const dynamicStyle = this.createDynamicStyle(roundedScore, scale, duration, colorInfo);

    // Send notification data to player's UI
    player.ui.sendData({
      type: 'showBlockDestroyedNotification',
      data: {
        score: roundedScore,
        position: worldPosition,
        style: dynamicStyle,
        verticalOffset,
        duration
      }
    });
  }

  public showComboNotification(consecutiveHits: number, comboBonus: number, player: Player): void {
    console.log('Showing combo notification:', { hits: consecutiveHits, bonus: comboBonus });
    
    player.ui.sendData({
      type: 'showCombo',
      data: {
        hits: consecutiveHits,
        bonus: comboBonus,
        text: this.getComboText(consecutiveHits)
      }
    });
  }

  private getComboText(hits: number): string {
    if (hits >= 10) return 'UNSTOPPABLE!';
    if (hits >= 7) return 'DOMINATING!';
    if (hits >= 5) return 'IMPRESSIVE!';
    if (hits >= 3) return 'NICE COMBO!';
    return '';
  }

  private getScoreColor(score: number): { main: string, glow: string, intensity: number } {
    const colors = [
      { score: 0, color: '#FFFFFF', glow: '#CCCCCC', intensity: 0.3 },
      { score: 15, color: '#FFFF00', glow: '#CCCC00', intensity: 0.6 },
      { score: 25, color: '#FFA500', glow: '#CC8400', intensity: 0.9 },
      { score: 50, color: '#FF0000', glow: '#CC0000', intensity: 1.2 },
      { score: 150, color: '#FF00FF', glow: '#FFFFFF', intensity: 1.5 }
    ];

    let lower = colors[0];
    let upper = colors[colors.length - 1];
    
    for (let i = 0; i < colors.length - 1; i++) {
      if (score >= colors[i].score && score < colors[i + 1].score) {
        lower = colors[i];
        upper = colors[i + 1];
        break;
      }
    }

    const range = upper.score - lower.score;
    const factor = range <= 0 ? 1 : (score - lower.score) / range;
    const intensity = lower.intensity + (upper.intensity - lower.intensity) * factor;

    return {
      main: this.interpolateHex(lower.color, upper.color, factor),
      glow: this.interpolateHex(lower.glow, upper.glow, factor),
      intensity
    };
  }

  private interpolateHex(hex1: string, hex2: string, factor: number): string {
    const r1 = parseInt(hex1.slice(1, 3), 16);
    const g1 = parseInt(hex1.slice(3, 5), 16);
    const b1 = parseInt(hex1.slice(5, 7), 16);
    const r2 = parseInt(hex2.slice(1, 3), 16);
    const g2 = parseInt(hex2.slice(3, 5), 16);
    const b2 = parseInt(hex2.slice(5, 7), 16);

    const r = Math.round(r1 + (r2 - r1) * factor);
    const g = Math.round(g1 + (g2 - g1) * factor);
    const b = Math.round(b1 + (b2 - b1) * factor);

    return `#${(r << 16 | g << 8 | b).toString(16).padStart(6, '0')}`;
  }

  private createDynamicStyle(score: number, scale: number, duration: number, colorInfo: { main: string, glow: string, intensity: number }): string {
    return `
      @keyframes scoreAnimation {
        0% {
          opacity: 0;
          transform: translateY(0) scale(0.2);
        }
        15% {
          opacity: 1;
          transform: translateY(-${8 * scale}px) scale(${scale * 0.9});
        }
        30% {
          opacity: 1;
          transform: translateY(-${20 * scale}px) scale(${scale});
        }
        60% {
          opacity: 1;
          transform: translateY(-${35 * scale}px) scale(${scale});
        }
        85% {
          opacity: 0.5;
          transform: translateY(-${45 * scale}px) scale(${scale * 0.9});
        }
        100% {
          opacity: 0;
          transform: translateY(-${50 * scale}px) scale(${scale * 0.8});
        }
      }
      animation: scoreAnimation ${duration}ms ease-out forwards;
      will-change: transform, opacity;
      transform: translateZ(0);
      font-size: ${scale * 48}px;
      color: ${colorInfo.main};
      text-shadow: 0 0 ${5 + colorInfo.intensity * 15}px ${colorInfo.glow};
      --score-value: ${score};
      --intensity: ${colorInfo.intensity};
    `;
  }

  public cleanup(): void {
    // No cleanup needed anymore as we're not storing any SceneUI instances
  }
}

================
File: src/test-round-transitions.js
================
// Simple manual test script for round transitions
// This isn't a proper test but allows us to manually verify the changes

console.log('=== ROUND TRANSITION TEST ===');

// Mock the core classes and functions
class World {
  constructor() {
    this.entityManager = {
      getAllPlayerEntities: () => [
        { player: { id: 'player1', ui: { sendData: (data) => console.log('UI update for player1:', JSON.stringify(data).substring(0, 100) + '...') } } },
        { player: { id: 'player2', ui: { sendData: (data) => console.log('UI update for player2:', JSON.stringify(data).substring(0, 100) + '...') } } }
      ],
      getAllEntities: () => []
    };
  }
}

class MockBlockManager {
  getBlockCount() {
    return 0;
  }
  createStaticTarget() {}
  createZAxisBlock() {}
  createSineWaveBlock() {}
  createVerticalWaveBlock() {}
}

class ScoreManager {
  startNewRound() {}
  handleRoundEnd() {
    return { winnerId: 'player1', placements: [{ playerId: 'player1', points: 100 }] };
  }
  broadcastScores() {}
}

// Import the actual RoundManager - note: this would fail in a real environment
// with TypeScript/ES modules, but this is just a demonstration
console.log('Note: This is a simplified test that mocks the RoundManager');

// Create a mock RoundManager for testing instead
class RoundManager {
  constructor(world, blockManager, scoreManager, transitionDuration = 2000) {
    this.world = world;
    this.blockManager = blockManager;
    this.scoreManager = scoreManager;
    this.TRANSITION_DURATION = transitionDuration || 1000;
    this.currentRound = 0;
    this.isRoundActive = false;
    this.roundTransitionPending = false;
    this.roundTimer = null;
  }

  getRoundConfig() {
    return {
      duration: 1000,
      minBlockCount: 1,
      maxBlockCount: 2,
      blockSpawnInterval: 500,
      speedMultiplier: 0.5,
      blockTypes: {
        normal: 0,
        sineWave: 0,
        static: 1.0,
        verticalWave: 0,
        popup: 0,
        rising: 0,
        parabolic: 0,
        pendulum: 0
      }
    };
  }

  startRound() {
    console.log('startRound called');
    if (this.roundTransitionPending) {
      console.log('Round transition pending, not starting new round');
      return;
    }

    console.log('Starting countdown...');
    setTimeout(() => {
      this.actuallyStartRound();
    }, 100); // Simplified countdown
  }

  actuallyStartRound() {
    console.log('actuallyStartRound called');
    if (this.isRoundActive) {
      console.log('Attempted to start round while another is active');
      return;
    }

    this.currentRound++;
    this.isRoundActive = true;
    
    console.log(`Starting round ${this.currentRound}`);
    
    // Set round timer
    if (this.roundTimer) {
      clearTimeout(this.roundTimer);
    }
    
    this.roundTimer = setTimeout(() => {
      console.log('Round timer completed');
      this.endRound();
    }, this.getRoundConfig().duration);
  }

  endRound() {
    console.log(`Ending round: ${this.currentRound}`);
    
    if (!this.isRoundActive) return;

    // Clear timers
    if (this.roundTimer) {
      clearTimeout(this.roundTimer);
      this.roundTimer = null;
    }

    this.isRoundActive = false;

    console.log('Round ended, starting transition');
    
    // Prevent multiple transitions
    if (this.roundTransitionPending) {
      console.log('Round transition already pending, skipping');
      return;
    }

    // Set transition flag
    this.roundTransitionPending = true;
    
    // Schedule next round after transition
    this.roundTimer = setTimeout(() => {
      console.log('Round transition complete');
      this.roundTransitionPending = false;
      this.startRound();
    }, this.TRANSITION_DURATION);
  }

  isActive() {
    return this.isRoundActive;
  }

  getCurrentRound() {
    return this.currentRound;
  }

  cleanup() {
    if (this.roundTimer) {
      clearTimeout(this.roundTimer);
      this.roundTimer = null;
    }
  }
}

// Test function
async function testRoundTransitions() {
  // Create instances with short durations for testing
  const world = new World();
  const blockManager = new MockBlockManager();
  const scoreManager = new ScoreManager();
  const roundManager = new RoundManager(world, blockManager, scoreManager, 500); // 500ms transition

  console.log('Starting first round...');
  roundManager.startRound();
  
  // Wait for first round to complete
  await new Promise(resolve => setTimeout(resolve, 1500));
  console.log('First round should have ended, checking transition...');
  
  // Should be in transition now
  console.log('In transition: ', roundManager.roundTransitionPending);
  console.log('Round active: ', roundManager.isActive());
  console.log('Current round: ', roundManager.getCurrentRound());
  
  // Try to start another round during transition (should be blocked)
  console.log('Attempting to start another round during transition...');
  roundManager.startRound();
  
  // Wait for transition and start of next round
  await new Promise(resolve => setTimeout(resolve, 1000));
  console.log('Second round should have started...');
  console.log('In transition: ', roundManager.roundTransitionPending);
  console.log('Round active: ', roundManager.isActive());
  console.log('Current round: ', roundManager.getCurrentRound());
  
  // End the second round and try rapid multiple endRound calls
  console.log('Testing multiple endRound calls...');
  roundManager.endRound();
  console.log('Calling endRound again immediately (should be ignored)');
  roundManager.endRound();
  
  // Cleanup
  roundManager.cleanup();
  console.log('Test complete');
}

// Run the test
testRoundTransitions().catch(console.error);

================
File: src/types.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

================
File: src/types.ts
================
import { Vector3Like, RaycastHit as SDKRaycastHit } from 'hytopia';

export type Vector3 = Vector3Like;

export type RaycastHit = SDKRaycastHit;

================
File: src/utils/test-spawner.ts
================
import { World, Vector3Like } from 'hytopia';
import { MovingBlockManager, MOVING_BLOCK_CONFIG } from '../moving_blocks/moving-block-entity';

export class TestBlockSpawner {
    private readonly DEBUG_ENABLED = false;
    private testRoundInterval: NodeJS.Timeout | null = null;
    private testRoundTimeout: NodeJS.Timeout | null = null;

    constructor(private world: World, private blockManager: MovingBlockManager) {}

    // Getter methods for configuration
    private get defaultSpawnBounds(): { min: Vector3Like, max: Vector3Like } {
        return {
            min: { x: -8, y: 2, z: -12 },
            max: { x: 8, y: 5, z: 12 }
        };
    }

    private get sineWaveSpawnBounds(): { min: Vector3Like, max: Vector3Like } {
        return {
            min: { x: -5, y: MOVING_BLOCK_CONFIG.SPAWN_POSITION.y, z: MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.min.z },
            max: { x: 5, y: MOVING_BLOCK_CONFIG.SPAWN_POSITION.y, z: MOVING_BLOCK_CONFIG.MOVEMENT_BOUNDS.max.z }
        };
    }

    private get popUpSpawnBounds(): { min: Vector3Like, max: Vector3Like } {
        return {
            min: { x: -5, y: MOVING_BLOCK_CONFIG.POPUP_TARGET.START_Y, z: -10 },
            max: { x: 5, y: MOVING_BLOCK_CONFIG.POPUP_TARGET.START_Y, z: 10 }
        };
    }

    private get risingSpawnBounds(): { min: Vector3Like, max: Vector3Like } {
        return {
            min: { x: -5, y: MOVING_BLOCK_CONFIG.RISING_TARGET.START_Y, z: -10 },
            max: { x: 5, y: MOVING_BLOCK_CONFIG.RISING_TARGET.START_Y, z: 10 }
        };
    }

    private get parabolicSpawnBounds(): { min: Vector3Like, max: Vector3Like } {
        return {
            min: { 
                x: MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SPAWN_BOUNDS.LATERAL.MIN,
                y: MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.START_Y, 
                z: MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SPAWN_BOUNDS.FORWARD.MIN
            },
            max: { 
                x: MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SPAWN_BOUNDS.LATERAL.MAX,
                y: MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.START_Y, 
                z: MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SPAWN_BOUNDS.FORWARD.MAX
            }
        };
    }

    private get pendulumSpawnBounds(): { min: Vector3Like, max: Vector3Like } {
        return {
            min: { 
                x: MOVING_BLOCK_CONFIG.PENDULUM_TARGET.SPAWN_BOUNDS.LATERAL.MIN,
                y: 0,
                z: MOVING_BLOCK_CONFIG.PENDULUM_TARGET.SPAWN_BOUNDS.FORWARD.MIN
            },
            max: { 
                x: MOVING_BLOCK_CONFIG.PENDULUM_TARGET.SPAWN_BOUNDS.LATERAL.MAX,
                y: MOVING_BLOCK_CONFIG.PENDULUM_TARGET.PIVOT_HEIGHT,
                z: MOVING_BLOCK_CONFIG.PENDULUM_TARGET.SPAWN_BOUNDS.FORWARD.MAX
            }
        };
    }

    // Helper methods for safe position checking
    private isPositionSafeFromPlatforms(position: Vector3Like): boolean {
        const safetyMargin = MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.PLATFORM_SAFETY_MARGIN;
        
        // Check distance from right platform
        const rightPlatformDistance = Math.abs(position.x - MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.RIGHT_PLATFORM_EDGE.X);
        const isInRightPlatformZRange = position.z >= MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.RIGHT_PLATFORM_EDGE.Z_MIN - safetyMargin && 
                                      position.z <= MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.RIGHT_PLATFORM_EDGE.Z_MAX + safetyMargin;
        
        // Check distance from left platform
        const leftPlatformDistance = Math.abs(position.x - MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.LEFT_PLATFORM_EDGE.X);
        const isInLeftPlatformZRange = position.z >= MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.LEFT_PLATFORM_EDGE.Z_MIN - safetyMargin && 
                                     position.z <= MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.LEFT_PLATFORM_EDGE.Z_MAX + safetyMargin;
        
        // A position is safe if it's either:
        // 1. Far enough from the right platform OR not in its Z range
        // 2. Far enough from the left platform OR not in its Z range
        const isSafeFromRightPlatform = rightPlatformDistance >= MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.PLATFORM_SAFETY_MARGIN || 
                                      !isInRightPlatformZRange;
        const isSafeFromLeftPlatform = leftPlatformDistance >= MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.PLATFORM_SAFETY_MARGIN || 
                                     !isInLeftPlatformZRange;
        
        return isSafeFromRightPlatform && isSafeFromLeftPlatform;
    }

    private getRandomPositionWithinBounds(bounds: {min: Vector3Like, max: Vector3Like}): Vector3Like {
        return {
            x: Math.random() * (bounds.max.x - bounds.min.x) + bounds.min.x,
            y: Math.random() * (bounds.max.y - bounds.min.y) + bounds.min.y,
            z: Math.random() * (bounds.max.z - bounds.min.z) + bounds.min.z,
        };
    }

    private getSafeRandomPosition(bounds: {min: Vector3Like, max: Vector3Like}, maxAttempts: number = 50): Vector3Like {
        let attempts = 0;
        let position: Vector3Like;

        do {
            position = this.getRandomPositionWithinBounds(bounds);
            attempts++;

            if (attempts >= maxAttempts) {
                // If we can't find a safe position, return a default position in the middle
                return {
                    x: 0,
                    y: bounds.min.y + (bounds.max.y - bounds.min.y) / 2,
                    z: 0
                };
            }
        } while (!this.isPositionSafeFromPlatforms(position));

        return position;
    }

    // Modify the existing position generation methods to use the safe check
    private getRandomPosition(): Vector3Like {
        return this.getSafeRandomPosition(this.defaultSpawnBounds);
    }

    private getRandomPopUpPosition(): Vector3Like {
        const bounds = this.popUpSpawnBounds;
        const safePosition = this.getSafeRandomPosition(bounds);
        return {
            x: safePosition.x,
            y: bounds.min.y, // Fixed Y position for pop-up targets
            z: safePosition.z
        };
    }

    private getRandomRisingPosition(): Vector3Like {
        const bounds = this.risingSpawnBounds;
        const safePosition = this.getSafeRandomPosition(bounds);
        return {
            x: safePosition.x,
            y: bounds.min.y, // Fixed Y position for rising targets
            z: safePosition.z
        };
    }

    private getRandomParabolicPosition(): Vector3Like {
        const bounds = this.parabolicSpawnBounds;
        const safePosition = this.getSafeRandomPosition(bounds);
        return {
            x: safePosition.x,
            y: bounds.min.y, // Fixed Y position for parabolic targets
            z: safePosition.z
        };
    }

    // Helper methods for safe pendulum spawning
    private isPositionSafeFromOtherPendulums(position: Vector3Like): boolean {
        const existingPendulums = this.world.entityManager.getAllEntities()
            .filter(entity => entity.name.toLowerCase().includes('block') && 
                            entity.isSpawned);

        for (const pendulum of existingPendulums) {
            const xDistance = Math.abs(position.x - pendulum.position.x);
            const zDistance = Math.abs(position.z - pendulum.position.z);

            if (xDistance < MOVING_BLOCK_CONFIG.PENDULUM_TARGET.SPAWN_SPACING.MIN_X_DISTANCE &&
                zDistance < MOVING_BLOCK_CONFIG.PENDULUM_TARGET.SPAWN_SPACING.MIN_Z_DISTANCE) {
                return false;
            }
        }

        return true;
    }

    private getSafePendulumPosition(): Vector3Like {
        let attempts = 0;
        const maxAttempts = 50;
        let position: Vector3Like;

        do {
            position = this.getRandomPendulumPosition();
            attempts++;

            if (attempts >= maxAttempts) {
                // If we can't find a safe position after max attempts,
                // return a default position in the middle of the map
                return {
                    x: 0,
                    y: MOVING_BLOCK_CONFIG.PENDULUM_TARGET.PIVOT_HEIGHT,
                    z: 0
                };
            }
        } while (!this.isPositionSafeFromPlatforms(position) || 
                 !this.isPositionSafeFromOtherPendulums(position));

        return position;
    }

    private getRandomPendulumPosition(): Vector3Like {
        const bounds = this.pendulumSpawnBounds;
        const safetyMargin = MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.PLATFORM_SAFETY_MARGIN;
        
        // Calculate safe spawn range excluding areas near platforms
        const minX = Math.max(
            bounds.min.x,
            MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.LEFT_PLATFORM_EDGE.X + safetyMargin
        );
        const maxX = Math.min(
            bounds.max.x,
            MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.RIGHT_PLATFORM_EDGE.X - safetyMargin
        );

        // Calculate safe Z range
        const minZ = Math.max(
            bounds.min.z,
            Math.min(
                MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.LEFT_PLATFORM_EDGE.Z_MIN,
                MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.RIGHT_PLATFORM_EDGE.Z_MIN
            ) + safetyMargin
        );
        const maxZ = Math.min(
            bounds.max.z,
            Math.max(
                MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.LEFT_PLATFORM_EDGE.Z_MAX,
                MOVING_BLOCK_CONFIG.PLATFORM_SAFETY.RIGHT_PLATFORM_EDGE.Z_MAX
            ) - safetyMargin
        );
        
        // Randomly choose a position within the safe range
        const pivotX = Math.random() * (maxX - minX) + minX;
        const pivotZ = Math.random() * (maxZ - minZ) + minZ;
        
        return {
            x: pivotX,
            y: MOVING_BLOCK_CONFIG.PENDULUM_TARGET.PIVOT_HEIGHT,
            z: pivotZ
        };
    }

    // Block spawning methods
    public spawnTestBlocks(speedMultiplier: number = 1): void {
        if (this.DEBUG_ENABLED) {
            // Remove debug log
        }

        // Clear existing blocks first
        this.clearAllBlocks();

        // Spawn one of each type
        this.spawnStaticTarget();
        this.spawnSineWaveBlock(speedMultiplier);
        this.spawnVerticalWaveBlock(speedMultiplier);
        this.spawnRegularBlock();
        this.spawnPopUpTarget(speedMultiplier);
        this.spawnRisingTarget(speedMultiplier);
        this.spawnParabolicTarget(speedMultiplier);
        this.spawnPendulumTarget(speedMultiplier);

        if (this.DEBUG_ENABLED) {
            // Remove debug log
        }
    }

    public clearAllBlocks(): void {
        if (this.DEBUG_ENABLED) {
            // Remove debug log
        }

        const removedCount = this.world.entityManager.getAllEntities()
            .filter(entity => entity.name.toLowerCase().includes('block'))
            .map(entity => {
                entity.despawn();
                return entity;
            }).length;

        if (this.DEBUG_ENABLED) {
            // Remove debug log
        }
    }

    public spawnStaticTarget(): void {
        const pos = this.getRandomPosition();
        pos.y = 2 + Math.random() * 4; // Higher range for static targets

        if (this.DEBUG_ENABLED) {
            // Remove debug log
        }

        // Create static target with position
        this.blockManager.createStaticTarget(pos);
    }

    public spawnSineWaveBlock(speedMultiplier: number = 1): void {
        const pos = this.getRandomPositionWithinBounds(this.sineWaveSpawnBounds);
        
        if (this.DEBUG_ENABLED) {
            // Remove debug log
        }

        this.blockManager.createSineWaveBlock({
            spawnPosition: pos,
            moveSpeed: MOVING_BLOCK_CONFIG.DEFAULT_SPEED * speedMultiplier,
            amplitude: 2 + Math.random() * 2,
            blockTextureUri: 'blocks/nuit.png' // Keep the mystical pattern for sine wave
        });
    }

    public spawnVerticalWaveBlock(speedMultiplier: number = 1): void {
        const pos = this.getRandomPosition();
        const spawnPosition = {
            ...pos,
            y: Math.min(MOVING_BLOCK_CONFIG.VERTICAL_WAVE.HEIGHT_OFFSET, 7)
        };

        if (this.DEBUG_ENABLED) {
            // Remove debug log
        }

        this.blockManager.createVerticalWaveBlock({
            spawnPosition,
            moveSpeed: MOVING_BLOCK_CONFIG.DEFAULT_SPEED * speedMultiplier * MOVING_BLOCK_CONFIG.VERTICAL_WAVE.SPEED_MULTIPLIER,
            blockTextureUri: MOVING_BLOCK_CONFIG.VERTICAL_WAVE.TEXTURE // Using infected-shadowrock (red pattern)
        });
    }

    public spawnRegularBlock(): void {
        const pos = this.getRandomPositionWithinBounds(this.sineWaveSpawnBounds);

        if (this.DEBUG_ENABLED) {
            // Remove debug log
        }

        // Create regular block with default texture
        const block = this.blockManager.createZAxisBlock(pos);
        
        // Try to manually force a movement to test if the block can move
        if (block && block.position) {
            console.log("Initial block position:", block.position);
            
            // Force a position update to verify the block can be moved
            setTimeout(() => {
                if (block.isSpawned) {
                    const newPos = {
                        x: block.position.x + 1,
                        y: block.position.y + 1,
                        z: block.position.z + 1
                    };
                    block.setPosition(newPos);
                    console.log("Forced new block position:", newPos);
                }
            }, 1000);
        }
    }

    public spawnPopUpTarget(speedMultiplier: number = 1): void {
        const pos = this.getRandomPopUpPosition();

        if (this.DEBUG_ENABLED) {
            // Remove debug log
        }

        this.blockManager.createPopUpTarget({
            spawnPosition: pos,
            startY: MOVING_BLOCK_CONFIG.POPUP_TARGET.START_Y,
            topY: MOVING_BLOCK_CONFIG.POPUP_TARGET.TOP_Y,
            moveSpeed: MOVING_BLOCK_CONFIG.DEFAULT_SPEED * speedMultiplier * MOVING_BLOCK_CONFIG.POPUP_TARGET.SPEED_MULTIPLIER,
            blockTextureUri: MOVING_BLOCK_CONFIG.POPUP_TARGET.TEXTURE // Using diamond-ore
        });
    }

    public spawnRisingTarget(speedMultiplier: number = 1): void {
        const pos = this.getRandomRisingPosition();

        if (this.DEBUG_ENABLED) {
            // Remove debug log
        }

        this.blockManager.createRisingTarget({
            spawnPosition: pos,
            startY: MOVING_BLOCK_CONFIG.RISING_TARGET.START_Y,
            firstStopY: MOVING_BLOCK_CONFIG.RISING_TARGET.FIRST_STOP_Y,
            finalY: MOVING_BLOCK_CONFIG.RISING_TARGET.FINAL_Y,
            moveSpeed: MOVING_BLOCK_CONFIG.DEFAULT_SPEED * speedMultiplier * MOVING_BLOCK_CONFIG.RISING_TARGET.SPEED_MULTIPLIER,
            pauseDuration: MOVING_BLOCK_CONFIG.RISING_TARGET.PAUSE_DURATION,
            blockTextureUri: MOVING_BLOCK_CONFIG.RISING_TARGET.TEXTURE // Using emerald-ore
        });
    }

    public spawnParabolicTarget(speedMultiplier: number = 1): void {
        const startPos = this.getRandomParabolicPosition();
        const endPos = this.getRandomParabolicPosition();
        
        // Ensure minimum forward distance and proper direction
        const forwardDistance = endPos.z - startPos.z;
        if (forwardDistance < MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.MIN_TRAVEL_DISTANCE) {
            endPos.z = Math.min(
                startPos.z + MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.MIN_TRAVEL_DISTANCE,
                MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.SPAWN_BOUNDS.FORWARD.MAX
            );
        }

        if (this.DEBUG_ENABLED) {
            // Remove debug log
        }

        this.blockManager.createParabolicTarget({
            startPoint: startPos,
            endPoint: endPos,
            maxHeight: MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.MAX_HEIGHT,
            duration: MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.DURATION / speedMultiplier,
            blockTextureUri: MOVING_BLOCK_CONFIG.PARABOLIC_TARGET.TEXTURE // Using swirl-rune
        });
    }

    public spawnPendulumTarget(speedMultiplier: number = 1): void {
        const pivotPoint = this.getSafePendulumPosition();

        if (this.DEBUG_ENABLED) {
            console.log(`Spawning pendulum at (${pivotPoint.x.toFixed(2)}, ${pivotPoint.y.toFixed(2)}, ${pivotPoint.z.toFixed(2)})`);
        }

        // Validate the spawn position
        if (!this.isValidSpawnPosition(pivotPoint, 'pendulum')) {
            console.warn('Invalid pendulum spawn position, using default center position');
            pivotPoint.x = 0;
            pivotPoint.z = 0;
        }

        this.blockManager.createPendulumTarget({
            pivotPoint,
            length: MOVING_BLOCK_CONFIG.PENDULUM_TARGET.LENGTH,
            amplitude: MOVING_BLOCK_CONFIG.PENDULUM_TARGET.AMPLITUDE,
            frequency: MOVING_BLOCK_CONFIG.PENDULUM_TARGET.FREQUENCY * speedMultiplier,
            blockTextureUri: MOVING_BLOCK_CONFIG.PENDULUM_TARGET.TEXTURE // Using nuit-leaves (green pattern)
        });
    }

    // Helper methods for block validation
    public isValidSpawnPosition(position: Vector3Like, type: 'static' | 'sine' | 'vertical' | 'regular' | 'popup' | 'rising' | 'parabolic' | 'pendulum'): boolean {
        switch (type) {
            case 'static':
                return position.y >= 2 && position.y <= 6;
            case 'sine':
                return this.isWithinBounds(position, this.sineWaveSpawnBounds);
            case 'vertical':
                return position.y <= MOVING_BLOCK_CONFIG.VERTICAL_WAVE.HEIGHT_OFFSET;
            case 'regular':
                return this.isWithinBounds(position, this.sineWaveSpawnBounds);
            case 'popup':
                return this.isWithinBounds(position, this.popUpSpawnBounds);
            case 'rising':
                return this.isWithinBounds(position, this.risingSpawnBounds);
            case 'parabolic':
                return this.isWithinBounds(position, this.parabolicSpawnBounds);
            case 'pendulum':
                return this.isWithinBounds(position, this.pendulumSpawnBounds);
            default:
                return false;
        }
    }

    private isWithinBounds(position: Vector3Like, bounds: { min: Vector3Like, max: Vector3Like }): boolean {
        return (
            position.x >= bounds.min.x && position.x <= bounds.max.x &&
            position.y >= bounds.min.y && position.y <= bounds.max.y &&
            position.z >= bounds.min.z && position.z <= bounds.max.z
        );
    }

    public startTestRound(speedMultiplier: number = 1.2): void {
        // Clear any existing round
        this.stopTestRound();
        
        // Configuration for test round
        const config = {
            minBlockCount: 10,  // Start with fewer blocks for testing
            maxBlockCount: 20,
            spawnInterval: 2000,  // 2 seconds between spawns
            duration: 60000,      // 1 minute round
            speedMultiplier
        };

        // Initial block spawning
        for (let i = 0; i < config.minBlockCount; i++) {
            setTimeout(() => {
                this.spawnRandomBlock(config.speedMultiplier);
            }, i * 1000); // Stagger initial spawns by 1 second
        }

        // Periodic spawning
        this.testRoundInterval = setInterval(() => {
            const currentBlocks = this.blockManager.getBlockCount();
            if (currentBlocks < config.maxBlockCount) {
                this.spawnRandomBlock(config.speedMultiplier);
            }
        }, config.spawnInterval);

        // End round after duration
        this.testRoundTimeout = setTimeout(() => {
            this.stopTestRound();
        }, config.duration);
    }

    public stopTestRound(): void {
        if (this.testRoundInterval) {
            clearInterval(this.testRoundInterval);
            this.testRoundInterval = null;
        }
        if (this.testRoundTimeout) {
            clearTimeout(this.testRoundTimeout);
            this.testRoundTimeout = null;
        }
        this.clearAllBlocks();
    }

    private spawnRandomBlock(speedMultiplier: number): void {
        const blockType = Math.random();
        if (blockType < 0.15) {
            this.spawnStaticTarget();
        } else if (blockType < 0.3) {
            this.spawnSineWaveBlock(speedMultiplier);
        } else if (blockType < 0.45) {
            this.spawnVerticalWaveBlock(speedMultiplier);
        } else if (blockType < 0.6) {
            this.spawnPopUpTarget(speedMultiplier);
        } else if (blockType < 0.75) {
            this.spawnRisingTarget(speedMultiplier);
        } else if (blockType < 0.9) {
            this.spawnParabolicTarget(speedMultiplier);
        } else {
            this.spawnPendulumTarget(speedMultiplier);
        }
    }
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "allowJs": true,
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "./dist",
    "types": ["jest", "node"],
    "allowSyntheticDefaultImports": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}



================================================================
End of Codebase
================================================================
