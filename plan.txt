Phase 1: Projectile Foundation (TDD First)

Test Cases to Implement First:

// projectile.test.ts
describe('Projectile System', () => {
  test('should create projectile entity with physics properties', () => {
    // Test mass, collider setup, initial forces
  });

  test('should apply impulse force in camera direction on throw', () => {
    // Verify force calculations match input direction
  });

  test('should detect projectile-block collisions', () => {
    // Raycast-like collision detection for dynamic bodies
  });

  test('should despawn projectile after lifetime expiration', () => {
    // Test entity cleanup system
  });
});



Implementation Steps:

Create ProjectileEntity class extending SDK's Entity
2. Add physics properties to projectile:

class ProjectileEntity extends Entity {
  constructor(options: ProjectileOptions) {
    super({
      ...options,
      rigidBodyType: 'dynamic',
      colliders: [/* sphere collider */]
    });
  }
}


Phase 2: Raycast-Projectile Integration

Key SDK Features to Leverage:
RigidBody.applyImpulse() 1
RaycastOptions.filterExcludeRigidBody (from your block breaking example)
3. Collision groups 2
Modification Plan:
1. Extend RaycastHandler to return both block and entity hits

        const result = this.world.simulation.raycast(origin, direction, length, options);
        
        if (!result) {
            this.log('No hit detected');
            return null;
        }



Add entity detection:

throwProjectile(origin: Vector3, direction: Vector3, force: number) {
  const projectile = new ProjectileEntity(...);
  projectile.rawRigidBody.applyImpulse(
    Vector3.multiply(direction, force)
  );
}



Phase 3: Collision & Impact Effects
TDD First:


test('should spawn impact effect on projectile collision', () => {
  // Verify particle system/VFX creation
});

test('should damage entities on direct hit', () => {
  // Test health system integration
});



Implementation Strategy:
1. Use SDK's collision events:


world.simulation.onCollision((event) => {
  if(event.body1 === projectile.rawRigidBody) {
    // Handle impact
  }
});


Codebase Recommendations
1. Keep:
Current raycast validation logic
Debug visualization system
Input handling architecture
2. Refactor:
Extract physics operations to dedicated PhysicsService
Add entity pooling for projectiles



